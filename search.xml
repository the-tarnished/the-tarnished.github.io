<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Geatpy学习</title>
      <link href="/2022/01/22/Geatpy%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/01/22/Geatpy%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="geatpy"><a href="#geatpy" class="headerlink" title="geatpy"></a>geatpy</h1><p>address:<a href="http://geatpy.com/index.php/home/">http://geatpy.com/index.php/home/</a></p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模,Geatpy,Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matplotlib学习</title>
      <link href="/2022/01/22/Matplotlib%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/01/22/Matplotlib%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h1><p>address:<a href="https://www.matplotlib.org.cn/tutorials/#%E5%BA%8F%E8%A8%80">https://www.matplotlib.org.cn/tutorials/#%E5%BA%8F%E8%A8%80</a></p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python,Matplotlib,数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scipy学习</title>
      <link href="/2022/01/22/Scipy%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/01/22/Scipy%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Scipy"><a href="#Scipy" class="headerlink" title="Scipy"></a>Scipy</h1><p>address:<a href="https://scipy.github.io/devdocs/tutorial/index.html">https://scipy.github.io/devdocs/tutorial/index.html</a></p><h2 id="Scipy内置模块"><a href="#Scipy内置模块" class="headerlink" title="Scipy内置模块"></a>Scipy内置模块</h2><table><thead><tr><th align="left">模块名</th><th align="left">功能</th><th align="left">参考文档</th></tr></thead><tbody><tr><td align="left">scipy.constants</td><td align="left">数学常量</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/constants.html">constants API</a></td></tr><tr><td align="left">scipy.cluster</td><td align="left">向量量化</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/cluster.html#module-scipy.cluster">cluster API</a></td></tr><tr><td align="left">scipy.fftpack</td><td align="left">快速傅里叶变换</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/fftpack.html#module-scipy.fftpack">fft API</a></td></tr><tr><td align="left">scipy.integrate</td><td align="left">积分</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/integrate.html#module-scipy.integrate">integrate API</a></td></tr><tr><td align="left">scipy.interpolate</td><td align="left">插值</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/interpolate.html#module-scipy.interpolate">interpolate API</a></td></tr><tr><td align="left">scipy.io</td><td align="left">数据输入输出</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/io.html#module-scipy.io">io API</a></td></tr><tr><td align="left">scipy.linalg</td><td align="left">线性代数</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/linalg.html#module-scipy.linalg">linalg API</a></td></tr><tr><td align="left">scipy.ndimage</td><td align="left">N 维图像</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/ndimage.html#module-scipy.ndimage">ndimage API</a></td></tr><tr><td align="left">scipy.odr</td><td align="left">正交距离回归</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/odr.html#module-scipy.odr">odr API</a></td></tr><tr><td align="left">scipy.optimize</td><td align="left">优化算法</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/optimize.html#module-scipy.optimize">optimize API</a></td></tr><tr><td align="left">scipy.signal</td><td align="left">信号处理</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/signal.html#module-scipy.signal">signal API</a></td></tr><tr><td align="left">scipy.sparse</td><td align="left">稀疏矩阵</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/sparse.html#module-scipy.sparse">sparse API</a></td></tr><tr><td align="left">scipy.spatial</td><td align="left">空间数据结构和算法</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/spatial.html#module-scipy.spatial">spatial API</a></td></tr><tr><td align="left">scipy.special</td><td align="left">特殊数学函数</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/special.html#module-scipy.special">special API</a></td></tr><tr><td align="left">scipy/stats</td><td align="left">统计函数</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/stats.html#module-scipy.stats">stats.mstats API</a></td></tr><tr><td align="left">scipy.misc</td><td align="left">图像处理</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/misc.html">misc API</a></td></tr></tbody></table><h2 id="Scipy常数模块"><a href="#Scipy常数模块" class="headerlink" title="Scipy常数模块"></a>Scipy常数模块</h2><p><code>Scipy.constants</code>模块内置多种常数,包括:</p><ul><li>公制单位</li><li>字节为单位的二进制</li><li>质量单位</li><li>角度换算</li><li>时间单位</li><li>长度单位</li><li>压强单位</li><li>体积单位</li><li>速度单位</li><li>温度单位</li><li>能量单位</li><li>功率单位</li><li>力学单位</li></ul><h2 id="Scipy-cluster模块"><a href="#Scipy-cluster模块" class="headerlink" title="Scipy cluster模块"></a>Scipy cluster模块</h2><p>这个模块分为vq模块和hierarchy模块.</p><h3 id="vq模块"><a href="#vq模块" class="headerlink" title="vq模块"></a>vq模块</h3><p>此模块实现k-means算法和向量量化.</p><h4 id="K-means算法"><a href="#K-means算法" class="headerlink" title="K-means算法"></a>K-means算法</h4><ul><li>1.首先给定需要的类/簇个数n</li><li>2.随机定n个簇心</li><li>3.将每个点分在离它最近的簇心</li><li>4.对于每个簇心,计算属于它的点集的平均点,该点为新的簇心</li><li>5.在获得新的n个簇心之后,重复 3,4步骤,如果划分新的点集的时候,点集没有变则循环结束.</li></ul><h3 id="hierarchy模块"><a href="#hierarchy模块" class="headerlink" title="hierarchy模块"></a>hierarchy模块</h3><p><del>这一块的数理逻辑暂且看不懂,之后再更新.应该吧</del></p><h2 id="Scipy-fftpack模块"><a href="#Scipy-fftpack模块" class="headerlink" title="Scipy fftpack模块"></a>Scipy fftpack模块</h2><p>fftpack模块提供了快速傅里叶变化的方法.</p><h3 id="一维离散傅里叶变换"><a href="#一维离散傅里叶变换" class="headerlink" title="一维离散傅里叶变换"></a>一维离散傅里叶变换</h3><p>长度为n的x序列,通过fft方法算出其在复数域上的映射a+bi.ifft方法是逆傅里叶变换.</p><h3 id="离散余弦变换"><a href="#离散余弦变换" class="headerlink" title="离散余弦变换"></a>离散余弦变换</h3><p>离散余弦变换是实偶函数的傅里叶变换,不含虚数单位项.可以认为是0i.也即没有初项,只有振幅和频率两个参数.<br>Scipy提供了dct和idct方法求得</p><h2 id="Scipy-integrade模块"><a href="#Scipy-integrade模块" class="headerlink" title="Scipy integrade模块"></a>Scipy integrade模块</h2><p>下表是integrate库中的常用功能</p><table><thead><tr><th align="left">编号</th><th align="left">功能说明</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">quad单积分</td></tr><tr><td align="left">2</td><td align="left">dblquad双重积分</td></tr><tr><td align="left">3</td><td align="left">tplquad三重积分</td></tr><tr><td align="left">4</td><td align="left">nquadn倍多重积分</td></tr><tr><td align="left">5</td><td align="left">fixed_quad高斯积分，阶数n</td></tr><tr><td align="left">6</td><td align="left">quadrature高斯正交到容差</td></tr><tr><td align="left">7</td><td align="left">romberg隆伯格积分</td></tr><tr><td align="left">8</td><td align="left">trapz梯形法则</td></tr><tr><td align="left">9</td><td align="left">cumtrapz梯形法则累计计算积分</td></tr><tr><td align="left">10</td><td align="left">simps辛普森的规则</td></tr><tr><td align="left">11</td><td align="left">romb隆伯格整合</td></tr><tr><td align="left">12</td><td align="left">polyint分析多项式积分（NumPy）</td></tr><tr><td align="left">13</td><td align="left">poly1d辅助函数polyint（NumPy）</td></tr></tbody></table><h3 id="quad-单积分"><a href="#quad-单积分" class="headerlink" title="quad 单积分"></a>quad 单积分</h3><p>$\int_a^bf\left(x\right)dx$ == quad(f,a,b)</p><p>quad返回两个值,第一个是积分结果,第二个是积分的绝对误差</p><p>实例:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> scipy<span class="token punctuation">.</span>integrate<span class="token keyword">from</span> numpy <span class="token keyword">import</span> expf<span class="token operator">=</span> <span class="token keyword">lambda</span> x<span class="token punctuation">:</span>exp<span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">)</span>i <span class="token operator">=</span> scipy<span class="token punctuation">.</span>integrate<span class="token punctuation">.</span>quad<span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">print</span> i<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="双重积分"><a href="#双重积分" class="headerlink" title="双重积分"></a>双重积分</h3><p>对于积分<br>$$\int_a^bdx\int_{g(x)}^{h(x)}dyf(x,y)$$<br>其等价于<code>dblquad（func，a，b，gfun，hfun)</code></p><p>其中func是<code>f(x,y)</code>这个复合函数 <code>a</code>,<code>b</code>是<code>x</code>的上下限,<code>gfunc</code>和<code>hfunc</code>是y的上下限.</p><p>输出和单积分相同,一个是积分结果,一个是绝对误差,</p><h2 id="interpolate-插值"><a href="#interpolate-插值" class="headerlink" title="interpolate 插值"></a>interpolate 插值</h2><h3 id="什么是插值"><a href="#什么是插值" class="headerlink" title="什么是插值"></a>什么是插值</h3><p>插值就是在离散数据的基础上补插连续函数,使得连续函数通过这些离散点.这是离散函数逼近的重要方法.</p><h3 id="Interp1d"><a href="#Interp1d" class="headerlink" title="Interp1d"></a>Interp1d</h3><p>scipy.interpolate中的interp1d类是一种基于固定数据点创建函数的便捷方法.</p><pre class="line-numbers language-none"><code class="language-none">interp1d(datax,datay,kind)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中的datax,datay分别为离散参数,kind是插值方式,比如线性(liner),最近(nearest),零,二次(cubic),立方等.</p><h3 id="多维数据插值-griddata"><a href="#多维数据插值-griddata" class="headerlink" title="多维数据插值-griddata"></a>多维数据插值-griddata</h3><pre class="line-numbers language-none"><code class="language-none">griddata(points,value,point_grid,method)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数解释:</p><ul><li>points 是每个点的坐标</li><li>value 是点相应的函数结果值</li><li>point_grid 是你要想获得结果的点的坐标</li><li>method 是插值方法</li></ul><p>这个方法返回的是点的函数结果</p><h3 id="单变量样条"><a href="#单变量样条" class="headerlink" title="单变量样条"></a>单变量样条</h3><p>UnivariateSpline是基于固定数据点类创建函数的便捷方法.</p><pre class="line-numbers language-none"><code class="language-none">scipy.interpolate.UnivariateSpline（x，y，w &#x3D; None，bbox &#x3D; [None，None]，k &#x3D; 3，s &#x3D;无，ext &#x3D; 0，check_finite &#x3D; False）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数解释:</p><ul><li>‘w’ - 指定样条拟合的权重。 必须是正数的。 如果没有（默认），权重都是相等的。</li><li>‘s’ - 通过指定平滑条件指定结的数量。</li><li>‘k’ - 平滑样条曲线的度数。 必须&lt;= 5.默认值为k = 3，三次样条曲线。</li><li>Ext - 控制不在结节序列定义的区间内的元素的外推模式。</li><li><ul><li>如果ext = 0或’extrapolate’，则返回外推值。</li></ul></li><li><ul><li>如果ext = 1或’0’，则返回0</li></ul></li><li><ul><li>如果ext = 2或’raise’，则引发ValueError</li></ul></li><li><ul><li>如果ext = 3’const’，则返回边界值。 </li></ul></li><li>check_finite - 是否检查输入数组是否仅包含有限数字。 </li></ul>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模,Scipy,Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy学习</title>
      <link href="/2022/01/19/Numpy%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/01/19/Numpy%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h1><p>address:<a href="https://www.numpy.org.cn/reference/">https://www.numpy.org.cn/reference/</a></p><h2 id="Ndarray对象"><a href="#Ndarray对象" class="headerlink" title="Ndarray对象"></a>Ndarray对象</h2><ul><li><code>Ndarray</code>等价于多维数组</li><li>构造方法:<pre class="line-numbers language-none"><code class="language-none">numpy.array(object, dtype &#x3D; None, copy &#x3D; True, order &#x3D; None, subok &#x3D; False, ndmin &#x3D; 0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><code>object</code>:数组或者嵌套的数列<br><code>dtype</code>:数组元素的数据类型,可选<br><code>copy</code>:数组是否需要复制,如果为false,则是对原数组的引用<br><code>order</code>:数组在内存中样式<br><code>subok</code>:默认返回一个与基类类型一致的数组<br><code>ndmin</code>:数组最小维度</p></blockquote><h2 id="数据类型对象dtype"><a href="#数据类型对象dtype" class="headerlink" title="数据类型对象dtype"></a>数据类型对象dtype</h2><code>dtype</code>实例是用来描述与数组对应的内存区域是如何使用的.</li><li>数据类型</li><li>数据大小</li><li>数据的字节顺序(大小端,&lt;表示小端,&gt;表示大端)</li><li>在结构化类型下,字段的名称,每个字段的数据类型和每个字段所取得内存块得部分</li><li>如果数据类型是子数组,描述其形状和数据类型</li></ul><p>构造:</br><br><code>numpy.dtype(object, align, copy)</code></p><p>类似于C的<code>struct</code>,要指明类型索引和类型输于的数据结构,如</p><pre class="line-numbers language-none"><code class="language-none">d &#x3D; dtype([(&#39;name&#39;,&#96;S20&#96;),((&#39;grade&#39;,&#39;int8&#39;))])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Numpy数组属性"><a href="#Numpy数组属性" class="headerlink" title="Numpy数组属性"></a>Numpy数组属性</h2><table><thead><tr><th align="left">属性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">ndarray.ndim</td><td align="left">秩，即轴的数量或维度的数量</td></tr><tr><td align="left">ndarray.shape</td><td align="left">数组的维度，对于矩阵，n 行 m 列</td></tr><tr><td align="left">ndarray.size</td><td align="left">数组元素的总个数，相当于 .shape 中 n*m 的值</td></tr><tr><td align="left">ndarray.dtype</td><td align="left">ndarray 对象的元素类型</td></tr><tr><td align="left">ndarray.itemsize</td><td align="left">ndarray 对象中每个元素的大小，以字节为单位</td></tr><tr><td align="left">ndarray.flags</td><td align="left">ndarray 对象的内存信息</td></tr><tr><td align="left">ndarray.real</td><td align="left">ndarray元素的实部</td></tr><tr><td align="left">ndarray.imag</td><td align="left">ndarray 元素的虚部</td></tr><tr><td align="left">ndarray.data</td><td align="left">包含实际数组元素的缓冲区，由于一般通过数组的索引获取元素，所以通常不需要使用这个属性。</td></tr></tbody></table><h2 id="Numpy创建数组"><a href="#Numpy创建数组" class="headerlink" title="Numpy创建数组"></a>Numpy创建数组</h2><ul><li><p>numpy.empty创建一个指定形状,指定数据类型的未初始化数组 <code>= np.empty([3,2], dtype = int)</code></p></li><li><p>numpy.zero创建一个指定大小,0填充的数组,默认为浮点数<code>numpy.zeros(shape, dtype = float, order = &#39;C&#39;)</code></p></li><li><p>numpy.one创建一个指定形状,1填充的数组,默认为浮点数<code>x = np.ones([2,2], dtype = int)</code></p></li><li><p>numpy.asarray类似array</p><blockquote><p><code>numpy.asarray(a, dtype = None, order = None)</code></p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">a</td><td align="left">任意形式的输入参数，可以是，列表, 列表的元组, 元组, 元组的元组, 元组的列表，多维数组</td></tr><tr><td align="left">dtype</td><td align="left">数据类型，可选</td></tr><tr><td align="left">order</td><td align="left">可选，有”C”和”F”两个选项,分别代表，行优先和列优先，在计算机内存中的存储元素的顺序。</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">&gt;x &#x3D;  [1,2,3] &gt;a &#x3D; np.asarray(x)  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote></li><li><p>numpy.frombuffer用于实现动态数组,接受buffer输入参数,以流的形式读入转化成ndarray对象.</p><blockquote><p><code>numpy.frombuffer(buffer, dtype = float, count = -1, offset = 0)</code></p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">buffer</td><td align="left">可以是任意对象，会以流的形式读入。</td></tr><tr><td align="left">dtype</td><td align="left">返回数组的数据类型，可选</td></tr><tr><td align="left">count</td><td align="left">读取的数据数量，默认为-1，读取所有数据。</td></tr><tr><td align="left">offset</td><td align="left">读取的起始位置，默认为0。</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">&gt;s &#x3D;  b&#39;Hello World&#39; &gt;a &#x3D; np.frombuffer(s, dtype &#x3D;  &#39;S1&#39;)  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote></li><li><p>numpy.fromiter 从可迭代对象中建立ndarray对象.</p><blockquote><p><code>numpy.fromiter(iterable, dtype, count=-1)</code></p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">iterable</td><td align="left">可迭代对象</td></tr><tr><td align="left">dtype</td><td align="left">返回数组的数据类型</td></tr><tr><td align="left">count</td><td align="left">读取的数据数量，默认为-1，读取所有数据</td></tr></tbody></table></blockquote></li><li><p>numpy.arange创建数值范围并返回ndarray对象</br><br><code>numpy.arange(start, stop, step, dtype)</code></p></li><li><p>numpy.linspace创建一个等差数列组成的一维数组</br><br><code>np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)</code></p></li><li><p>numpy.logspace创建一个等比数列</br><br><code>np.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)</code></p><h2 id="Numpy切片"><a href="#Numpy切片" class="headerlink" title="Numpy切片"></a>Numpy切片</h2></li><li><p>可以通过创建slice类来对数组进行切片</p><pre class="line-numbers language-none"><code class="language-none">s &#x3D; slice(0,16,2)print(a[s])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>可以通过:和…切片</p><h2 id="Numpy索引"><a href="#Numpy索引" class="headerlink" title="Numpy索引"></a>Numpy索引</h2></li><li><p>整数数组索引</p><blockquote><p>设索引地址为x,y. x = {x1,x2,…xn}, y = {y1,y2,…yn},a[x,y] = [a[x1,y1],…,a[xn,yn]]</p><pre class="line-numbers language-none"><code class="language-none">&gt;import numpy as np &gt;x &#x3D; np.array([[  0,  1,  2],[  3,  4,  5],[  6,  7,  8],[  9,  10,  &gt;11]])  &gt;rows &#x3D; np.array([[0,0],[3,3]]) &gt;cols &#x3D; np.array([[0,2],[0,2]]) &gt;y &#x3D; x[rows,cols]  &gt;print (y) ##[y[0,0],y[0,2],y[3,0],y[3,2]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote></li><li><p>布尔索引</p><blockquote><p>x = bool运算 , a[x] = {ai | ai 属于 a 且 ai满足x}</p></blockquote></li><li><p>花式索引</p><blockquote><p>设索引地址为x, a[x] = {ai | ai的行坐标为xi}<br>设索引地址为x,y, a[x,y] = {ai | aij的行坐标为xi,aij的列坐标属于y}</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np  x<span class="token operator">=</span>np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span> <span class="token punctuation">(</span>x<span class="token punctuation">[</span>np<span class="token punctuation">.</span>ix_<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">"""[[ 4  7  5  6] [20 23 21 22] [28 31 29 30] [ 8 11  9 10]] """</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Numpy-的广播-broadcase"><a href="#Numpy-的广播-broadcase" class="headerlink" title="Numpy 的广播(broadcase)"></a>Numpy 的广播(broadcase)</h2><p>如果数组运算,这俩矩阵的shape不同,则触发broadcase.</p></li></ul><p>broadcase规则</p><ul><li>让所有输入数组都向其中形状最长的数组看齐，形状中不足的部分都通过在前面加 1 补齐。</li><li>输出数组的形状是输入数组形状的各个维度上的最大值。</li><li>如果输入数组的某个维度和输出数组的对应维度的长度相同或者其长度为 1 时，这个数组能够用来计算，否则出错。</li><li>当输入数组的某个维度的长度为 1 时，沿着此维度运算时都用此维度上的第一组值。<h2 id="Numpy的迭代"><a href="#Numpy的迭代" class="headerlink" title="Numpy的迭代"></a>Numpy的迭代</h2>numpy.nditer可以将数组转化为迭代,默认是根据数组内存布局.<pre class="line-numbers language-none"><code class="language-none">nditer(array,order &#x3D; &quot;C&quot;,op_flags &#x3D; [&#39;read_only&#39;],flags)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>其中flags可以取:<table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">c_index</td><td align="left">可以跟踪 C 顺序的索引</td></tr><tr><td align="left">f_index</td><td align="left">可以跟踪 Fortran 顺序的索引</td></tr><tr><td align="left">multi_index</td><td align="left">每次迭代可以跟踪一种索引类型</td></tr><tr><td align="left">external_loop</td><td align="left">给出的值是具有多个值的一维数组，而不是零维数组</td></tr></tbody></table></li></ul><p>如果迭代一个可广播的数组,则迭代放回的是两个值,这两个值是广播之后两个数组的值</p><h2 id="Numpy数组操作"><a href="#Numpy数组操作" class="headerlink" title="Numpy数组操作"></a>Numpy数组操作</h2><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">reshape</td><td align="left">不改变数据的条件下修改形状</td></tr><tr><td align="left">flat</td><td align="left">数组元素迭代器</td></tr><tr><td align="left">flatten</td><td align="left">返回一份数组拷贝，对拷贝所做的修改不会影响原始数组</td></tr><tr><td align="left">ravel</td><td align="left">返回展开数组</td></tr><tr><td align="left">transpose</td><td align="left">对换数组的维度,转置</td></tr><tr><td align="left">broadcase</td><td align="left">返回一个数组对另一个数组广播的结果</td></tr><tr><td align="left">split</td><td align="left">分割数组</td></tr></tbody></table><h2 id="Numpy位运算"><a href="#Numpy位运算" class="headerlink" title="Numpy位运算"></a>Numpy位运算</h2><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">bitwise_and</td><td align="left">对数组元素执行位与操作</td></tr><tr><td align="left">bitwise_or</td><td align="left">对数组元素执行位或操作</td></tr><tr><td align="left">invert</td><td align="left">按位取反</td></tr><tr><td align="left">left_shift</td><td align="left">向左移动二进制表示的位</td></tr><tr><td align="left">right_shift</td><td align="left">向右移动二进制表示的位</td></tr></tbody></table><h2 id="Numpy数学函数"><a href="#Numpy数学函数" class="headerlink" title="Numpy数学函数"></a>Numpy数学函数</h2><p>numpy内置了pi,numpy.pi就是pi</p><ul><li>三角函数<blockquote><p>sin,cos,tan只支持弧度制<br>arcsin,arccos,arctan返回弧度制,可通过degrees转化为角度值</p></blockquote><h2 id="Numpy算术函数"><a href="#Numpy算术函数" class="headerlink" title="Numpy算术函数"></a>Numpy算术函数</h2>add,subtract,multiply,divide,对数组相应数据进行计算<h2 id="Numpy统计函数"><a href="#Numpy统计函数" class="headerlink" title="Numpy统计函数"></a>Numpy统计函数</h2></li><li>amin函数 <code>amin(array,axis)</code>没有设置axis,默认当成一维数组</li><li>amax函数 <code>amax(array,axis)</code>没有设置axis,默认是一维数组</li><li>ptp函数 <code>ptp(array,axis)</code>没有设置axis,默认为一维数组</li><li>percentile函数<code>percentile(array, q, axis)</code>,p是有 <code>p%</code> 的数据项小于或等于这个值</li><li>media函数<code>media(array,axis)</code>计算中位数</li><li>mean函数<code>mean(array,axis)</code>计算算数平均数</li><li>average函数<code>mean(array,weights,returened,axis)</code> weights需要一个权重数组,returened是返回权重和</li><li>std标准差函数,var方差函数<h2 id="Numpy-排序条件筛选函数"><a href="#Numpy-排序条件筛选函数" class="headerlink" title="Numpy 排序条件筛选函数"></a>Numpy 排序条件筛选函数</h2></li><li>sort<code>sort(a, axis, kind, order)</code> kind为排序算法种,order就是排序字段</li><li>agsort返回数组从小到大的索引值</li><li>lexsort 对多个序列进行排序,排序时优先照顾靠后的序列</li><li>msort(a)    数组按第一个轴排序，返回排序后的数组副本。np.msort(a) 相等于 np.sort(a, axis=0)。</li><li>sort_complex(a)     对复数按照先实部后虚部的顺序进行排序。</li><li>partition(a, kth[, axis, kind, order])     指定一个数，对数组进行分区</li><li>argpartition(a, kth[, axis, kind, order])     可以通过关键字 kind 指定算法沿着指定轴对数组进行分区</li><li>numpy.argmax() 和 numpy.argmin()函数分别沿给定轴返回最大和最小元素的索引。</li><li>numpy.nonzero() 函数返回输入数组中非零元素的索引。</li><li>numpy.where() 函数返回输入数组中满足给定条件的元素的索引。</li><li>numpy.extract() 函数根据某个条件从数组中抽取元素，返回满足条件的元素。<h2 id="Numpy的副本和视图"><a href="#Numpy的副本和视图" class="headerlink" title="Numpy的副本和视图"></a>Numpy的副本和视图</h2>简单来说,副本和原来的数组面对的内存不一样,视图时对原来数组的引用.</li></ul><p>视图:</p><ul><li>切片</li><li>view方法</li></ul><p>副本:</p><ul><li>deepCopy</li><li>ndarray的copy方法<h2 id="Numpy矩阵库"><a href="#Numpy矩阵库" class="headerlink" title="Numpy矩阵库"></a>Numpy矩阵库</h2></li><li>matlib.empty <code>numpy.matlib.empty(shape, dtype, order)</code> 创建一个随机填充的矩阵</li><li>matlib.zeros创建一个以 0 填充的矩阵。</li><li>matlib.ones 创建一个以1填充的矩阵</li><li>matlib.eye 创建一个对角元素为1的矩阵<code>numpy.matlib.eye(n, M,k, dtype)</code>其中n为行数,M为列数,K为对角线的索引</li><li>numpy.matlib.identity() 函数返回给定大小的单位矩阵</li><li>numpy.matlib.rand() 函数创建一个给定大小的矩阵，数据是随机填充的。<h2 id="Numpy线性代数"><a href="#Numpy线性代数" class="headerlink" title="Numpy线性代数"></a>Numpy线性代数</h2><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">dot</td><td align="left">一维就是数组对应相乘,高维数组就是两个矩阵相乘。</td></tr><tr><td align="left">vdot</td><td align="left">两个向量的点积</td></tr><tr><td align="left">inner</td><td align="left">两个数组的内积</td></tr><tr><td align="left">matmul</td><td align="left">两个数组的矩阵积</td></tr><tr><td align="left">determinant</td><td align="left">数组的行列式</td></tr><tr><td align="left">solve</td><td align="left">求解线性矩阵方程</td></tr><tr><td align="left">inv</td><td align="left">计算矩阵的乘法逆矩阵</td></tr></tbody></table><h2 id="Numpy-I-O"><a href="#Numpy-I-O" class="headerlink" title="Numpy I/O"></a>Numpy I/O</h2></li><li>numpy.save 把一个数组存成npy形式 load取出<blockquote><p><code>numpy.save(file, arr, allow_pickle=True, fix_imports=True)</code></p></blockquote></li><li>numpy.savez 把多个数组存成npy形式 load取出<blockquote><p><code>numpy.savez(file, *args, **kwds)</code></p></blockquote></li><li>numpy.savetxt 把数组存储txt形式 loadtxt取出<blockquote><p><code>savetxt(FILENAME, a, fmt=&quot;%d&quot;, delimiter=&quot;,&quot;)</code></p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模,Numpy,Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>httpx的使用</title>
      <link href="/2022/01/18/httpx%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/01/18/httpx%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 爬虫学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spider/crawler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>logism自动化填充</title>
      <link href="/2022/01/17/logism%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
      <url>/2022/01/17/logism%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>P0的grf题需要32个寄存器,面对这种需要Ctrl-c/v的工作实在是浪费时间.对此,我们需要重拳出击,正好,logism的教程文件提到了怎么自动化复制,这不来尝试一下???</p><h3 id="寻找目标元件"><a href="#寻找目标元件" class="headerlink" title="寻找目标元件"></a>寻找目标元件</h3><p>用vsc打开circ文件,看到一堆标签,如何从标签里面找到需要的文件?我提出我的一些小办法:</br></p><ol><li>使用circuitname快速寻找:使用vsc自带的搜索功能,输入你要找的元件所属的circuit的名字,快速锁定大概范围.</li><li>根据元器件名字寻找:比如grf需要寄存器,那么,寻找名字为register 的器件,对于tunnel元件,可以根据朝向来判断需要<br>找到之后,把这些标签放在一起,好统一复制<br><img src="https://img-blog.csdnimg.cn/ef16719f8a9342609f5fa83238c3f246.png" alt="logism所需的元件"><br><img src="https://img-blog.csdnimg.cn/76f7ee75ad3b4bb8991c8878a85ca357.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Luj56CB5qyh5qyh5pegYnVn77yM546v5aKD5qyh5qyh5peg5Yay56qB,size_5,color_FFFFFF,t_70,g_se,x_16" alt="对应代码"><h3 id="写代码"><a href="#写代码" class="headerlink" title="写代码"></a>写代码</h3><del>python是最好的语言</del></br><br>一通操作猛如虎,打出代码,然后尝试一下 <del>(在写代码之前建议备份一下之前的circ文件,别问我怎么知道的,在1000+行的circ里面debug太痛苦了,不如直接/remake)</del></li></ol><p><img src="https://img-blog.csdnimg.cn/d1920bf2f4334199bb322184759e9014.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Luj56CB5qyh5qyh5pegYnVn77yM546v5aKD5qyh5qyh5peg5Yay56qB,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"><br><img src="https://img-blog.csdnimg.cn/7c4357f359e14dd2b690e84cc4473376.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Luj56CB5qyh5qyh5pegYnVn77yM546v5aKD5qyh5qyh5peg5Yay56qB,size_12,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"><br>好像emmmm,应该是双重循环.<br>修改一下,下面附上最终代码</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os<span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"F:\\LOGISIM_FILES\\P0_L0_GRF.circ"</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    template <span class="token operator">=</span> <span class="token triple-quoted-string string">r"""        &lt;comp lib="0" loc="(%d,%d)" name="Tunnel">      &lt;a name="width" val="8"/>      &lt;a name="label" val="r%d_out"/>    &lt;/comp>    &lt;comp lib="4" loc="(%d,%d)" name="Register"/>    &lt;comp lib="0" loc="(%d,%d)" name="Tunnel">      &lt;a name="facing" val="north"/>      &lt;a name="label" val="clk"/>    &lt;/comp>        &lt;comp lib="0" loc="(%d,%d)" name="Tunnel">      &lt;a name="facing" val="east"/>      &lt;a name="width" val="8"/>      &lt;a name="label" val="r%d_in"/>    &lt;/comp>    &lt;comp lib="0" loc="(%d,%d)" name="Tunnel">      &lt;a name="facing" val="north"/>      &lt;a name="label" val="clr"/>    &lt;/comp>        &lt;wire from="(%d,%d)" to="(%d,%d)"/>    &lt;wire from="(%d,%d)" to="(%d,%d)"/>    &lt;wire from="(%d,%d)" to="(%d,%d)"/>    &lt;wire from="(%d,%d)" to="(%d,%d)"/>    &lt;wire from="(%d,%d)" to="(%d,%d)"/>         &lt;wire from="(%d,%d)" to="(%d,%d)"/>    &lt;wire from="(%d,%d)" to="(%d,%d)"/>    &lt;wire from="(%d,%d)" to="(%d,%d)"/>"""</span>    <span class="token comment"># startx_clr+i*stepx starty_clr+j*stepy-10    startx_clr+i*stepx starty_clr+j*stepy</span>    <span class="token comment"># startx_clr+i*stepx-10, starty_clr+j*stepy-10, startx_clr+i*stepx,starty_clr+j*stepy-10</span>    <span class="token comment"># startx_clr+i*stepx-10,starty_clr+j*stepy-20,startx_clr+i*stepx-10,sstarty_clr+j*stepy-10</span>    <span class="token comment"># startx_ri+i*stepx,starty_ri+j*stepy,startx_ri+i*stepx+20,starty_ri+j*stepy</span>    <span class="token comment"># startx_ro+i*stepx,starty_ro+j*stepy,startx_ro+i*stepx,starty_ro+j*stepy</span>    <span class="token comment">#startx_clk+i*stepx+10 starty_clk+j*stepy-20   startx_clk+i*stepx+10 starty_clk+j*stepy-10</span>    <span class="token comment">#startx_clk+i*stepx starty_clk+j*stepy-10   startx_clk+i*stepx+10 starty_clk+j*stepy-10</span>    <span class="token comment">#startx_clk+i*stepx starty_clk+j*stepy-10   startx_clk+i*stepx starty_clk+j*stepy</span>    startx_ro <span class="token operator">=</span> <span class="token number">450</span>    starty_ro <span class="token operator">=</span> <span class="token number">200</span>    type_ro <span class="token operator">=</span> <span class="token number">0</span>     startx_re <span class="token operator">=</span> <span class="token number">410</span>    starty_re <span class="token operator">=</span> <span class="token number">200</span>    startx_clk <span class="token operator">=</span> <span class="token number">380</span>    starty_clk <span class="token operator">=</span> <span class="token number">240</span>    startx_ri <span class="token operator">=</span> <span class="token number">360</span>    starty_ri <span class="token operator">=</span> <span class="token number">200</span>    type_ri <span class="token operator">=</span> <span class="token number">0</span>    startx_clr <span class="token operator">=</span> <span class="token number">410</span>    starty_clr <span class="token operator">=</span> <span class="token number">240</span>    stepx <span class="token operator">=</span> <span class="token number">300</span>    stepy <span class="token operator">=</span> <span class="token number">300</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>   template <span class="token operator">%</span> <span class="token punctuation">(</span>              startx_ro<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token punctuation">,</span> starty_ro<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token punctuation">,</span> type_ro<span class="token operator">+</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token operator">*</span>i<span class="token operator">+</span>j<span class="token punctuation">)</span><span class="token punctuation">,</span>              startx_re<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token punctuation">,</span> starty_re<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token punctuation">,</span>              startx_clk<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token punctuation">,</span> starty_clk<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token punctuation">,</span>              startx_ri<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token punctuation">,</span> starty_ri<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token punctuation">,</span> type_ri<span class="token operator">+</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token operator">*</span>i<span class="token operator">+</span>j<span class="token punctuation">)</span><span class="token punctuation">,</span>              startx_clr<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token punctuation">,</span> starty_clr<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token punctuation">,</span>               startx_clr<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token punctuation">,</span> starty_clr<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span> startx_clr<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token punctuation">,</span>starty_clr<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token punctuation">,</span>              startx_clr<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span> starty_clr<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span> startx_clr<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token punctuation">,</span>starty_clr<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span>               startx_clr<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span>starty_clr<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token operator">-</span><span class="token number">20</span><span class="token punctuation">,</span>startx_clr<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span>starty_clr<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span>               startx_ri<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token punctuation">,</span>starty_ri<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token punctuation">,</span>startx_ri<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token operator">+</span><span class="token number">20</span><span class="token punctuation">,</span>starty_ri<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token punctuation">,</span>              startx_ro<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token punctuation">,</span>starty_ro<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token punctuation">,</span>startx_ro<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token operator">-</span><span class="token number">40</span><span class="token punctuation">,</span>starty_ro<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token punctuation">,</span>              startx_clk<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">,</span>starty_clk<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token operator">-</span><span class="token number">20</span><span class="token punctuation">,</span>startx_clk<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">,</span>starty_clk<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span>              startx_clk<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token punctuation">,</span>starty_clk<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span>startx_clk<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">,</span>starty_clk<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span>              startx_clk<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token punctuation">,</span>starty_clk<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span>startx_clk<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token punctuation">,</span>starty_clk<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token punctuation">)</span>  <span class="token punctuation">)</span>    f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token triple-quoted-string string">"""     &lt;/circuit>&lt;/project>"""</span><span class="token punctuation">)</span>      <span class="token comment">#logism通过这两个标签来判断circuit是否结束,所以在找到circ所需的元件之后,将这个标签删去,这样在f.write结束后自动填上/circuit,免得自己去翻   </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果:<br><img src="https://img-blog.csdnimg.cn/4f625359661141e286f54c83f247d08e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Luj56CB5qyh5qyh5pegYnVn77yM546v5aKD5qyh5qyh5peg5Yay56qB,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"></p><p>我宣布python是世界上最好的编程语言!</p>]]></content>
      
      
      <categories>
          
          <category> logism </category>
          
      </categories>
      
      
        <tags>
            
            <tag> logisim,P0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/01/16/hello-world/"/>
      <url>/2022/01/16/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>就像万事有一个开头,对于程序员来说,<code>hello world</code>就是开始的仪式.这是<code>Hexo</code>建立的时候自带的文章,本应该删去,但还是留着当一个纪念.这个post的封面是动漫<code>Hello World</code>的海报,这俩还挺配的,就一起用了.也没啥特别意义,也算是矫情吧.那么,我的博客之旅要开始了.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式学习</title>
      <link href="/2022/01/16/regular_expression/"/>
      <url>/2022/01/16/regular_expression/</url>
      
        <content type="html"><![CDATA[<h2 id="关于正则表达式的学习笔记和总结"><a href="#关于正则表达式的学习笔记和总结" class="headerlink" title="关于正则表达式的学习笔记和总结"></a>关于正则表达式的学习笔记和总结</h2><h3 id="浅谈正则表达式"><a href="#浅谈正则表达式" class="headerlink" title="浅谈正则表达式"></a>浅谈正则表达式</h3><pre class="line-numbers language-none"><code class="language-none">我有一个问题可以用正则表达式解决，好了现在我有两个问题了<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="为什么是正则表达式"><a href="#为什么是正则表达式" class="headerlink" title="为什么是正则表达式"></a>为什么是正则表达式</h5><p>在我个人的学习经历中接触过各种字符串查找函数，但为什么正则表达式这么神奇？我觉得是它的模糊性，它的模糊性决定了查找时无关元素的影响更小，更能找到需要的内容</br><br>用一段python代码举例</br></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">str</span> <span class="token operator">=</span> <span class="token string">"abcdef"</span>res <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">.</span>find<span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这个代码能帮助你找到字符串中a这个字符，但如果换个问题，在一堆电话号码中找某一个开头的电话，或者末尾是某一片段的电话号码，那么，find函数就没这么好用了。</br>这时候，正则表达式的模糊性就能很好的得到需要的结果。</p><h5 id="正则表达式的应用范围"><a href="#正则表达式的应用范围" class="headerlink" title="正则表达式的应用范围"></a>正则表达式的应用范围</h5><p>正则表达式在java和python等语言中都有相应的包调用.在爬虫的使用中,正则表达式能很好的从一堆标签中找到你需要的某一段消息(虽然有时候在结构规整,目标不复杂的情况下,bs4有更好的效果).</p><h3 id="正则表达式规则"><a href="#正则表达式规则" class="headerlink" title="正则表达式规则"></a>正则表达式规则</h3><h4 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h4><ol><li><code>.</code> :匹配除换行符之外的任意字符</li><li><code>\w</code> :匹配字母或数字或下划线或汉字</li><li><code>\W</code> :匹配不是字母或数字或下划线或汉字的字符</li><li><code>\s</code> :匹配任意空白符</li><li><code>\S</code> :匹配任意非空白符</li><li><code>\d</code> :匹配数字</li><li><code>\D</code> :匹配非数字</li><li><code>\b</code> :匹配单词的开始或结束 如<code>&quot;er\b&quot;</code> 可以匹配never 不能匹配 very</li><li><code>\A</code> :匹配字符串开头</li><li><code>\z</code>:匹配字符串结尾,如果有换行符,则同时匹配换行符.</li><li><code>\Z</code>:匹配字符串结尾,不匹配换行符.</li><li><code>^</code> :匹配输入字符串的开始</li><li><code>$</code> :匹配输入字符串的结束<h4 id="重复限定符"><a href="#重复限定符" class="headerlink" title="重复限定符"></a>重复限定符</h4></li><li><code>*</code> 重复零次或者多次</li><li><code>+</code> 重复一次或多次</li><li><code>?</code>重复零次或一次</li><li><code>&#123;n&#125;</code> 重复n次</li><li><code>&#123;n,&#125;</code> 重复n次或者多次</li><li><code>&#123;n,m&#125;</code> 重复n次或者m次<h4 id="分组符"><a href="#分组符" class="headerlink" title="分组符"></a>分组符</h4></li><li><code>(ab)</code> 表明以字符串<code>&quot;ab&quot;</code>为一组的元素,例如: <code>&quot;^(ab)+&quot;</code>匹配以零个或者多个<code>&quot;ab&quot;</code>开头的字符串</li><li><code>[abc]</code>或者<code>[a-c]</code> 表明匹配abc中任意一个的字符  <h4 id="转义符"><a href="#转义符" class="headerlink" title="转义符"></a>转义符</h4></li><li><code>\</code> 表明将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。如:<code>&quot;(\n)&quot;</code>表示匹配\n <code>&quot;(\(ab\))+&quot;</code>表示匹配一个或者多个<code>&quot;(ab)&quot;</code>的字符<h4 id="条件符"><a href="#条件符" class="headerlink" title="条件符"></a>条件符</h4></li><li><code>|</code> 条件或,满足前者或者后者的字符,例如<code>&quot;(12)(3|4)&quot;</code>匹配<code>&quot;123&quot;</code>或者<code>&quot;124&quot;</code>的字符<h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4></li><li>正向先行断言<code>表达式1(?=pattern)</code>匹配pattern前面的表达式,不包含本身,例如下面的代码</br><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> reline <span class="token operator">=</span> <span class="token string">"&lt;div class = \"left_box\" height = 100px>"</span>pattern <span class="token operator">=</span> <span class="token string">".*(?=height)"</span>m <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>pattern<span class="token punctuation">,</span>line<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token operator">&lt;</span>div <span class="token keyword">class</span> <span class="token operator">=</span> <span class="token string">"left_box"</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>负向先行断言<code>表达式1(?!pattern)</code>匹配后面不含pattern的表达式,不包含本身,例如下面的代码</br><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> reline <span class="token operator">=</span> <span class="token string">"regular regex rlief"</span>pattern <span class="token operator">=</span> <span class="token string">r"r(\w&#123;1&#125;)(?!g)"</span>m <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>pattern<span class="token punctuation">,</span>line<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> rl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>正向后行断言<code>(?&lt;=pattern)表达式1</code>,同正向先行断言,只是匹配的是pattern后面的表达式</li><li>负向向后行断言<code>(?&lt;!pattern)表达式1</code>,同负向向先行断言,只是匹配的是pattern后面的表达式</li></ol><h4 id="懒惰-非贪婪"><a href="#懒惰-非贪婪" class="headerlink" title="懒惰(非贪婪)"></a>懒惰(非贪婪)</h4><h6 id="什么是正则表达式的贪婪"><a href="#什么是正则表达式的贪婪" class="headerlink" title="什么是正则表达式的贪婪?"></a>什么是正则表达式的贪婪?</h6><p>贪婪是指在匹配时尽可能多的匹配,如<code>\w&#123;2,9&#125;</code>则会尽量匹配9个,如果不够就匹配八个.</p><h6 id="如何做到懒惰"><a href="#如何做到懒惰" class="headerlink" title="如何做到懒惰"></a>如何做到懒惰</h6><ol><li><code>*?</code>重复0次或者无数次,从0开始匹配</li><li><code>+?</code>重复一到正无穷次,从1开始</li><li><code>??</code>重复0到1次,从0开始</li><li><code>&#123;n,m&#125;?</code> 重复n到m次,从n开始<h4 id="编号分组"><a href="#编号分组" class="headerlink" title="编号分组"></a>编号分组</h4></li><li>数字编号分组<code>&#123;表达式&#125;</code>,例如:<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> reline <span class="token operator">=</span> <span class="token string">"020-85653333"</span>pattern <span class="token operator">=</span> <span class="token string">r"(0\d&#123;2,3&#125;)-(\d&#123;8&#125;)"</span>m <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>pattern<span class="token punctuation">,</span>line<span class="token punctuation">)</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span><span class="token number">020</span><span class="token operator">-</span><span class="token number">85653333</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span><span class="token number">020</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span><span class="token number">85653333</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>命名编号捕获组<code>(?&lt;name&gt;表达式)</code>,非捕获组<code>()?:表达式</code>,不捕获(在不同语言中实现方式不同,如在python中需要添加P在?与<name>之间)<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> reline <span class="token operator">=</span> <span class="token string">"020-85653333"</span>pattern <span class="token operator">=</span> <span class="token string">r"(?P&lt;区号>0\d&#123;2,3&#125;)-(?P&lt;号码>\d&#123;8&#125;)"</span>m <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>pattern<span class="token punctuation">,</span>line<span class="token punctuation">)</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span><span class="token number">020</span><span class="token operator">-</span><span class="token number">85653333</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token string">"号码"</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span><span class="token number">020</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token string">"区号"</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span><span class="token number">85653333</span><span class="token keyword">import</span> reline <span class="token operator">=</span> <span class="token string">"020-85653333"</span>pattern <span class="token operator">=</span> <span class="token string">r"(?P&lt;区号>0\d&#123;2,3&#125;)-(?:\d&#123;8&#125;)"</span>m <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>pattern<span class="token punctuation">,</span>line<span class="token punctuation">)</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span><span class="token number">020</span><span class="token operator">-</span><span class="token number">85653333</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token string">"号码"</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span>Errorm<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token string">"区号"</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span><span class="token number">85653333</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python中re库介绍"><a href="#python中re库介绍" class="headerlink" title="python中re库介绍"></a>python中re库介绍</h3><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4></li></ol><ul><li>re.I 大小写不敏感</li><li>re.L 实现本地化识别(local-aware)匹配</li><li>re.M 多行匹配</li><li>re.S 匹配包括换行符在内的任何字符</li><li>re.U 使用Unicode字符集解析字符</li><li>re.X 该标志给予灵活格式.</li></ul><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li>search:从开头开始匹配,如果开头不匹配则失败</li><li>findall:获取匹配的所有字符串</li><li>sub:把匹配字符出从其中删去</li><li>compile:将正则表达式编译成正则表达式对象,方便之后复用</li><li>match:找到第一个匹配的字符串</li></ul><h3 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h3><p>正则表达式在线匹配网站:<code>https://c.runoob.com/front-end/854/</code></p>]]></content>
      
      
      <categories>
          
          <category> 正则表达式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>响应状态码</title>
      <link href="/2022/01/16/response_status_code/"/>
      <url>/2022/01/16/response_status_code/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th align="center">状态码</th><th align="center">状态码英文名称</th><th align="center">中文描述</th></tr></thead><tbody><tr><td align="center">100</td><td align="center">Continue</td><td align="center">继续。客户端应继续其请求</td></tr><tr><td align="center">101</td><td align="center">Switching Protocols</td><td align="center">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">200</td><td align="center">OK</td><td align="center">请求成功。一般用于GET与POST请求</td></tr><tr><td align="center">201</td><td align="center">Created</td><td align="center">已创建。成功请求并创建了新的资源</td></tr><tr><td align="center">202</td><td align="center">Accepted</td><td align="center">已接受。已经接受请求，但未处理完成</td></tr><tr><td align="center">203</td><td align="center">Non-Authoritative Information</td><td align="center">非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td align="center">204</td><td align="center">No Content</td><td align="center">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td align="center">205</td><td align="center">Reset Content</td><td align="center">重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td align="center">206</td><td align="center">Partial Content</td><td align="center">部分内容。服务器成功处理了部分GET请求</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">300</td><td align="center">Multiple Choices</td><td align="center">多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td></tr><tr><td align="center">301</td><td align="center">Moved Permanently</td><td align="center">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td align="center">302</td><td align="center">Found</td><td align="center">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td align="center">303</td><td align="center">See Other</td><td align="center">查看其它地址。与301类似。使用GET和POST请求查看</td></tr><tr><td align="center">304</td><td align="center">Not Modified</td><td align="center">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td align="center">305</td><td align="center">Use Proxy</td><td align="center">使用代理。所请求的资源必须通过代理访问</td></tr><tr><td align="center">306</td><td align="center">Unused</td><td align="center">已经被废弃的HTTP状态码</td></tr><tr><td align="center">307</td><td align="center">Temporary Redirect</td><td align="center">临时重定向。与302类似。使用GET请求重定向</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">400</td><td align="center">Bad Request</td><td align="center">客户端请求的语法错误，服务器无法理解</td></tr><tr><td align="center">401</td><td align="center">Unauthorized</td><td align="center">请求要求用户的身份认证</td></tr><tr><td align="center">402</td><td align="center">Payment Required</td><td align="center">保留，将来使用</td></tr><tr><td align="center">403</td><td align="center">Forbidden</td><td align="center">服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td align="center">404</td><td align="center">Not Found</td><td align="center">服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td></tr><tr><td align="center">405</td><td align="center">Method Not Allowed</td><td align="center">客户端请求中的方法被禁止</td></tr><tr><td align="center">406</td><td align="center">Not Acceptable</td><td align="center">服务器无法根据客户端请求的内容特性完成请求</td></tr><tr><td align="center">407</td><td align="center">Proxy Authentication Required</td><td align="center">请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td></tr><tr><td align="center">408</td><td align="center">Request Time-out</td><td align="center">服务器等待客户端发送的请求时间过长，超时</td></tr><tr><td align="center">409</td><td align="center">Conflict</td><td align="center">服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突</td></tr><tr><td align="center">410</td><td align="center">Gone</td><td align="center">客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td></tr><tr><td align="center">411</td><td align="center">Length Required</td><td align="center">服务器无法处理客户端发送的不带Content-Length的请求信息</td></tr><tr><td align="center">412</td><td align="center">Precondition Failed</td><td align="center">客户端请求信息的先决条件错误</td></tr><tr><td align="center">413</td><td align="center">Request Entity Too Large</td><td align="center">由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td></tr><tr><td align="center">414</td><td align="center">Request-URI Too Large</td><td align="center">请求的URI过长（URI通常为网址），服务器无法处理</td></tr><tr><td align="center">415</td><td align="center">Unsupported Media Type</td><td align="center">服务器无法处理请求附带的媒体格式</td></tr><tr><td align="center">416</td><td align="center">Requested range not satisfiable</td><td align="center">客户端请求的范围无效</td></tr><tr><td align="center">417</td><td align="center">Expectation Failed</td><td align="center">服务器无法满足Expect的请求头信息</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">500</td><td align="center">Internal Server Error</td><td align="center">服务器内部错误，无法完成请求</td></tr><tr><td align="center">501</td><td align="center">Not Implemented</td><td align="center">服务器不支持请求的功能，无法完成请求</td></tr><tr><td align="center">502</td><td align="center">Bad Gateway</td><td align="center">作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td></tr><tr><td align="center">503</td><td align="center">Service Unavailable</td><td align="center">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td align="center">504</td><td align="center">Gateway Time-out</td><td align="center">充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td align="center">505</td><td align="center">HTTP Version not supported</td><td align="center">服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 爬虫学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http基础</title>
      <link href="/2022/01/16/the_principle_of_HTTP/"/>
      <url>/2022/01/16/the_principle_of_HTTP/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP基本原理"><a href="#HTTP基本原理" class="headerlink" title="HTTP基本原理"></a>HTTP基本原理</h1><h2 id="1-URI-和-URL"><a href="#1-URI-和-URL" class="headerlink" title="1. URI  和  URL "></a>1.<strong> URI </strong> 和 <strong> URL </strong></h2><p>URI = URL(统一资源定位符,需要有路径) + URN(统一资源名称,只需要独一无二,例如ID card)</br><br>URL 统一格式:</br><br><code>scheme://[username:password@]hostname[:port][/path][;parameters][?query][#fragment] </code></p><h3 id="解释"><a href="#解释" class="headerlink" title="解释:"></a>解释:</h3><blockquote><p>scheme: 协议 也称protocol </br><br><strong>[username:password@]</strong>:用户名和密码<br><strong>hostname</strong>:主机地址</br><br><strong>port</strong>:端口</br><br><strong>path</strong>:路径,网络资源在服务器中的指定地址,类比操作系统中目录</br><br><strong>parameters</strong>:参数,访问资源的附加信息</br><br><strong>query</strong>:查询,查询某类资源,比如地址</br><code>https://www.baidu.com/baidu?tn=monline_3_dg&amp;ie=utf-8&amp;wd=%E4%BD%A0%E5%A5%BD%E6%9D%8E%E7%84%95%E8%8B%B1</code></br>问号后面限制了搜索引擎关键词<br>fragment:片段,对资源描述的部分补充.应用之一作为现代前端框架做路由管理,其二是HTML锚点(href = “#top”)</p></blockquote><h2 id="2-HTTP-和-HTTPS"><a href="#2-HTTP-和-HTTPS" class="headerlink" title="2. HTTP  和  HTTPS "></a>2.<strong> HTTP </strong> 和 <strong> HTTPS </strong></h2><p>HTTP只是单纯把超文本数据从网络传输到本地浏览器,HTTPS增加了SSL层,传输内容经过SSL加密.</br><br>这两个协议都是应用层协议,只负责信息传输的规范,其传输层还是TCP/IP(三次握手,四次挥手)协议,负责服务器和本地主机建立联系.</br></p><h2 id="3-HTTP-HTTPS请求过程"><a href="#3-HTTP-HTTPS请求过程" class="headerlink" title="3.HTTP/HTTPS请求过程:"></a>3.HTTP/HTTPS请求过程:</h2><p>客户端发送Request(请求),服务器收到请求进行解析,然后服务器返回Response(响应).浏览器得到响应之后进行响应解析渲染呈现.</p><h2 id="4-请求"><a href="#4-请求" class="headerlink" title="4.请求"></a>4.请求</h2><p>请求  ＝ 请求方法 + 请求网址 + 请求头 + 请求体</p><h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><p>常用<code>get</code>和<code>post</code></p><h4 id="GET方法"><a href="#GET方法" class="headerlink" title="GET方法:"></a>GET方法:</h4><blockquote><p>当输入网址按下回车的时候就已经输入了GET方法到服务器,请求参数(query)会和URL一起发给服务器.一个Get请求一次最多发送1024Byte大小数据</p></blockquote><h4 id="POST方法"><a href="#POST方法" class="headerlink" title="POST方法:"></a>POST方法:</h4><blockquote><p>当输入账号密码等需要提交表单的时候就是发送了<code>post</code>方法,参数不会包含在URL中,而是包含在请求体里面发给服务器.发送的数据没有大小要求.</p></blockquote><p>不常用方法有<code>HEAD</code>,<code>PUT</code>,<code>DELETE</code>,<code>CONNECT</code>,<code>OPTIONS</code>,<code>TRACE</code>.</p><ul><li>HEAD:类似于GET请求,但是Response中没有具体内容,用于获取响应头.</li><li>PUT: 用客户端发送给服务器的数据取代指定文档中的内容(修改操作,共享文档 <del>或许是</del> )</li><li>DELET: 请求服务器删除指定页面(类似于不使用<code>blank</code>)</li><li>CONNECT: 通过服务器代替客户端访问其他网页(<code>VPN</code>)</li><li>OPTIONS: 允许客户端查看服务器性能</li><li>TRACE: 回显服务器收到的请求,主要用于测试和诊断<h3 id="请求网址"><a href="#请求网址" class="headerlink" title="请求网址"></a>请求网址</h3>URL,不再赘述.<h3 id="请求头-headers"><a href="#请求头-headers" class="headerlink" title="请求头(headers)"></a>请求头(headers)</h3>服务器要使用的附加信息,常用来判断是否请求合法.<h4 id="常用请求头信息"><a href="#常用请求头信息" class="headerlink" title="常用请求头信息"></a>常用请求头信息</h4></li><li><strong>Accept</strong>: 请求报头域,用于指定客户端可接受哪些类型的信息 <del>(神画了一条线,说你只能在此地,不能逾越)</del> </li><li><strong>Accept-Language</strong>: 用于指定客户端的语言类型</li><li><strong>Accept-Encoding</strong>:用于指定客户端可接受的编码(常用UTF-8,也有GBK)</li><li><strong>Host</strong>:用于指定请求资源的主机IP和端口号</li><li><strong>Cookie/Cookies</strong>: 网站用于辨别用户,进行会话跟踪而存储在 <strong>用户本地</strong> 的数据.功能是 <strong>维持当前访问会话</strong>.</br><br>例如:</br>登录网站之后,客户端本地会保存服务器发来的Cookies,这样之后在网站内跳转,凭借Cookies就能保持登录状态,如果Cookies被删掉就要重新获得Cookies.(为了保证个人信息安全,请及时删除Cookies,以免病毒获得了你的Cookies,登入网站)</li><li><strong>Referer</strong>:用于标识请求是从那个页面发过来,判断访问是否合法(你不能在不进入浏览器的情况直接进入某宝的付款页面,但是正常登录就行,因为Referer不合法),以及来源统计(网站统计访问人数和来源).</li><li><strong>User-Agent/UA</strong>:帮助服务器识别客户端使用的操作系统以及版本、浏览器和版本信息.爬虫加上此头用于模仿浏览器的正常访问,如果不加,该UA就是Python.</li><li><strong>Content-Type</strong>: 也叫互联网媒体类型或者MIME类型,在HTTP中用来表示具体请求中的媒体类型信息,例如<code>text/html</code>表示<code>HTML</code>格式,<code>image/gif</code>表示<code>GIF</code>图片,<code>application/json</code>代表<code>json</code>类型<h3 id="请求体-body"><a href="#请求体-body" class="headerlink" title="请求体(body)"></a>请求体(body)</h3><a id="Content_Type_Table"></li></ul><p>在GET中为空,POSI为提交的表单信息</br></p><table><thead><tr><th align="center">Content-Type</th><th align="center">Post提交数据方式</th></tr></thead><tbody><tr><td align="center">application/x-www-form-urlencoded</td><td align="center">表单数据</td></tr><tr><td align="center">multipart/form-data</td><td align="center">表单文件上传</td></tr><tr><td align="center">application/json</td><td align="center">序列化json数据(<a href="https://baike.baidu.com/item/JSON/2462549?fr=aladdin">一种数据交换格式,本质是js对象的字符串表示方法</a>)</td></tr><tr><td align="center">text/xml</td><td align="center">xml数据(<a href="https://www.w3school.com.cn/xml/xml_intro.asp">一种可拓展标签语言,用来传递数据</a>)</td></tr></tbody></table><h2 id="5-响应"><a href="#5-响应" class="headerlink" title="5.响应"></a>5.响应</h2><h3 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h3><ul><li>状态码分类:</br></li></ul><table><thead><tr><th align="center">分类</th><th align="center">分类描述</th></tr></thead><tbody><tr><td align="center">1xx</td><td align="center">信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td align="center">2xx</td><td align="center">成功，操作被成功接收并处理</td></tr><tr><td align="center">3xx</td><td align="center">重定向，需要进一步的操作以完成请求</td></tr><tr><td align="center">4xx</td><td align="center">客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td align="center">5xx</td><td align="center">服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><ul><li>详解:</br></li><li>状态码    </li></ul><p><a href="response_status_code.md">详见响应状态码</a></p><h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h3><p>响应头包含服务器对请求的应答</p><ul><li><strong>Date</strong>:日期</li><li><strong>Last_Modified</strong>:指定资源的最后修改时间</li><li><strong>Content_Encoding</strong>:指定响应内容的编码</li><li><strong>Server</strong>:服务器信息</li><li><strong>Content_Type</strong>:文档类型,见<a href="#Content_Type_Table">请求头Content_Type对应数据类型</a></li><li><strong>Set_Cookie</strong>:服务器传给客户端的Cookies,需要在下次访问网站时携带此Cookie</li><li><strong>Expires</strong>:用于指定响应的过期时间,在此时间内浏览器可把内容写入缓存,下次直接从缓存中获得.</li></ul><h3 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h3><p>客户端对于请求返回的响应数据皆在此部分.是爬虫的爬取目标.</p><h2 id="6-HTTP2-0"><a href="#6-HTTP2-0" class="headerlink" title="6.HTTP2.0"></a>6.HTTP2.0</h2><h3 id="二进制分帧层"><a href="#二进制分帧层" class="headerlink" title="二进制分帧层"></a>二进制分帧层</h3><ul><li>帧是HTTP2.0中的概念.代表数据通信最小单位.比如请求头帧,请求体帧.</li><li>数据流:一个虚拟的双向通道,有唯一整数ID标识.</li><li>信息:与逻辑请求或响应信息对应的完整的一系列帧.</li></ul><p>HTTP2.0 将HTTP协议通信分解为二进制编码帧的交换,帧对应特定数据流中的信息,在一个TCP中复用,从而提高效率.</p><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>HTTP2.0通过讲HTTP消息分解为互不依赖的帧,交错发送,从而达到多路并行的效果(类似Pipeline),客户端再把这些帧拼接起来.</p><h3 id="流控制"><a href="#流控制" class="headerlink" title="流控制"></a>流控制</h3><p>流控制是为了防止服务器向客户端发送过量数据,客户端来不及处理.因为HTTP2.0只在一个TCP内复用,无法使用TCP自带流控制API.</br><br>为了解决这一问题,HTTP2.0提供了简单构建块.</p><ul><li>流控制具有方向性.每个接受方都能按自身需求为每个数据流甚至整个连接设置窗口大小.</li><li>流控制窗口大小是动态控制的.每个接受方都可以公布其窗口,当发送方发送DATA时窗口变小,接收方发出WINDOW_UPDATA时窗口变大.</li><li>流控制无法停止.<h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3>服务器可以对一个客户端请求发送多个数据.这个常用于发送了HTML文件之后再把CSS和JS发送过去.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 爬虫学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spider/crawler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Requests的使用</title>
      <link href="/2022/01/16/the_use_of_requests/"/>
      <url>/2022/01/16/the_use_of_requests/</url>
      
        <content type="html"><![CDATA[<h1 id="Requests的应用"><a href="#Requests的应用" class="headerlink" title="Requests的应用"></a>Requests的应用</h1><h2 id="Get请求"><a href="#Get请求" class="headerlink" title="Get请求"></a>Get请求</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requests<span class="token comment">### 添加params</span>data <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token string">'name'</span><span class="token punctuation">:</span><span class="token string">'admin'</span><span class="token punctuation">,</span>    <span class="token string">'password'</span><span class="token punctuation">:</span><span class="token string">'passward'</span><span class="token punctuation">&#125;</span><span class="token comment">### 添加headers</span>headers <span class="token operator">=</span><span class="token punctuation">&#123;</span>    <span class="token string">"Host"</span><span class="token punctuation">:</span> <span class="token string">"pss.bdstatic.com"</span><span class="token punctuation">,</span>    <span class="token string">"User-Agent"</span><span class="token punctuation">:</span> <span class="token string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:96.0) Gecko/20100101 Firefox/96.0'</span>    <span class="token string">'Accept'</span><span class="token punctuation">:</span> <span class="token string">"*/*"</span>    <span class="token string">'Accept-Language'</span><span class="token punctuation">:</span> <span class="token string">'zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2'</span>    <span class="token string">'Accept-Encoding'</span><span class="token punctuation">:</span> <span class="token string">'gzip, deflate, br'</span>    <span class="token string">'Referer'</span><span class="token punctuation">:</span> <span class="token string">'https://www.baidu.com/baidu?tn=monline_3_dg&amp;ie=utf-8&amp;wd=%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%99%BB%E5%BD%95%E5%85%A8%E6%98%AFget'</span>    <span class="token string">'Connection'</span><span class="token punctuation">:</span> <span class="token string">'keep-alive'</span>    <span class="token string">'Sec-Fetch-Dest'</span><span class="token punctuation">:</span> <span class="token string">'script'</span>    <span class="token string">'Sec-Fetch-Mode'</span><span class="token punctuation">:</span> <span class="token string">'no-cors'</span>    <span class="token string">'Sec-Fetch-Site'</span><span class="token punctuation">:</span> <span class="token string">'cross-site'</span>    <span class="token string">'Pragma'</span><span class="token punctuation">:</span> <span class="token string">'no-cache'</span>    <span class="token string">'Cache-Control'</span><span class="token punctuation">:</span> <span class="token string">'no-cache'</span>    <span class="token string">'TE'</span><span class="token punctuation">:</span> <span class="token string">'trailers'</span><span class="token punctuation">&#125;</span>response <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span>params <span class="token operator">=</span> data<span class="token punctuation">,</span>headers <span class="token operator">=</span> headers<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token comment">### 如果返回是请求头,则能以str格式或者json格式输出</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>json<span class="token punctuation">)</span><span class="token comment">### 如果返回是网页,则能使用正则表达式匹配抓取</span><span class="token keyword">import</span> re pattern <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token builtin">compile</span><span class="token punctuation">(</span><span class="token string">"&lt;h1.*?> .*?&lt;/h1>"</span><span class="token punctuation">,</span>re<span class="token punctuation">.</span>S<span class="token punctuation">)</span>title <span class="token operator">=</span> re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>pattern<span class="token punctuation">,</span>response<span class="token punctuation">.</span>txt<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>title<span class="token punctuation">)</span><span class="token comment">### 如果是视频,图片,音频,则是二进制文件,使用context</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>context<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Post请求"><a href="#Post请求" class="headerlink" title="Post请求"></a>Post请求</h2><h3 id="基本用法实例"><a href="#基本用法实例" class="headerlink" title="基本用法实例"></a>基本用法实例</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requestsurl <span class="token operator">=</span> <span class="token string">''</span><span class="token comment">## </span>data <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token string">'name'</span><span class="token punctuation">:</span><span class="token string">'admin'</span><span class="token punctuation">,</span>    <span class="token string">'password'</span><span class="token punctuation">:</span><span class="token string">'passward'</span><span class="token punctuation">&#125;</span><span class="token comment">## 设置headers</span>headers <span class="token operator">=</span><span class="token punctuation">&#123;</span>    <span class="token string">"Host"</span><span class="token punctuation">:</span> <span class="token string">"pss.bdstatic.com"</span><span class="token punctuation">,</span>    <span class="token string">"User-Agent"</span><span class="token punctuation">:</span> <span class="token string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:96.0) Gecko/20100101 Firefox/96.0'</span>    <span class="token string">'Accept'</span><span class="token punctuation">:</span> <span class="token string">"*/*"</span>    <span class="token string">'Accept-Language'</span><span class="token punctuation">:</span> <span class="token string">'zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2'</span>    <span class="token string">'Accept-Encoding'</span><span class="token punctuation">:</span> <span class="token string">'gzip, deflate, br'</span>    <span class="token string">'Referer'</span><span class="token punctuation">:</span> <span class="token string">'https://www.baidu.com/baidu?tn=monline_3_dg&amp;ie=utf-8&amp;wd=%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%99%BB%E5%BD%95%E5%85%A8%E6%98%AFget'</span>    <span class="token string">'Connection'</span><span class="token punctuation">:</span> <span class="token string">'keep-alive'</span>    <span class="token string">'Sec-Fetch-Dest'</span><span class="token punctuation">:</span> <span class="token string">'script'</span>    <span class="token string">'Sec-Fetch-Mode'</span><span class="token punctuation">:</span> <span class="token string">'no-cors'</span>    <span class="token string">'Sec-Fetch-Site'</span><span class="token punctuation">:</span> <span class="token string">'cross-site'</span>    <span class="token string">'Pragma'</span><span class="token punctuation">:</span> <span class="token string">'no-cache'</span>    <span class="token string">'Cache-Control'</span><span class="token punctuation">:</span> <span class="token string">'no-cache'</span>    <span class="token string">'TE'</span><span class="token punctuation">:</span> <span class="token string">'trailers'</span><span class="token punctuation">&#125;</span><span class="token comment">##</span>response <span class="token operator">=</span> requests<span class="token punctuation">.</span>post<span class="token punctuation">(</span>url<span class="token punctuation">,</span>data <span class="token operator">=</span> data<span class="token punctuation">,</span> headers <span class="token operator">=</span> headers<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>status_code<span class="token punctuation">)</span><span class="token comment">##状态码</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>headers<span class="token punctuation">)</span><span class="token comment">##响应头</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>cookies<span class="token punctuation">)</span><span class="token comment">##cookie</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>url<span class="token punctuation">)</span><span class="token comment">##url</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>history<span class="token punctuation">)</span><span class="token comment">##请求你是</span><span class="token comment">## requests内置了状态码,比如 requests.codes,ok 就是 statsus_code 200</span>exit<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token keyword">not</span> response<span class="token punctuation">.</span>status_code <span class="token operator">==</span> requests<span class="token punctuation">.</span>codes<span class="token punctuation">.</span>ok <span class="token keyword">else</span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Successful"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requestsfiles <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">'file'</span><span class="token punctuation">:</span><span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"filepath"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>response <span class="token operator">=</span> requests<span class="token punctuation">.</span>post<span class="token punctuation">(</span>url<span class="token punctuation">,</span>files <span class="token operator">=</span> files<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Cookie设置"><a href="#Cookie设置" class="headerlink" title="Cookie设置"></a>Cookie设置</h4><pre class="line-numbers language-none"><code class="language-none">import requestsclass Spider:    def __init__(self,CookieJar):        self.cookies &#x3D; Requests.cookies.RequestsCookieJar() ## 创建一个Cookiejar类    def Update(cookies):        self.cookies.updata(cookies)    def Crawler_get(url)        self.response &#x3D; requests.get(url,cookies &#x3D; self.cookies)##r &#x3D; requests.get(url)print(r.cookies) ## cookies 属于RequestsCookieJar类型for key,values in r.cookies.items(): ##用items方法返回一个由Cookie组成的元组    print(key + &quot;:&quot; + values)## 使用Cookie去访问网站MySpider &#x3D; Spider()          ## 创捷Spider对象MySpider.Update(r.cookies)   ## 更新cookiesMySpider.Crawler_get(url)    ## 获取开始爬<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Session维持"><a href="#Session维持" class="headerlink" title="Session维持"></a>Session维持</h4><p><code>Session</code>维持能保证两次请求的时候都是同一个账户,并且不需要手动保持<code>Cookie</code>,显得更为方便.其主要模拟同一个浏览器访问同一个站点的不同页面.</p><p>下面举例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requestsrequests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'https://www.httpbin.org/cookies/set/number/123456789'</span><span class="token punctuation">)</span> <span class="token comment">##这个网址能设置cookies</span>response <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'http://www.httpbin.org/cookies'</span><span class="token punctuation">)</span> <span class="token comment">##访问这个网址能获取自己的请求头,这里是返回自己的cookies</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>text<span class="token punctuation">)</span> <span class="token comment">##这里面不会有之前这是的cookies</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requestss <span class="token operator">=</span> requests<span class="token punctuation">.</span>Session<span class="token punctuation">(</span><span class="token punctuation">)</span>s<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'https://www.httpbin.org/cookies/set/number/123456789'</span><span class="token punctuation">)</span>response <span class="token operator">=</span> s<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'http://www.httpbin.org/cookies'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>text<span class="token punctuation">)</span> <span class="token comment">###这里返回了cookies</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="SSL证书验证"><a href="#SSL证书验证" class="headerlink" title="SSL证书验证"></a>SSL证书验证</h4><p>有些网站可能没有设置好HTTPS证书,或者其证书没有被CA认证,那么访问的时候就会出现SSL证书错误异常,那么就需要让爬虫自动处理.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requestsresponse <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>verify <span class="token operator">=</span> <span class="token boolean">False</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>status_code<span class="token punctuation">)</span><span class="token comment">##这里能输出200,但是会有一个warning,让我们指定证书,我们可以设置忽略</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如下</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requests<span class="token keyword">from</span> requests<span class="token punctuation">.</span>packages<span class="token punctuation">.</span>md <span class="token keyword">import</span> urllib3urllib3<span class="token punctuation">.</span>disable_warnings<span class="token punctuation">(</span><span class="token punctuation">)</span>response <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>verify <span class="token operator">=</span> <span class="token boolean">False</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>status_code<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者我们可以把警告捕获到日志,从而忽略</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> logging<span class="token keyword">import</span> requestslogging<span class="token punctuation">.</span>CaptureWarnings<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>response <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>verify <span class="token operator">=</span> <span class="token boolean">False</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>status_code<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然也可以设置本地证书用作客户端证书,可以是单个文件,也可以是包含两个文件路径的元组</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requestsresponse <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>cert <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'/path/server.crt'</span><span class="token punctuation">,</span><span class="token string">'/path/server.key'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>status_code<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="超时设置"><a href="#超时设置" class="headerlink" title="超时设置"></a>超时设置</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requestsresponse <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>timeout <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h4><p><code>urllib</code>中有<code>HTTPBasicAuthHandler</code>来处理身份验证问题,那么同样的<code>requests</code>中也有相应的库来处理.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requests<span class="token keyword">from</span> requests<span class="token punctuation">.</span>auth <span class="token keyword">import</span> HTTPBasicAuthr <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>auth <span class="token operator">=</span> HTTPBasicAuth<span class="token punctuation">(</span><span class="token string">"admin"</span><span class="token punctuation">,</span><span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">##或者</span>r <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>auth <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"admin"</span><span class="token punctuation">,</span><span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>status_code<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外,<code>requests</code>还提供了其他认证方式,比如<code>oa</code>验证,提供了<code>OAuth</code>,需要安装<code>oauth</code>包.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requests<span class="token punctuation">.</span>oauthlib <span class="token keyword">import</span> OAuth1<span class="token keyword">import</span> requestauth <span class="token operator">=</span> OAuth1<span class="token punctuation">(</span><span class="token string">'Your_App_Key'</span><span class="token punctuation">,</span><span class="token string">'You_App_Secret'</span><span class="token punctuation">,</span><span class="token string">'User_Oauth_Token'</span><span class="token punctuation">,</span><span class="token string">'User_Oauth_Token_Secret'</span><span class="token punctuation">)</span>response <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">.</span>auth <span class="token operator">=</span> auth<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a>代理设置</h4><p><code>urllib</code>中有<code>ProxyHandler</code>来处理身份验证问题,那么同样的<code>requests</code>中也有相应的库来处理.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requestsproxies <span class="token operator">=</span> <span class="token punctuation">&#123;</span>        <span class="token string">'http'</span><span class="token punctuation">:</span><span class="token string">'http://'</span>        <span class="token string">'https'</span><span class="token punctuation">:</span><span class="token string">'https://'</span><span class="token punctuation">&#125;</span>requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>proxies <span class="token operator">=</span> proxies<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果需要身份验证,那么,可以使用类似<code>http://user:password@host:port</code>的形式设置代理.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requestsproxies <span class="token operator">=</span> <span class="token punctuation">&#123;</span>        <span class="token string">'http'</span><span class="token punctuation">:</span><span class="token string">'http://user:password@'</span>        <span class="token string">'https'</span><span class="token punctuation">:</span><span class="token string">'https://user:password@'</span><span class="token punctuation">&#125;</span>requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>proxies <span class="token operator">=</span> proxies<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Requests库的实现浅尝"><a href="#Requests库的实现浅尝" class="headerlink" title="Requests库的实现浅尝"></a>Requests库的实现浅尝</h3><p>实际上,在使用requests库的时候,他是在内部构造了一个Request对象,并给这个对象各种参数,再把这个Request对象发送出去,请求成功之后再返回Response对象.</p><p>这个Request对象是Prepare Request类型</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> requests <span class="token keyword">import</span> Request<span class="token punctuation">,</span>Sessionurl <span class="token operator">=</span> <span class="token string">''</span>data <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">''</span><span class="token punctuation">:</span><span class="token string">''</span><span class="token punctuation">&#125;</span>headers <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">''</span><span class="token punctuation">:</span><span class="token string">''</span><span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">:</span><span class="token string">''</span><span class="token punctuation">&#125;</span>s <span class="token operator">=</span> Session<span class="token punctuation">(</span><span class="token punctuation">)</span>req <span class="token operator">=</span> Request<span class="token punctuation">(</span><span class="token string">'POST'</span><span class="token punctuation">,</span>url<span class="token punctuation">,</span>data<span class="token operator">=</span> data<span class="token punctuation">,</span>headers <span class="token operator">=</span> headers<span class="token punctuation">)</span> <span class="token comment">##创建了一个request对象</span>prepped <span class="token operator">=</span> s<span class="token punctuation">.</span>prepare_request<span class="token punctuation">(</span>req<span class="token punctuation">)</span> <span class="token comment">##把request对象转换为一个prepare_request对象</span>r <span class="token operator">=</span> s<span class="token punctuation">.</span>send<span class="token punctuation">(</span>prepped<span class="token punctuation">)</span><span class="token comment">##把prepare_request对象发送出去,获得其response对象</span><span class="token keyword">print</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 爬虫学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spider/crawler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫基础</title>
      <link href="/2022/01/16/the_principle_of_crawler/"/>
      <url>/2022/01/16/the_principle_of_crawler/</url>
      
        <content type="html"><![CDATA[<h1 id="一、爬虫的基本原理"><a href="#一、爬虫的基本原理" class="headerlink" title="一、爬虫的基本原理"></a>一、爬虫的基本原理</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>爬虫就是假装浏览器爬取网页并获取信息.</p><h2 id="爬取数据类型"><a href="#爬取数据类型" class="headerlink" title="爬取数据类型"></a>爬取数据类型</h2><ul><li>最常见的就是爬虫能爬取JSON形式的HTML代码.</li><li>对于js,css等文件,需分析源代码后台Ajax接口,或者使用<code>Selenium</code>,<code>Splash</code>,<code>Pyppeteer</code>,<code>Playwright</code>等库来模拟js渲染.<h1 id="二、Session-和-Cookie"><a href="#二、Session-和-Cookie" class="headerlink" title="二、Session 和 Cookie"></a>二、Session 和 Cookie</h1><h2 id="无状态HTTP-查询wink状态"><a href="#无状态HTTP-查询wink状态" class="headerlink" title="无状态HTTP (#查询wink状态)"></a>无状态HTTP <del>(#查询wink状态)</del></h2>HTTP对无状态表示HTTP协议对于事务处理没有记忆能力,也就是说服务器并不知道客户端处于什么状态.这意味着如果需要处理前面的信息,客户端必须重传,造成资源浪费.所以,服务器端会保存一个<code>Session</code>,客户端保存一个<code>Cookie</code>,通过这两个凭证,服务器才能做出相应响应.<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2>Web中,Session对象用来存储特定用户是所需的属性和配置信息.这样用户再响应的网页跳转时,存储在Session中的信息不丢失.如果Session过期或者没有Session,服务器会创建一个Session.<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2>见<a href="the_principle_of_HTTP.md">HTTP原理</a><h2 id="Session维持"><a href="#Session维持" class="headerlink" title="Session维持"></a>Session维持</h2>客户端第一次请求服务器的时候,服务器会返回一个<code>Set_Cookie</code>.客户端保存响应字符串,并在之后的请求中带上<code>Cookie</code>.<code>Cookie</code>中保存着响应的<code>SessionID</code>,服务器通过查询<code>SessionID</code>来找到对应<code>Session</code>,进而判断用户状态.<h2 id="Cookie的属性结构"><a href="#Cookie的属性结构" class="headerlink" title="Cookie的属性结构"></a>Cookie的属性结构</h2>在浏览器中打开<code>Application</code>选项卡,<code>Storage</code>最后一项就是<code>Cookie</code>.</li><li><strong>Name</strong>: <code>Cookie</code>名称</li><li><strong>Value</strong>:<code>Cookie</code>的值,如果是<code>Unicode</code>字符则需要字符编码,如果是二进制数据,则是<code>BASE64</code>编码.</li><li><strong>Domain</strong>:指定可以访问该<code>Cookie</code>的域名.表示该<code>Cookie</code>的可用范围.</li><li><strong>Path</strong>:<code>Cookie</code>的使用路径.如果是/path/,则表示只在该路径可用,如果是/则表示在该<code>Domain</code>下都可用.</li><li><strong>Size</strong>:表示<code>Cookie</code>的大小.</li><li><strong>HTTP</strong>:<code>Cookie</code>的<code>httponly</code>属性,如果是<code>True</code>,则表示只有在<code>HTTP Headers</code>中才含有此<code>Cookie</code>,而不能使用<code>document.cookie</code>来访问此<code>Cookie</code>.</li><li><strong>Secure</strong>:是否允许使用安全协议传输<code>Cookie</code>.<h2 id="会话Cookie和持久Cookie"><a href="#会话Cookie和持久Cookie" class="headerlink" title="会话Cookie和持久Cookie"></a>会话Cookie和持久Cookie</h2>会话<code>Cookie</code>和持久<code>Cookie</code>本质只是Cookie存储的位置不同,一个是存在缓存,一个是存在硬盘.持久<code>Cookie</code>的有效期很久,所以可以在下次登录的时候直接使用硬盘中的<code>Cookie</code>.<h1 id="三、代理的基本原理"><a href="#三、代理的基本原理" class="headerlink" title="三、代理的基本原理"></a>三、代理的基本原理</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2>代理本名代理服务器(<code>Proxy Server</code>),功能是代网络用户获得信息.客户端把请求发给代理服务器,代理服务器再把请求发给服务器.响应在经过代理服务器返回给客户端.在这个过程中服务器接受到的是代理服务器的<code>IP</code>.<h2 id="代理的作用"><a href="#代理的作用" class="headerlink" title="代理的作用"></a>代理的作用</h2></li><li>突破IP访问限制,访问一些访问不到的站点 <del>(科学上网)</del></li><li>访问一些单位或者团队的内部资源 (校园VPN)</li><li>提高访问速度.代理服务器一般都有一个较大的硬盘缓冲区,可以保存数据.如果其他用户访问,可以直接把这些数据给用户(类似<code>cache</code>)</li><li>隐藏真实的IP,保护个人信息.<h2 id="爬虫代理"><a href="#爬虫代理" class="headerlink" title="爬虫代理"></a>爬虫代理</h2>爬虫爬取速度过快,服务器检测到一个IP地址行为异常会直接封锁IP.使用代理,爬虫就会认为是代理服务器在访问自己,通过切换代理就能防止被发现.<h2 id="代理分类"><a href="#代理分类" class="headerlink" title="代理分类"></a>代理分类</h2><h3 id="根据协议区分"><a href="#根据协议区分" class="headerlink" title="根据协议区分"></a>根据协议区分</h3></li><li>FTP代理,访问FTP服务器,主要端口是21和2121</li><li>HTTP代理 访问HTTP服务器,主流的代理,端口是80和8080</li><li>SSL/TLS代理 主要访问加密网站,一般有SSL和TLS加密功能,端口一般是443</li><li>RTSP代理 主要用于Realplayer访问Real流服务器,端口一般是554</li><li>Telnet代理 主要用于Telnet远程控制(黑客Ddos攻击时隐藏身份),一般端口时23</li><li>POP3/SMTP代理 主要用于以POP3/SMTP发送邮件,具有缓存功能,端口一般是110/25</li><li>SOCKS代理 单纯传递数据包,不关心协议和用法,一般有缓存功能,端口一般是1080.SOCK代理分为SOCKS4和SOCKS5.SOCKS4只支持TCP,SOCKS支持TCP和UDP,还支持身份验证机制,服务器端域名解析等.<h3 id="根据匿名程度区分"><a href="#根据匿名程度区分" class="headerlink" title="根据匿名程度区分"></a>根据匿名程度区分</h3></li><li>高度匿名代理 将数据包原封不动转发,在服务端看来就是一个普通客户端,记录的是代理的IP</li><li>普通匿名代理 会对数据包做一些处理,服务端可能发现这是一个代理,然后追查客户端的真实IP.这种代理通常会加入的HTTP头有HTTP_VIA,HTTP_X_FORWARDED_FOR</li><li>透明代理 该种代理不仅会更改数据包,还会告诉服务器真实IP,主要用于过滤数据包,常用于内网防火墙.</li><li>间谍代理 常见于组织或者个人创建的代理服务器,用于记录用户传输的数据,然后对传输数据进行研究和监控.<h3 id="常见代理设置"><a href="#常见代理设置" class="headerlink" title="常见代理设置"></a>常见代理设置</h3></li><li>网上的免费代理,建议全部抓取下来一个个筛选,然后维护代理池.</li><li>付费代理</li><li>ADSL拨号,昂贵但是稳定性高</li><li>蜂窝代理 即使用4G/5G网卡等制作的代理.该代理情形较小,封锁概念低,但是成本高.<h1 id="四、多线程和多进程的基本原理"><a href="#四、多线程和多进程的基本原理" class="headerlink" title="四、多线程和多进程的基本原理"></a>四、多线程和多进程的基本原理</h1><h2 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h2>进程可以理解为独立运行的程序单位.比如打开浏览器.<br>线程是进程中的多个任务,比如浏览器打开之后访问网址,加载网页,看视频能同时进行.这就是多线程<h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2></li><li>并发:指多个线程对应的多条指令被快速轮换地执行.人宏观上感受不到进程切换,感觉是一起执行</li><li>并行:指同一时刻有多条指令在多个处理器上同时执行.宏观和微观上都是并行.<h2 id="多线程的爬虫应用场景"><a href="#多线程的爬虫应用场景" class="headerlink" title="多线程的爬虫应用场景"></a>多线程的爬虫应用场景</h2>爬虫在向服务器发送请求等待响应的时间内可以处理其他线程.<h2 id="Python中的多线程"><a href="#Python中的多线程" class="headerlink" title="Python中的多线程"></a>Python中的多线程</h2>Python中GIL(Global Interpreter Lock)的限制导致同一时刻下只可能进行一个线程,无法发挥多核并行的优势.所以不可能并行,只能并发.<h3 id="Python多线程下每个线程的执行方式"><a href="#Python多线程下每个线程的执行方式" class="headerlink" title="Python多线程下每个线程的执行方式:"></a>Python多线程下每个线程的执行方式:</h3></li><li>获取GIL</li><li>执行代码</li><li>释放GIL<br>Python多进程效果强于多线程.因为每一个进程都有自己的GIL,互不干扰.而多线程需要频繁切换GIL,反而减慢速度.</br><br>可见大佬博客学习</br><blockquote><p>python多线程:<a href="https://cuiqingcai.com/3325.html">https://cuiqingcai.com/3325.html</a></br><br>python多进程:<a href="https://cuiqingcai.com/3335.html">https://cuiqingcai.com/3335.html</a></br></p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 爬虫学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spider/crawler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>urllib的使用</title>
      <link href="/2022/01/16/the_use_of_urllib/"/>
      <url>/2022/01/16/the_use_of_urllib/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是python自带的爬虫相关模块,但市面上有更好的BeautifulSoup模块和requests模块.如果是速成爬虫直接学习那两个模块用法即可,但requests模块是使用urllib搭建而成,如果时间不急,可以从底层看起.</br></p><h1 id="urllib的使用"><a href="#urllib的使用" class="headerlink" title="urllib的使用"></a>urllib的使用</h1><p>基本模块:</p><ul><li><strong>request</strong>:HTTP请求模块</li><li><strong>error</strong>:异常处理模块</li><li><strong>parse</strong>:工具模块,提供url处理方法</li><li><strong>robotparser</strong>:识别网站的robot.txt文件<h2 id="requset模块"><a href="#requset模块" class="headerlink" title="requset模块"></a>requset模块</h2><h3 id="urlopen"><a href="#urlopen" class="headerlink" title="urlopen"></a>urlopen</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> urllib<span class="token punctuation">.</span>requsetresponse <span class="token operator">=</span> urlib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>url<span class="token punctuation">,</span>data<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span><span class="token punctuation">[</span>timeout<span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">,</span>cafile<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>capath<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>cadefault<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>context<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><strong ><font face = "仿宋"  size = 4 >参数解释</font></strong ></li><li>url: 网页地址</li><li>data: <code>bytes</code>类型的字节流编码<blockquote><p><code>data = bytes(urllib.parse.urlencode(&#123;&#39;username&#39;:&#39;admin&#39;&#125;),encoding = &quot;utf-8&quot;)</code></p></blockquote></li><li>timeout:超时时间设置,单位秒.</li><li>其他参数:<blockquote><p>context:接受ssl.SSLContext类,用来设置SSL</br><br>cafile/capath:设置CA证书和其路径,请求https链接有用</br><br>cadefault:已经弃用</br></p></blockquote></li></ul><h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> urllib<span class="token punctuation">.</span>requestrequest <span class="token operator">=</span> urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>Request<span class="token punctuation">(</span>url<span class="token punctuation">)</span>response <span class="token operator">=</span> urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>Request</code>使用<code>Request</code>对象传给<code>urlopen</code>,可读性更高,封装更好.</p><h4 id="Request构造"><a href="#Request构造" class="headerlink" title="Request构造"></a>Request构造</h4><pre class="line-numbers language-none"><code class="language-none">request &#x3D; urllib.request.Request(url,data&#x3D;None,headers&#x3D;&#123;&#125;,origin_req_host&#x3D;None,unverifiable&#x3D;False,method&#x3D;None)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>url:同urlopen</li><li>data:同urlopen</li><li>headers:传一个字典参数,作为请求头</li><li>origin_req_host:请求方的host名称或者IP地址</li><li>unverifiable:表示请求是否是无法验证的,默认为<code>False</code>,表示用户没有足够的权限来接受这个请求的结果</li><li>method:字符串参数,表示请求方法,如GET,POST,PUT,DELETE<h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3>request的高级用法依托<code>Handler</code>实现.<br>首先是所有<code>Handler</code>的父类<code>BaseHandler</code>,其提供了基本方法,如default_open,protocol_request等<br>其几个子类如下<blockquote><ul><li><strong>HTTPDefaultErrorHandler</strong>:用于处理<code>HTTP</code>响应错误,所有错误都会抛出<code>HTTPError</code>类型的异常</li><li><strong>HTTPRedirectHandler</strong>:用于处理重定向</li><li><strong>HTTPCookieProcessor</strong>:用于处理Cookie</li><li><strong>ProxyHandler</strong>:用于设置代理,代理默认为空</li><li><strong>HTTPPasswordMgr</strong>:用于密码管理,维护者用户名密码对照表</li><li><strong>HTTPBasicAuthHandler</strong>:用于管理认证,如果一个链接在打开的时候需要认证,那么可以用这个解决认证问题.</li></ul></blockquote></li></ul></br><p>另外一个比较重要的类是<code>OpenerDirector</code>,简称Opener.之前的<code>urlopen</code>方法就是一个<code>Opener</code>.<code>Request</code>类和<code>urlopen</code>类都是已经封装好的常用请求方法,如果需要高级用法则需要使用更加底层的实例来完成操作.</br><br><code>Opener</code>类提供<code>Open</code>方法,该方法的返回的响应类型和<code>urlopen</code>方法一致.<code>Opener</code>类需要使用<code>Handler</code>类来构建.<br></br></p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>在访问一些服务器的时候,有些网页需要用户输入账号密码进行身份验证.这就是<code>HTTP Basic Access Authentication</code>.</br><br>爬虫借助<code>HTTPBasicAuthHandler</code>模块就能完成身份验证.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> urllib<span class="token punctuation">.</span>request <span class="token keyword">import</span> HTTPPasswordMgrWithDefaultRealm<span class="token punctuation">,</span> HTTPBasicAuthHandler<span class="token punctuation">,</span> build_opener<span class="token keyword">import</span> urllib<span class="token punctuation">.</span>errorusername <span class="token operator">=</span> <span class="token string">'admin'</span>password <span class="token operator">=</span> <span class="token string">'password'</span>url <span class="token operator">=</span> <span class="token string">''</span>p <span class="token operator">=</span> HTTPPasswordMgrWithDefaultRealm<span class="token punctuation">(</span><span class="token punctuation">)</span> p<span class="token punctuation">.</span>addpassword<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">,</span>url<span class="token punctuation">,</span>username<span class="token punctuation">,</span>password<span class="token punctuation">)</span> <span class="token comment">##这个类是构建　用户名和密码　对一个地址的映射，这个映射可以是　url 也可以是 proxy </span>auth_handler <span class="token operator">=</span> HTTPBasicAuthHandler<span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token comment">## HTTPBasicAuthHandler的构造方法需要提供一个HTTPPasswordMgr(密码管理 Password Management Object) 对象 如果不知道域/对域不需要关心,就使用 HTTPPasswordMgrwithDefaultRealm 对象,使用None作为构造参数,知道的话就使用realm代替None </span>opener <span class="token operator">=</span> build_opener<span class="token punctuation">(</span>auth_handler<span class="token punctuation">)</span> <span class="token comment">## 构建了一个opener,可以使用这个opener去open url.如果这个opener是 网页验证,那么就是open url,如果是 代理验证,那么访问的时候,就是使用代理ip帮你访问(相当于Request封装再更底层)</span><span class="token keyword">try</span><span class="token punctuation">:</span>    result <span class="token operator">=</span> opener<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>    html <span class="token operator">=</span> result<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span><span class="token keyword">except</span> URLError <span class="token keyword">as</span> e<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>reason<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>代理的逻辑同验证一样,先使用ProxyHandler建立代理,再使用build_opener方法建立opener,再使用这个opener打开你需要的web</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> urllib<span class="token punctuation">.</span>requset <span class="token keyword">import</span> ProxyHandler<span class="token punctuation">,</span> build_opener<span class="token punctuation">,</span> <span class="token keyword">from</span> urllib<span class="token punctuation">.</span>error <span class="token keyword">import</span> URLErrorproxy_Handler <span class="token operator">=</span> ProxyHandler<span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token string">'http'</span><span class="token punctuation">:</span><span class="token string">'http://'</span><span class="token punctuation">,</span>                             <span class="token string">'https'</span><span class="token punctuation">:</span><span class="token string">'https://'</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token comment">## ProxyHandler类的构造需要一个字典</span>opener <span class="token operator">=</span> build_opener<span class="token punctuation">(</span>proxy_Handler<span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">:</span>    response <span class="token operator">=</span> opener<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">except</span> URLError <span class="token keyword">as</span> e<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>reason<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是如果碰到了代理验证的话,那么还是需要使用HTTPBasicAuthHandler</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> urllib<span class="token punctuation">.</span>request <span class="token keyword">import</span> HTTPPasswordMgrWithDefaultRealm<span class="token punctuation">,</span> HTTPBasicAuthHandler<span class="token punctuation">,</span> build_opener<span class="token keyword">import</span> urllib<span class="token punctuation">.</span>errorusername <span class="token operator">=</span> <span class="token string">'admin'</span>password <span class="token operator">=</span> <span class="token string">'password'</span>proxyserver <span class="token operator">=</span> <span class="token string">"61.158.163.130:16816"</span> <span class="token operator">//</span> 此时代理地址直接使用IP地址的字符串url <span class="token operator">=</span> <span class="token string">''</span>p <span class="token operator">=</span> HTTPPasswordMgrWithDefaultRealm<span class="token punctuation">(</span><span class="token punctuation">)</span> p<span class="token punctuation">.</span>addpassword<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">,</span>proxyserver<span class="token punctuation">,</span>username<span class="token punctuation">,</span>password<span class="token punctuation">)</span> <span class="token comment">##这个类是构建　用户名和密码　对代理地址的映射</span>auth_handler <span class="token operator">=</span> HTTPBasicAuthHandler<span class="token punctuation">(</span>p<span class="token punctuation">)</span> opener <span class="token operator">=</span> build_opener<span class="token punctuation">(</span>auth_handler<span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">:</span>    result <span class="token operator">=</span> opener<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>    html <span class="token operator">=</span> result<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span><span class="token keyword">except</span> URLError <span class="token keyword">as</span> e<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>reason<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>获取网站的Cookie,就是根据网站的响应头里面的 Set_Cookie的值来设置Cookie.</br><br>思路是构建CookieJar对象,再用这个对象创建opener,用这个opener打开网站,其响应的cookie会自动给CookieJar对象,通过直接访问CookieJar对象来获得Cookie.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> urlib<span class="token punctuation">.</span>request <span class="token keyword">import</span> HTTPCookieProcessor<span class="token punctuation">,</span>build_opener<span class="token keyword">from</span> http<span class="token punctuation">.</span>cookiejar <span class="token keyword">import</span> CookieJarcookie <span class="token operator">=</span> CookieJar<span class="token punctuation">(</span><span class="token punctuation">)</span>handler <span class="token operator">=</span> HTTPCookieProcessor<span class="token punctuation">(</span>cookie<span class="token punctuation">)</span>opener <span class="token operator">=</span> build_opener<span class="token punctuation">(</span>handler<span class="token punctuation">)</span>response <span class="token operator">=</span> opener<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token keyword">for</span> items <span class="token keyword">in</span> cookie<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">':'</span> <span class="token operator">+</span> item<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果需要保存cookie的话,那么需要使用MozillaCookieJar.它是CookieJar的子类,专门用于处理Cookie,比如Cookie的读取和保存,其将Cookie保存为Mozilla浏览器类型的Cookie,也就是在请求头中看到的格式.</br></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> urlib<span class="token punctuation">.</span>request <span class="token keyword">import</span> HTTPCookieProcessor<span class="token punctuation">,</span>build_opener<span class="token keyword">from</span> http<span class="token punctuation">.</span>cookiejar <span class="token keyword">import</span> MozillaCookieJarfilename <span class="token operator">=</span> <span class="token string">'cookie.txt'</span>cookie <span class="token operator">=</span> MozillaCookieJar<span class="token punctuation">(</span>filename<span class="token punctuation">)</span>handler <span class="token operator">=</span> HTTPCookieProcessor<span class="token punctuation">(</span>cookie<span class="token punctuation">)</span>opener <span class="token operator">=</span> build_opener<span class="token punctuation">(</span>handler<span class="token punctuation">)</span>response <span class="token operator">=</span> opener<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>cookie<span class="token punctuation">.</span>save<span class="token punctuation">(</span>ignore_discard <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">,</span>ignore_expires <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token comment">## ignore_discard 及时被弃用也将其保存下来,ignore_expires 及时已经过期也将其保存</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样的,如果是LWP(<code>libwww-perl</code>)格式,则使用</p><pre class="line-numbers language-none"><code class="language-none">cookie &#x3D; LWPCookieJar(filename)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那么,如何读取利用cookie?.下面是代码</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> urllib<span class="token punctuation">.</span>request <span class="token keyword">import</span> HTTPCookieProcessor<span class="token punctuation">,</span>build_opener<span class="token keyword">from</span> http<span class="token punctuation">.</span>cookiejar <span class="token keyword">import</span> MozillaCookieJarcookie <span class="token operator">=</span> CookieJar<span class="token punctuation">(</span><span class="token punctuation">)</span>cookie<span class="token punctuation">.</span>load<span class="token punctuation">(</span><span class="token string">"cookie.txt"</span><span class="token punctuation">,</span>ignore_discard <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">,</span>ignore_expires <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">)</span>handler <span class="token operator">=</span> HTTPCookieProcessor<span class="token punctuation">(</span>cookie<span class="token punctuation">)</span>opener <span class="token operator">=</span> build_opener<span class="token punctuation">(</span>handler<span class="token punctuation">)</span>response <span class="token operator">=</span> opener<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p><code>urllib.error</code>定义了<code>urllib.request</code>库产生的异常</p><h3 id="URLError"><a href="#URLError" class="headerlink" title="URLError"></a>URLError</h3><p><code>URLError</code>来自<code>urllib.error</code>库,继承于<code>OSError</code>,是<code>urllib.error</code>异常模块的基类.它具有一个reason属性,返回错误原因.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> urllib<span class="token punctuation">.</span>error<span class="token keyword">try</span><span class="token punctuation">:</span>    result <span class="token operator">=</span> opener<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>    html <span class="token operator">=</span> result<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span><span class="token keyword">except</span> URLError <span class="token keyword">as</span> e<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>reason<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="HTTPError"><a href="#HTTPError" class="headerlink" title="HTTPError"></a>HTTPError</h3><p><code>HTTPError</code>是<code>URLError</code>的子类,专门用来处理<code>HTTP</code>请求错误,例如认证请求失败.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> urllib<span class="token punctuation">.</span>error<span class="token keyword">try</span><span class="token punctuation">:</span>    result <span class="token operator">=</span> opener<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>    html <span class="token operator">=</span> result<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span><span class="token keyword">except</span> HTTPError <span class="token keyword">as</span> e<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>reason<span class="token punctuation">,</span>e<span class="token punctuation">.</span>code<span class="token punctuation">,</span>e<span class="token punctuation">.</span>headers<span class="token punctuation">)</span><span class="token keyword">except</span> URLError <span class="token keyword">as</span> e<span class="token punctuation">:</span> <span class="token comment">##如果不是HTTPError,则进入URLError捕获</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>reason<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="解析链接"><a href="#解析链接" class="headerlink" title="解析链接"></a>解析链接</h2><p><code>urllib.parse</code>块定义了处理URL的标准接口,例如实现URL各部分的抽取,合并已经连接转换.</p><h3 id="urlparse"><a href="#urlparse" class="headerlink" title="urlparse"></a>urlparse</h3><p>该方法实现<code>URL</code>的识别和分段</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> urllib<span class="token punctuation">.</span>parse <span class="token keyword">import</span> urlparseresult <span class="token operator">=</span> urlparse<span class="token punctuation">(</span><span class="token string">'https://www.baidu.com/index.html;user?id=5#commemt'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">##&lt;class 'urllib.parse.ParseResult'>,是一个元组,可以使用索引或者序列号访问其中的元素</span><span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token comment">## scheme,netloc,path,params,query fragment</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可得标准链接格式:</p><pre class="line-numbers language-none"><code class="language-none">scheme:&#x2F;&#x2F;netloc&#x2F;path;params?query#fragment<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>urlparse</code>含有三个参数,下面是解释</p><ul><li><strong>urlstring</strong>:待解析的url</li><li><strong>scheme</strong>:默认的协议,如果url没有提供协议则会用这个代替</li><li><strong>allow_fragment</strong>:是否忽略<code>fragment</code></li></ul><h3 id="urlunparse"><a href="#urlunparse" class="headerlink" title="urlunparse"></a>urlunparse</h3><p>此方法用于构造url.参数必须是一个可迭代对象,长度必须为6,否则会抛出异常.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> urllib<span class="token punctuation">.</span>parse <span class="token keyword">import</span> urlunparsestring <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"https"</span><span class="token punctuation">,</span><span class="token string">"www.baidu.com"</span><span class="token punctuation">,</span><span class="token string">"index.html"</span><span class="token punctuation">,</span><span class="token string">"user"</span><span class="token punctuation">,</span><span class="token string">"id=5"</span><span class="token punctuation">,</span><span class="token string">"commemt"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="urlsplit"><a href="#urlsplit" class="headerlink" title="urlsplit"></a>urlsplit</h3><p>和<code>urlparse</code>类似,只不过<code>params</code>不会单独出现,划分为path的一部分,返回结果是<code>SplitResult</code>,和<code>ParseResult</code>类似,既能索引,也可以序列访问.</p><h3 id="urlunsplit"><a href="#urlunsplit" class="headerlink" title="urlunsplit"></a>urlunsplit</h3><p>和<code>urlunparse</code>类似,使用长度为5的可迭代对象.</p><h3 id="urljoin"><a href="#urljoin" class="headerlink" title="urljoin"></a>urljoin</h3><p>该方法需要两个参数,一个是<code>base_url</code>,一个是待修改的链接.该方法会分析<code>base_url</code>中的<code>scheme</code>,<code>netloc</code>和<code>path</code>.如果待修改的链接不含这三个部分中的一个,则补充上去.</p><h3 id="urlencode"><a href="#urlencode" class="headerlink" title="urlencode"></a>urlencode</h3><p>这个方法在<code>GET</code>方法中特别实用</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> urllib<span class="token punctuation">.</span>parse <span class="token keyword">import</span> urlencodequery <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token string">'tn'</span><span class="token punctuation">:</span><span class="token string">'monline_3_dg'</span><span class="token punctuation">,</span>    <span class="token string">'ie'</span><span class="token punctuation">:</span><span class="token string">'utf-8'</span><span class="token punctuation">,</span>    <span class="token string">'wd'</span><span class="token punctuation">:</span><span class="token string">'python'</span><span class="token punctuation">&#125;</span>base_url <span class="token operator">=</span> <span class="token string">'https://www.baidu.com?'</span>url <span class="token operator">=</span> base_url <span class="token operator">+</span> urlencode<span class="token punctuation">(</span>query<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span> <span class="token comment">## https://www.baidu.com?tn=monline_3_dg&amp;ie=utf-8&amp;wd=python</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其作用就是把字典参数链接在url后面</p><h3 id="parse-qs"><a href="#parse-qs" class="headerlink" title="parse_qs"></a>parse_qs</h3><p>反序列化方法,将<code>query</code>参数返回为字典</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> urllib<span class="token punctuation">.</span>parse <span class="token keyword">import</span> parse_qsquery <span class="token operator">=</span> <span class="token string">"tn=monline_3_dg&amp;ie=utf-8&amp;wd=python"</span><span class="token keyword">print</span><span class="token punctuation">(</span>parse_qs<span class="token punctuation">(</span>query<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">## query = &#123;</span>                       <span class="token comment">##    'tn':'monline_3_dg',</span>                       <span class="token comment">##    'ie':'utf-8',</span>                       <span class="token comment">##    'wd':'python'</span>                       <span class="token comment">## &#125; </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="parse-qsl"><a href="#parse-qsl" class="headerlink" title="parse_qsl"></a>parse_qsl</h3><p>将参数转化为元组组成的列表</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> urllib<span class="token punctuation">.</span>parse <span class="token keyword">import</span> parse_qslquery <span class="token operator">=</span> <span class="token string">"tn=monline_3_dg&amp;ie=utf-8&amp;wd=python"</span><span class="token keyword">print</span><span class="token punctuation">(</span>parse_qsl<span class="token punctuation">(</span>query<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">## [('tn','monline_3_dg'),('ie','utf-8'),('wd','python')]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="quote"><a href="#quote" class="headerlink" title="quote"></a>quote</h3><p>将内容转化为<code>URL</code>编码格式.如果<code>URL</code>有中文参数,有可能乱码,所以需要<code>quote</code>将其转化为<code> URL</code>编码</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> url<span class="token punctuation">.</span>parse <span class="token keyword">import</span> quotekeyword <span class="token operator">=</span> <span class="token string">"爬虫"</span>url <span class="token operator">=</span> <span class="token string">'https://www.baidu.com/s?wd='</span> <span class="token operator">+</span> quote<span class="token punctuation">(</span>keyword<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="unquote"><a href="#unquote" class="headerlink" title="unquote"></a>unquote</h3><p>将<code>URL</code>编码转成中文</p><h2 id="分析Robot协议"><a href="#分析Robot协议" class="headerlink" title="分析Robot协议"></a>分析Robot协议</h2><p><code>Robot</code>协议也叫机器人协议,全名网络爬虫排除标准(Robot Exclusion Protocal),用来告诉爬虫那些网页可以抓取,那些不行.通常命名为<code>robot.txt</code>,放在网站根目录.</br><br>爬虫在实际爬取时,会先检查是否存在’robot.txt’,如果有则遵从,没有的话就随意爬取.<br>下面是一个<code>robot.txt</code>的实例</p><pre class="line-numbers language-none"><code class="language-none">User-Agent: * &#x2F;对所有爬虫生效Disallow: &#x2F; #不允许爬取任何页面Allow: &#x2F;public&#x2F; #只能爬取public<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="robotparser"><a href="#robotparser" class="headerlink" title="robotparser"></a>robotparser</h3><p>这个模块用于解析<code>robot.txt</code>文件,来判断是由有权利爬取这个网页.</p><pre class="line-numbers language-none"><code class="language-none">urllib.robotparser.RobotFileParser(url &#x3D; &#39;&#39;) ## 可以不设置url,之后用set_url添加<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以下是<code>RobotFileParset</code>常用方法</p><ul><li><strong>set_url</strong>:设置<code>robot.txt</code>文件链接.</li><li><strong>read</strong>:读取文件并进行分析.这个方法包含读取和分析,所以一定要使用.</li><li><strong>parse</strong>:解析文件,传入其中的参数是文件中某些行的内容.</li><li><strong>can_fetch</strong>:需要两个参数,一个是<code>User-Agent</code>,一个是<code>URL</code>.判断是否能爬取.</li><li><strong>mtime</strong>:返回上次抓取分析文件的时间,如果长时间爬取的话就需要获取最新的<code>robot.txt</code>文件来判断自己爬取的合法性.</li><li><strong>modified</strong>:将当前时间设置为上次抓取分析文件的时间,在长时间爬取中很有用.</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一节主要是<code>urllib</code>的使用,使用略显复杂,后面的<code>requesets</code>模块更加方便,但是对于自定义爬虫这很有用.<br>爬取逻辑分析:<br>判断是否需要验证和代理 -&gt; 根据情况建立HTTPBasicAuthHandler(PasswordMgrWithDefaultRealm)或者ProxyHandler(字典) -&gt; 根据Handler建立opener -&gt; 爬取网页,同时记得捕获异常,根据异常修改爬虫. -&gt;如果需要修改cookie,使用HTTPCookieProcessor(CookieJar类).</p>]]></content>
      
      
      
        <tags>
            
            <tag> spider/crawler </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
