<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>操作系统_设备管理</title>
      <link href="/2022/05/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/"/>
      <url>/2022/05/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h1><h2 id="I-O硬件"><a href="#I-O硬件" class="headerlink" title="I/O硬件"></a>I/O硬件</h2><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p>这是在对总线的抽象,<code>CPU</code>,<code>Memory</code>,<code>I/O</code>部件挂载在总线上,通过总线交流<br><img src="images/Bus.drawio.svg" alt="Bus"><br>地址总线传递地址，数据总线传递数据，控制总线传递控制信号。<br>以<code>CPU</code>读入数据为例,<code>CPU</code>发出请求,<code>address bus</code>传递地址,读到的数据通过<code>data bus</code>传递给<code>CPU</code>。</p><h3 id="I-O系统"><a href="#I-O系统" class="headerlink" title="I/O系统"></a>I/O系统</h3><p>这是对<code>I/O</code>的抽象,可见<code>I/O</code>被拆分开,<code>channel processor</code>可以看成分发器,<code>System Bus</code>传来的请求在这里处理,然后发送信号到<code>I/O bus</code>,控制不同的<code>I/O</code>设备.<br><img src="images/IO_bus.svg" alt="IO"><br><code>I/O Bus</code>连接了不同的<code>I/O</code>设备,不同<code>I/O</code>设备的传输数量差了很多倍数量级,键盘打字的速度再快也比不上硬盘的读入,因此,需要对不同设备分别管理.</p><h3 id="I-O设备与管理"><a href="#I-O设备与管理" class="headerlink" title="I/O设备与管理"></a>I/O设备与管理</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p><strong>按照类型分类</strong>:</p><ul><li>传输速度不同:低俗设备,中速设备,高速设备</li><li>数据组织不同:<ul><li>块设备:以数据块为单位存储、传输信息。传输速率较高、可寻址(随机读写)</li><li>字符设备:以字符为单位存储、传输信息。传输速率低、不可寻址。</li></ul></li><li>共享属性不同:<ul><li>独占设备:一次只能由一个进程访问,比如打印机</li><li>共享设备:可以多个进程访问的设备</li><li>虚拟设备:在一类设备上模拟另一类设备，常用的方法是，用共享设备模拟独占设备，用高速设备模拟低速设备。</li></ul></li></ul><h4 id="设备管理-1"><a href="#设备管理-1" class="headerlink" title="设备管理"></a>设备管理</h4><p><strong>目标</strong>:</p><ul><li>按照请求,操作设备,完成数据交换,最终完成用户请求</li><li>建立方便,统一的独立于设备的接口(抽象)</li><li>充分利用技术,提高CPU与设备,设备与设备之间的并行工作能力,提高利用率</li><li>保护信息</li></ul><h3 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h3><p><img src="images/IO_Controller.svg" alt="设备控制器"></p><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul><li>接收和识别CPU给来的命令</li><li>数据交换：CPU与控制器、控制器与设备</li><li>设备状态的了解和报告</li><li>设备地址识别</li><li>缓冲区</li><li>对设备传来的数据进行差错检测</li></ul><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><ul><li>控制器与<code>CPU</code>的接口: 数据寄存器,控制寄存器,状态寄存器,采用内存映射或专门的<code>I/O</code>指令</li><li>控制器与设备的接口: 数据信号,控制信号,状态信号</li><li><code>I/O</code>逻辑: 用于实现<code>CPU</code>对<code>I/O</code>设备控制</li></ul><h3 id="I-O端口地址"><a href="#I-O端口地址" class="headerlink" title="I/O端口地址"></a>I/O端口地址</h3><p><code>I/O</code>端口地址指的是接口电路中每个寄存器具有唯一的地址</p><p>每个设备的<code>I/O</code>端口地址形成<code>I/O</code>地址空间,由OS保护</p><p><code>I/O</code>指令形式和<code>I/O</code>地址相关联,分类如下:</p><ul><li>内存映像编址(内存映像<code>I/O</code>模式):<ul><li>控制器的寄存器作为物理空间的一部分,可以直接通过地址访问</li></ul></li><li><code>I/O</code>独立编址(<code>I/O</code>专用指令):<ul><li>由专门的指令访问<code>I/O</code>端口,就像<code>CP0</code>中的寄存器通过<code>mfc0,mtc0</code>访问类似,<code>add</code>等指令无法访问<code>CP0</code>寄存器,<code>intel</code>架构中有<code>in/out</code>指令</li></ul></li></ul><h4 id="内存映像I-O模式特点"><a href="#内存映像I-O模式特点" class="headerlink" title="内存映像I/O模式特点:"></a>内存映像<code>I/O</code>模式特点:</h4><p><strong>优点</strong>:</p><ul><li>不需要特殊的保护机制来组织用于进程访问,只需要当成内核地址一样即可.</li><li>不需要额外指令集,减轻编程负担</li></ul><p><strong>缺点</strong>:</p><ul><li>不允许把控制寄存器放入高速缓存,因为该寄存器的值会改变<h4 id="I-O独立编址特点"><a href="#I-O独立编址特点" class="headerlink" title="I/O独立编址特点:"></a><code>I/O</code>独立编址特点:</h4></li></ul><p><strong>优点</strong>:</p><ul><li>外设不占用地址空间</li><li>编程时易区分是对内存操作还是<code>I/O</code>操作</li></ul><p><strong>缺点</strong>:</p><ul><li><code>I/O</code>指令少,操作不灵活</li></ul><h3 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I/O控制方式"></a>I/O控制方式</h3><ul><li>程序控制<code>I/O</code>:也称轮询或者查询方式<code>I/O</code>.</li><li>中断驱动:当<code>I/O</code>操作结束后由设备控制器主动来通知驱动程序说这次结束.</li><li><code>DMA(Direct Memory Access)</code>:直接存储器访问方式,由一个专门的控制器完成数据到内存和设备或者是从设备到内存的传输工作</li><li>通道:与<code>DMA</code>很类似,但是<code>DMA</code>依然离不开<code>CPU</code>,需要<code>CPU</code>的控制信号,通道则更加<strong>独立</strong>.<strong>它有自己的指令和程序</strong>专门负责数据输入输出的传输控制.CPU将“传输控制”的功能下放给通道后只负责“数据处理”功能.这样,通道与CPU<strong>分时使用内存</strong>，实现了CPU内部运算与I/O设备的<strong>并行</strong>工作.<h4 id="程序控制I-O"><a href="#程序控制I-O" class="headerlink" title="程序控制I/O"></a>程序控制<code>I/O</code></h4><img src="images/%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6IO.svg" alt="程序控制I/O"><h4 id="中断驱动"><a href="#中断驱动" class="headerlink" title="中断驱动"></a>中断驱动</h4><img src="images/%E4%B8%AD%E6%96%AD%E9%A9%B1%E5%8A%A8.svg" alt="中断驱动"><h4 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h4></li><li>命令/状态寄存器(<code>CR</code>):用于接受从CPU发送来的I/O命令,或有关控制信息,或设备状态.</li><li>内存地址寄存器(<code>MAR</code>):在输入时,它存放把数据从设备传送到内存的起始目标地址,在输出的时候,它存方由内存到设备的内存源地址.</li><li>数据寄存器(<code>DR</code>):用于暂存从设备到内存,或从内存到设备的数据.</li><li>数据计数器(<code>DC</code>):存放本次<code>CPU</code>要读或写的字节数.<br><img src="images/DMA.svg" alt="DMA"></li><li>优点:<ul><li><code>CPU</code>只需要干预<code>I/O</code>操作的开始和结束,后续数据读写无需CPU控制</li></ul></li><li>缺点:<ul><li>数据传输方向,地址,数据大小都由CPU控制,占用<code>CPU</code>时间</li><li>每个设备占用一个<code>DMA</code>控制器,当设备增加的时候,需要增加新的<code>DMA</code>控制器<h4 id="I-O通道"><a href="#I-O通道" class="headerlink" title="I/O通道"></a>I/O通道</h4></li></ul></li></ul><p><strong>基本思想</strong>:<br>进一步减少<code>CPU</code>的干预.</p><p><code>I/O</code>通道有自己的处理器和指令体系,独立于<code>CPU</code>,可进行更复杂的<code>I/O</code>控制.通道程序通常由操作系统构造,放在内存.</p><ul><li><strong>优点</strong>:<ul><li>执行一个通道程序可以完成机组I/O操作,减少<code>CPU</code>干预.</li></ul></li><li><strong>缺点</strong>:<ul><li>费用高</li></ul></li></ul><p><strong>I/O通道分类</strong></p><ul><li><strong>字节多路通道</strong><ul><li>以字节为单位交叉工作:当为一台设备传送一个字节后,立即转去为另一台设备传送一个字节,是用于低速或中速<code>I/O</code>设备.</li></ul></li><li><strong>选择通道</strong><ul><li>以组方式工作:每次传送一批数据,传送速率很高,但一段时间只能为一个设备服务.当当前<code>I/O</code>请求处理完之后,就选择另一台设备服务,适用于高速设备.</li></ul></li><li><strong>数组多路通道</strong><ul><li>综合字节多路通道<strong>分时工作</strong>和<strong>选择通道</strong>传输速率高的特点,实质是:对通道程序采用多道程序设计技术,使得与通道连接而设备可以并行工作.</li></ul></li></ul><h4 id="DMA与通道区别"><a href="#DMA与通道区别" class="headerlink" title="DMA与通道区别"></a>DMA与通道区别</h4><ul><li>通道更加独立,<code>DMA</code>数据传输方向,地址,大小还脱离不了<code>CPU</code>,通道则有自己的指令体系,执行通道程序就能实现对数据传输控制.</li><li>DMA通常只能控制一台或者少数几台同类设备,而一个通道可以同时控制多种设备</li></ul><h2 id="I-O软件"><a href="#I-O软件" class="headerlink" title="I/O软件"></a>I/O软件</h2><p><img src="images/%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB.svg" alt="层次关系"></p><h3 id="设备独立性"><a href="#设备独立性" class="headerlink" title="设备独立性"></a>设备独立性</h3><p>类似于逻辑地址和物理地址的结构,对于设备而言也有逻辑设备和物理设备.应用程序访问的是逻辑设备,经过逻辑设备表转换为物理设备.这样的好处是:</p><ul><li>设备分配的灵活性:当计算机连接多台相同设备的时候,如果进程直接访问物理设备,而该物理设备繁忙,那么就会阻塞.如果访问逻辑设备,则是请求的一类设备,由<code>OS</code>完成分配.</li><li>易于<code>I/O</code>重定向,用于<code>I/O</code>操作的设备通过修改逻辑设备表即可实现更换,而不需要更换应用程序,同时也提升了程序的可移植性</li></ul><h3 id="逻辑设备表-LUT"><a href="#逻辑设备表-LUT" class="headerlink" title="逻辑设备表(LUT)"></a>逻辑设备表(LUT)</h3><p>为了实现设备独立性,系统设置的一张由逻辑设备映射到物理设备的表,该表表项包含三项:<strong>逻辑设备名</strong>,<strong>物理设备名</strong>,<strong>驱动程序入口地址</strong>.</p><p><code>LUT</code>的设置课采用两种方式:</p><ul><li>整个系统设置一张<code>LUT</code>:该表中不能出现重复的逻辑设备名,因此用户不能使用相同的逻辑设备名(保证用户的独立性)</li><li>每个用户一张<code>LUT</code>:每个用户登录时,便为该用户建立一个进程,同时设置一张<code>LUT</code>放入进程的<code>PCB</code>中.</li></ul><h3 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h3><p>与设备密切相关的代码放在设备驱动程序中,<strong>每个设备驱动程序处理一种设备类型</strong>.</p><p>设备驱动程序的任务时<strong>接受来自于设备无关的上层软件的抽象请求</strong>,并执行请求.</p><p>每一个控制器都设有一个或多个设备寄存器,用于存放向设备发送的命令和参数,<strong>设备驱动程序负责释放这些命令,监督正确执行</strong>.</p><p>它是I/O设备和设备控制器之间的通信程序</p><p>驱动程序与I/O设备的<strong>特性</strong>,<strong>控制方式</strong>,<strong>硬件</strong>密切相关,特殊优化.</p><h4 id="设备驱动程序的组成"><a href="#设备驱动程序的组成" class="headerlink" title="设备驱动程序的组成"></a>设备驱动程序的组成</h4><ul><li><strong>自动配置和初始化子程序</strong>:检测对应的硬件设备是否存在且正常,并完成对该设备及其相关设备驱动程序所需要的软件状态的初始化.在初始化时被调用一次</li><li><strong>I/O操作子程序</strong>:调用该子程序是系统调用的结果,执行该部分程序时仍属于调用它的进程,只是进入了核心态.</li><li><strong>中断服务子程序</strong>:系统来接受系统中断,再有系统调用中断服务子程序.因为设备驱动程序一般支持同一类型的若干设备,所以一般在系统调用中断服务子程序的时候,都带有一个或多个参数,以标识请求服务的设备.</li></ul><h4 id="设备驱动属于内核"><a href="#设备驱动属于内核" class="headerlink" title="设备驱动属于内核"></a>设备驱动属于内核</h4><p>前面提到,<strong>设备驱动是系统调用的结果</strong>,因此,设备驱动享有内核的一切服务和责任,包括:</p><ul><li>设备驱动时内核的一部分,出错将导致系统的严重错误</li><li>设备驱动必须为内核提供一个标准接口<ul><li>驱动程序初始化函数</li><li>驱动卸载函数,申请设备函数,释放设备函数</li><li><code>I/O</code>操作函数</li><li>中断处理函数</li></ul></li><li>可以使用内核服务,如内存分配,中断发送,等待队列</li><li>动态可加载</li></ul><h3 id="I-O缓冲管理"><a href="#I-O缓冲管理" class="headerlink" title="I/O缓冲管理"></a>I/O缓冲管理</h3><p>缓冲技术可提高外设利用率</p><ul><li>匹配<code>CPU</code>和外设的不同处理速度</li><li>减少对<code>CPU</code>的中断次数</li><li>提高<code>CPU</code>和<code>I/O</code>设备之间的并行性</li></ul><h4 id="单缓冲-Single-Buffer"><a href="#单缓冲-Single-Buffer" class="headerlink" title="单缓冲(Single Buffer)"></a>单缓冲(Single Buffer)</h4><p>每当用户进程发出一个I/O请求时,操作系统便在<strong>主存</strong>之中分配一个缓冲区,因为<code>CPU</code>和<code>I/O</code>之间并行,因此数据处理时间为$Max(C,T)+M$</p><p><img src="images/single_buffer.svg" alt="单缓冲"></p><h4 id="双缓冲-Double-Buffer"><a href="#双缓冲-Double-Buffer" class="headerlink" title="双缓冲(Double Buffer)"></a>双缓冲(Double Buffer)</h4><p>两个缓冲区,<code>CPU</code>和外设都可以连续处理而无需等待对方.要求<code>CPU</code>和外设的速度相近.在双缓冲时,系统处理一块数据的时间可以粗略认为是$Max(C+M,T)$,如果$C \lt T$,可使块设备连续输入,如果$C \gt T$,则可是CPU不必等待设备输入</p><p><img src="images/double_buffer.svg" alt="双缓冲"></p><h4 id="环形缓冲-Circular-Buffer"><a href="#环形缓冲-Circular-Buffer" class="headerlink" title="环形缓冲(Circular Buffer)"></a>环形缓冲(Circular Buffer)</h4><p>针对<code>CPU</code>和外设处理速度差较大,引入环形缓冲,可将多个缓冲组织成循环缓冲形式.<br><strong>组成</strong>:</p><ul><li>多个缓冲区:在循环中有多个大小相同的缓冲区.缓冲区可分为三类:<strong>空缓冲区R</strong>,<strong>满缓冲区G</strong>,计算机进程<strong>正在使用的空缓冲区C</strong>.</li><li>多个指针:作为输入的缓冲区可设置三个指针,指示计算进程下一个可用缓冲区G的<strong>指针Nextg</strong>,指示输入进程下一个可用的空缓冲区R的<strong>指针Nexti</strong>,指示计算进程正在使用的缓冲区C的指针<strong>Current</strong></li></ul><h4 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h4><p>当系统较大的时候,不可能给每一个进程开一个缓冲区,这会消耗大量内存,因此为了提高利用率,引入了缓冲池,池中设置了多个可供若干个进程共享的缓冲区.池内至少有下面三种缓冲区:</p><ul><li>空闲缓冲区,其形成的队列叫做<code>emq</code></li><li>装满输入数据的缓冲区,其形成的队列叫做<code>inq</code></li><li>装满输出数据的缓冲区,其形成的队列叫做<code>outq</code></li></ul><p><img src="images/buffer_pool.svg" alt="缓冲池"></p><h3 id="I-O设备管理"><a href="#I-O设备管理" class="headerlink" title="I/O设备管理"></a>I/O设备管理</h3><p>由于外设资源有限,需解决进程间的外设共享问题,以提高外设资源的利用率,有常见一下两种做法:</p><ul><li>在进程间切换使用外设</li><li>通过一个虚拟设备把外设和应用进程隔开,只由虚拟设备来使用外设.</li></ul><h4 id="DCT-Device-Control-Table-设备控制表"><a href="#DCT-Device-Control-Table-设备控制表" class="headerlink" title="DCT(Device Control Table)设备控制表"></a>DCT(Device Control Table)设备控制表</h4><p>每个设备一张,描述设备特性和状态.</p><ul><li>类型</li><li>标识符</li><li>状态:表示设备使用状态</li><li>指向控制器表的指针:指向该设备所连接的控制器的控制表</li><li>重复执行次数或时间:发生传送错误时应重复执行的次数</li><li>设备队列的队首指针:指向申请本设备而没有满足的进程排成的表</li></ul><h4 id="COCT-Controller-Control-Table-控制器控制表"><a href="#COCT-Controller-Control-Table-控制器控制表" class="headerlink" title="COCT(Controller Control Table)控制器控制表"></a>COCT(Controller Control Table)控制器控制表</h4><p>每个设备控制器一张,描述控制器的配置和状态</p><h4 id="CHCT-Channel-Control-Table-通道控制表"><a href="#CHCT-Channel-Control-Table-通道控制表" class="headerlink" title="CHCT(Channel Control Table)通道控制表"></a>CHCT(Channel Control Table)通道控制表</h4><p>每个通道一张,描述通道工作状态</p><h4 id="SDT-System-Device-Table-系统设备表"><a href="#SDT-System-Device-Table-系统设备表" class="headerlink" title="SDT(System Device Table)系统设备表"></a>SDT(System Device Table)系统设备表</h4><p>反映系统中设备资源的状态,记录所有设备的状态及其设备控制表的入口</p><ul><li>DCT指针:指向相应设备的DCT</li><li>设备使用进程表示:正在使用该设备的进程标识</li><li>DCT信息:为引用方便而保存的DCT信息,如设备标识,设备类型</li></ul><h4 id="设备分配考虑因素"><a href="#设备分配考虑因素" class="headerlink" title="设备分配考虑因素"></a>设备分配考虑因素</h4><ul><li>设备固有属性</li><li>设备分配算法</li><li>设备分配中的安全性:死锁<ul><li>安全分配(同步):进程分配之后进入阻塞,直到I/O完成,但是<code>CPU</code>和<code>I/O</code>串行,效率低</li><li>不安全分配(异步):进程发出请求后,仍然继续运行,可申请其他设备,可能产生死锁,需进行检查,但是效率高.</li></ul></li></ul><h4 id="单-多-通路I-O系统的设备分配"><a href="#单-多-通路I-O系统的设备分配" class="headerlink" title="单(多)通路I/O系统的设备分配"></a>单(多)通路I/O系统的设备分配</h4><p>单(多)通路:一个设备对应一(多)个控制器,一个控制器对应一(多)个通道.</p><ul><li>分配设备<ul><li>根据物理设备名查找SDT,找到DCT,如果忙,则等待,否则计算是否产生死锁,进行分配</li></ul></li><li>分配设备控制器<ul><li>进程得到DCT之后,找到对应的COCT,如果空闲则分配,否则进入等待队列</li></ul></li><li>分配通道<ul><li>进程得到COCT之后,找到对应的CHCT,如果空闲则分配,否则进入等待队列</li></ul></li></ul><h4 id="SPOOLing技术-假脱机技术"><a href="#SPOOLing技术-假脱机技术" class="headerlink" title="SPOOLing技术/假脱机技术"></a>SPOOLing技术/假脱机技术</h4><p><code>SPOOLing(Simultaneous Peripheral Operation On Line)</code>也称为虚拟设备技术,可把独享设备转换成具有共享特征的虚拟设备,提高设备利用率</p><p><strong>引入</strong><br>在多道程序系统中,专门利用移到程序(<code>SPOOLing</code>程序)来完成对设备的I/O操作,无需使用外围I/O处理机</p><ul><li><code>SPOOLing</code>程序和外设进行数据交换:实际I/O:<ul><li>输入:程序预先从外设读入数据并且加以缓冲,在需要的时候输入到应用程序</li><li>输出:程序预先接受应用程序的输出数据加以缓冲,在适当时机输出到外设</li></ul></li><li><code>SPOOLing</code>程序和用户程序进行数据交换:虚拟I/O</li></ul><p><strong>系统组成</strong></p><ul><li><strong>输入井和输出井</strong>:磁盘上开辟的两个大存储空间.输入井用于模拟脱机输入时的磁盘设备,<strong>暂存输入数据</strong>,输出井模拟脱机输出时的磁盘,用于<strong>暂存用户程序和输出数据</strong>.</li><li><strong>输入缓冲区和输出缓冲区</strong>:由于<code>CPU</code>和磁盘速度不匹配而在内存开辟的缓冲区,攒出数据</li><li><strong>输入进程<code>SPi</code>和输出进程<code>SPo</code></strong>:利用两个进程模拟脱机<code>I/O</code>时的外围控制机.SPi将输入数据从输入机通过输入缓冲区输入输入金,需要的时候再从输入井读入内存,输出线程将要求输出的数据从内存读入输出井,空闲时将其传送到输出设备.</li></ul><p><img src="images/SPOOLing.svg" alt="SPOOLing"></p><p><strong>特点</strong></p><ul><li>告诉虚拟I/O操作:缓冲区提速</li><li>实现对独享设备的共享:设备繁忙时,先把数据放入输出井,对于进程来说已经完成了输出.</li></ul><h3 id="I-O性能问题"><a href="#I-O性能问题" class="headerlink" title="I/O性能问题"></a>I/O性能问题</h3>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua语言总结</title>
      <link href="/2022/05/11/Lua%E8%AF%AD%E8%A8%80%E6%80%BB%E7%BB%93/"/>
      <url>/2022/05/11/Lua%E8%AF%AD%E8%A8%80%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h1><blockquote><p>在写这篇博客的时候,我满心都是月亮</p></blockquote><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><code>Lua</code>是一种轻量小巧的<strong>脚本语言</strong>,使用标准C语言编写,支持面向过程和函数式编程,其和C不同,不需要程序员考虑内存的问题,语言自动管理内存.<br>其主要目的是嵌入程序中,为程序提供灵活扩展</p><h2 id="编程方式"><a href="#编程方式" class="headerlink" title="编程方式"></a>编程方式</h2><p><code>Lua</code>语言支持脚本式编程.<br>一般情况下,直接写代码,然后<code>lua xxx.lua</code>运行.<br>但是,可以通过开头添加<code>#!/usr/local/bin/lua</code>的方式,指定解释器位置,使用类似<code>.bat</code>文件的方式运行.</p><p><code>Lua</code>同时也支持交互式编程,具体可见python.</p><h2 id="注释方式"><a href="#注释方式" class="headerlink" title="注释方式"></a>注释方式</h2><p><code>Lua</code>的注释方式很奇特.<br>单行注释:</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token comment">--hello World</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>多行注释:</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token comment">--[[ 如果爱 请干净的爱 把爱情献给爱情 --]]</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为注释是<code>--</code>,因此<code>Lua</code>不支持自增自减运算</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><table><thead><tr><th align="center">数据类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>nil</code></td><td align="center">等同于<code>NULL</code>,但是在<code>Lua</code>中,这是一个数据类型,</td></tr><tr><td align="center"><code>boolean</code></td><td align="center">布尔值,<code>nil</code>和<code>false</code>为假,<code>true</code>和非<code>nil</code>为真,因此,0为<code>true</code></td></tr><tr><td align="center"><code>number</code></td><td align="center">双精度浮点数,和<code>double</code>一样</td></tr><tr><td align="center"><code>string</code></td><td align="center">字符串</td></tr><tr><td align="center"><code>function</code></td><td align="center">由<code>C</code>或<code>Lua</code>编写的函数</td></tr><tr><td align="center"><code>userdata</code></td><td align="center">任意存储在变量中的<code>C</code>数据结构</td></tr><tr><td align="center"><code>thread</code></td><td align="center">线程</td></tr><tr><td align="center"><code>table</code></td><td align="center">是一个”关联数组”</td></tr></tbody></table><p><code>type</code>函数用于返回变量的数据类型,返回值是一个 <strong><code>string</code></strong></p><h3 id="number"><a href="#number" class="headerlink" title="number"></a>number</h3><p>默认是<code>double</code>,但是可以通过修改源码里面<code>luaconf.h</code>的定义</p><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><ul><li>对于一块字符串可用<code>[[]]</code>表示,类似python中<code>&quot;&quot;&quot;&quot;&quot;&quot;</code></li><li>不支持<code>+</code>,使用<code>+</code>会尝试转换成<code>number</code>,而不是字符串拼接,字符串拼接是<code>..</code></li><li><code>#</code>返回字符串长度</li></ul><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p><code>table</code>本质是一个字典(或者关联数组),在不给键值对的时候,默认<code>value</code>是数字索引,特别注意,数字索引从<code>1</code>开始,而不是从<code>0</code>.<br>索引方式多样,比如:</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua">t <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>t<span class="token punctuation">[</span>i<span class="token punctuation">]</span>t<span class="token punctuation">.</span>i<span class="token function">gettable_event</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>方法和用途:<br>|方法|用途|<br>|:–:|:–:|<br>|<code>table.concat (table [, sep [, start [, end]]])</code>|列出从<code>start</code>到<code>end</code>的所有元素,元素之间以<code>sep</code>分割|<br>|<code>table.insert (table, [pos,] value)</code>|插入元素,默认为尾部|<br>|table.remove (table [, pos])|删除指定位置的元素,默认为最后一个|<br>|table.sort()|排序|</p><h3 id="function"><a href="#function" class="headerlink" title="function"></a>function</h3><p>因为<code>function</code>变成了数据类型,因此,可以通过变量存储函数,类似函数指针.<br>同时,因为变成了变量,因此可以直接声明一个函数当成参数传给另一个函数.<br>函数的声明:</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token keyword">function</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">--pass</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>函数支持多返回值</p><h3 id="userdata"><a href="#userdata" class="headerlink" title="userdata"></a>userdata</h3><p>自定义数据,用于表示一种由应用程序或 C/C++ 语言库所创建的类型，可以将任意 C/C++ 的任意数据类型的数据（通常是 struct 和 指针）存储到 Lua 变量中调用。</p><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p>对于变量声明,<code>local</code>表示局部变量,不加修饰就是全局变量,因此可以在函数里面声明一个全局变量.<code>Lua</code>很神奇吧</p><h2 id="循环和条件"><a href="#循环和条件" class="headerlink" title="循环和条件"></a>循环和条件</h2><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token keyword">while</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token keyword">do</span><span class="token comment">--statements</span><span class="token keyword">end</span><span class="token keyword">for</span> var<span class="token operator">=</span>exp1<span class="token punctuation">,</span>exp2<span class="token punctuation">,</span>exp3 <span class="token keyword">do</span> <span class="token comment">--var 从 exp1 变化到 exp2，每次变化以 exp3 为步长递增 var,exp3默认为1,可以不写</span><span class="token comment">--statements  </span><span class="token keyword">end</span>  <span class="token keyword">for</span> i<span class="token punctuation">,</span>v <span class="token keyword">in</span> <span class="token function">pairs</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token keyword">do</span> <span class="token comment">--类似python for i in iterator</span><span class="token comment">--statements</span><span class="token keyword">end</span><span class="token keyword">repeat</span> <span class="token comment">--类似do while</span><span class="token comment">--statements</span><span class="token keyword">until</span><span class="token punctuation">(</span> condition <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Lua</code>的循环支持<code>goto</code>语句,语法为<code>goto lable</code>,<code>lable</code>的定义为<code>::lable::</code></p><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token keyword">then</span><span class="token comment">--statement</span><span class="token keyword">elseif</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token keyword">then</span><span class="token comment">--statement</span><span class="token keyword">else</span><span class="token comment">--statement</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p><code>Lua</code>支持自定义迭代函数,但是,笔者学习<code>Lua</code>只是为了使用这个工具,不打算细究这个语言,因此,在这个模块,我只讨论<code>ipairs()</code>和<code>pairs()</code>的区别</p><h3 id="ipairs"><a href="#ipairs" class="headerlink" title="ipairs()"></a>ipairs()</h3><p><code>ipairs</code>只支持数字索引,而且从1开始,相当于返回<code>t[1],t[2],...,t[n]</code>,所以如果不是数字索引,或者不连续,那么得不到期望的结果.具体原因和其迭代器的实现有关,这里就不深究了.</p><h3 id="pairs"><a href="#pairs" class="headerlink" title="pairs()"></a>pairs()</h3><p><code>pairs</code>遍历所有的<code>key</code>.</p><h2 id="文件I-O"><a href="#文件I-O" class="headerlink" title="文件I/O"></a>文件I/O</h2><p><code>lua</code>的文件<code>I/O</code>有些许复杂,分为简单模式和复杂模式,简单模式之下是通过改变程序标准输入输出来实现的,复杂模式则是通过句柄实现.<br>简单模式虽然是简单模式,但是实际应用还是由诸多不变,在此做简单介绍.</p><h3 id="简单模式"><a href="#简单模式" class="headerlink" title="简单模式"></a>简单模式</h3><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token comment">-- 以只读方式打开文件</span>file <span class="token operator">=</span> io<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"in.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token comment">-- 设置默认输入文件为in.txt</span>io<span class="token punctuation">.</span><span class="token function">input</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token comment">-- 输出文件第一行</span><span class="token function">print</span><span class="token punctuation">(</span>io<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">-- 关闭打开的文件</span>io<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token comment">-- 以附加的方式打开只写文件</span>file <span class="token operator">=</span> io<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"in.txt"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token comment">-- 设置默认输出文件为in.txt</span>io<span class="token punctuation">.</span><span class="token function">output</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token comment">-- 在文件最后一行添加</span>io<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span><span class="token comment">-- 关闭打开的文件</span>io<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于io.read()方法,可以通过提供参数,获得不同的效果<br>|参数|效果|<br>|:-:|:-:|<br>|”*n”|读取一个数字|<br>|”*a”|从当前文字读取整个文件|<br>|”*l”|默认参数,读取下一行|<br>|number|返回一个指定字符的字符串,<code>io.read(114514)</code>,返回114514个字符|</p><h2 id="完全模式"><a href="#完全模式" class="headerlink" title="完全模式"></a>完全模式</h2><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token comment">-- 以只读方式打开文件</span>file <span class="token operator">=</span> io<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"in.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token comment">-- 输出文件第一行</span><span class="token function">print</span><span class="token punctuation">(</span>file<span class="token punctuation">:</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">-- 关闭打开的文件</span>file<span class="token punctuation">:</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">-- 再次打开只写文件</span>file <span class="token operator">=</span> io<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"in.txt"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token comment">-- 在文件最后一行添加文字</span>file<span class="token punctuation">:</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span><span class="token comment">-- 关闭打开的文件</span>file<span class="token punctuation">:</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Splash的使用</title>
      <link href="/2022/05/08/Splash%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/05/08/Splash%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Splash的使用"><a href="#Splash的使用" class="headerlink" title="Splash的使用"></a>Splash的使用</h1><p><code>Splash</code>是一个<code>JS</code>渲染服务,本质是一个轻量级浏览器.建议<code>Splash</code>通过<code>Docker</code>安装.</p><h2 id="Lua脚本"><a href="#Lua脚本" class="headerlink" title="Lua脚本"></a>Lua脚本</h2><p>进入Splash,能看见这样一段代码:</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token keyword">function</span> <span class="token function">main</span><span class="token punctuation">(</span>splash<span class="token punctuation">,</span> args<span class="token punctuation">)</span>  <span class="token function">assert</span><span class="token punctuation">(</span>splash<span class="token punctuation">:</span><span class="token function">go</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span>url<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token function">assert</span><span class="token punctuation">(</span>splash<span class="token punctuation">:</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>    html <span class="token operator">=</span> splash<span class="token punctuation">:</span><span class="token function">html</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    png <span class="token operator">=</span> splash<span class="token punctuation">:</span><span class="token function">png</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    har <span class="token operator">=</span> splash<span class="token punctuation">:</span><span class="token function">har</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大致能看明白这段代码先执行了<code>go</code>方法,然后<code>wait</code>,返回值是<code>html</code>,<code>png</code>,<code>har</code>.<br>因此,通过修改这段代码,能实现更多的功能,具体细节请看笔者的<strong>Lua语言总结</strong></p><h3 id="入口和返回值"><a href="#入口和返回值" class="headerlink" title="入口和返回值"></a>入口和返回值</h3><ul><li><p><strong>入口</strong>:<br>函数的入口固定为<code>main</code>,和<code>c</code>差不多</p></li><li><p><strong>返回值</strong>:<br>返回值可以是字符串,也可以是字典,其形式分别如下:</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token keyword">function</span> <span class="token function">main</span><span class="token punctuation">(</span>splash<span class="token punctuation">,</span> args<span class="token punctuation">)</span>    <span class="token keyword">return</span> `Hello World!` <span class="token operator">//</span>字符串<span class="token keyword">end</span><span class="token keyword">function</span> <span class="token function">main</span><span class="token punctuation">(</span>splash<span class="token punctuation">,</span> args<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>hello<span class="token operator">=</span>`Hello World!`<span class="token punctuation">&#125;</span> <span class="token operator">//</span>字典<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><p><code>splash</code>支持异步处理,在<code>wait</code>的时候会进行其他任务</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token keyword">function</span> <span class="token function">main</span><span class="token punctuation">(</span>splash<span class="token punctuation">,</span> args<span class="token punctuation">)</span>    <span class="token keyword">local</span> urls <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"www.baidu.com"</span><span class="token punctuation">,</span><span class="token string">"www.google.com"</span><span class="token punctuation">,</span><span class="token string">"www.chrome.com"</span><span class="token punctuation">&#125;</span>    <span class="token keyword">local</span> results <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> index<span class="token punctuation">,</span>url <span class="token keyword">in</span> <span class="token function">pairs</span><span class="token punctuation">(</span>urls<span class="token punctuation">)</span>     <span class="token keyword">do</span>      <span class="token keyword">local</span> ok<span class="token punctuation">,</span>reason <span class="token operator">=</span> splash<span class="token punctuation">.</span><span class="token function">go</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>      <span class="token keyword">if</span> ok       <span class="token keyword">then</span>        splash<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>        results<span class="token punctuation">[</span>url<span class="token punctuation">]</span> <span class="token operator">=</span> splash<span class="token punctuation">.</span><span class="token function">png</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token keyword">end</span>    <span class="token keyword">end</span>    <span class="token keyword">return</span> results<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="splash对象的属性"><a href="#splash对象的属性" class="headerlink" title="splash对象的属性"></a>splash对象的属性</h2></li></ul>]]></content>
      
      
      <categories>
          
          <category> 爬虫学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Lua </tag>
            
            <tag> splash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Selenium的使用</title>
      <link href="/2022/05/07/Selenium%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/05/07/Selenium%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Selenium的使用"><a href="#Selenium的使用" class="headerlink" title="Selenium的使用"></a>Selenium的使用</h1><p><code>Selenium</code>是一个自动化测试工具,借助浏览器驱动可以模拟用户对浏览器的操作.因此,爬虫也可以直接使用它爬取渲染好的结果,不需要去分析加密方式.<br><a href="https://selenium-python.readthedocs.io/">官方文档</a></p><h2 id="浏览器对象初始化"><a href="#浏览器对象初始化" class="headerlink" title="浏览器对象初始化"></a>浏览器对象初始化</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriverbrowser <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chorme<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">##初始化一个Chorme浏览器对象</span>browser <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Edge<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">##初始化一个Edge浏览器对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="访问页面"><a href="#访问页面" class="headerlink" title="访问页面"></a>访问页面</h2><p>使用<code>get</code>方法发送一个<code>get</code>请求访问页面</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">browser<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"www.baidu.com"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>browser<span class="token punctuation">.</span>page_source<span class="token punctuation">)</span> <span class="token comment">##获得网页源码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h2><h3 id="单个节点"><a href="#单个节点" class="headerlink" title="单个节点"></a>单个节点</h3><p><code>selenium</code>提供了<code>find_element_by_name</code>和<code>find_element_by_id</code>等方法来寻找,而且还支持XPath(<code>find_element_by_xpath</code>)和CSS选择器(<code>find_element_by_css_selector</code>)等方式寻找<br>另外,<code>selenium</code>还提供了<code>find_element()</code>函数,传递两个值,第一个值是查找方式,第二个是取值.建议使用这个方法</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">find_element_by_id<span class="token punctuation">(</span><span class="token string">'q'</span><span class="token punctuation">)</span><span class="token comment">## equals</span>find_element<span class="token punctuation">(</span>By<span class="token punctuation">.</span>ID<span class="token punctuation">,</span><span class="token string">'q'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="多个节点"><a href="#多个节点" class="headerlink" title="多个节点"></a>多个节点</h3><p>对于多个节点,<code>find_element</code>方法只能返回第一个节点,需要使用<code>find_elements</code>方法,其余同上</p><h2 id="节点交互"><a href="#节点交互" class="headerlink" title="节点交互"></a>节点交互</h2><p><code>selenium</code>还能实现浏览器交互</p><ul><li><code>send_keys()</code>向表格输入文字(需要寻找input标签)</li><li><code>click()</code>点击按钮(需要寻找button标签)</li><li><code>screenshot()</code>保存当前元素为PNG文件,该方法需要传入文件路径</li><li><code>submit()</code>提交表格<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriver<span class="token keyword">from</span> selenium<span class="token punctuation">.</span>webdriver<span class="token punctuation">.</span>common<span class="token punctuation">.</span>by <span class="token keyword">import</span> By<span class="token keyword">import</span> timeurl <span class="token operator">=</span> <span class="token string">"https://www.taobao.com"</span>browser <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span>browser<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token builtin">input</span> <span class="token operator">=</span> browser<span class="token punctuation">.</span>find_element<span class="token punctuation">(</span>By<span class="token punctuation">.</span>ID<span class="token punctuation">,</span><span class="token string">'q'</span><span class="token punctuation">)</span><span class="token builtin">input</span><span class="token punctuation">.</span>send_keys<span class="token punctuation">(</span><span class="token string">"IPhone"</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>button <span class="token operator">=</span> browser<span class="token punctuation">.</span>find_element<span class="token punctuation">(</span>By<span class="token punctuation">.</span>CLASS_NAME<span class="token punctuation">,</span><span class="token string">'btn-search'</span><span class="token punctuation">)</span>button<span class="token punctuation">.</span>click<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="获取节点信息"><a href="#获取节点信息" class="headerlink" title="获取节点信息"></a>获取节点信息</h2><h3 id="获取节点属性"><a href="#获取节点属性" class="headerlink" title="获取节点属性"></a>获取节点属性</h3><p>可以使用<code>get_attribute</code>方法在选中结点之后获得节点属性.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriver<span class="token keyword">from</span> selenium<span class="token punctuation">.</span>webdriver<span class="token punctuation">.</span>common<span class="token punctuation">.</span>by <span class="token keyword">import</span> Byurl <span class="token operator">=</span> <span class="token string">"https://spa2.scrape.center/"</span>browser <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span>browser<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">)</span>logo <span class="token operator">=</span> browser<span class="token punctuation">.</span>find_element<span class="token punctuation">(</span>By<span class="token punctuation">.</span>CLASS_NAME<span class="token punctuation">,</span><span class="token string">'logo-image'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>logo<span class="token punctuation">.</span>get_attribute<span class="token punctuation">(</span><span class="token string">'src'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="获取节点文本信息"><a href="#获取节点文本信息" class="headerlink" title="获取节点文本信息"></a>获取节点文本信息</h3><p>每个webElement节点都有一个text属性,直接调用这个属性即可</p><h3 id="获取ID-位置-标签名和大小"><a href="#获取ID-位置-标签名和大小" class="headerlink" title="获取ID,位置,标签名和大小"></a>获取ID,位置,标签名和大小</h3><p>webElement节点的<code>id</code>,<code>location</code>,<code>tag_nanme</code>,<code>size</code>属性分别存储了对应的信息.</p><h2 id="动作链"><a href="#动作链" class="headerlink" title="动作链"></a>动作链</h2><p>节点交互的方法都依赖于节点,但是一些操作没有节点依赖.比如键盘输入,鼠标移动,这些就需要动作链方法</p><ul><li><code>drag_and_drop(source,target)</code>拖曳节点,把节点<code>source</code>拖到节点<code>target</code>所在的位置</li><li><code> drag_and_drop_by_offset(source, xoffset, yoffset)</code>拖曳<code>source</code>节点,移动<code>offset</code>的距离</li><li><code>move_to_element(target)</code>将鼠标移动到<code>target</code>节点的位置</li><li><code>click()</code>左键点击当前鼠标所在位置的节点</li><li><code>click_and_hold()</code>左键点击鼠标所在位置节点保持不放</li><li><code>context_click()</code>右键点击</li><li><code>double_click()</code>双击</li><li><code>key_down(value)</code>按下键盘每个键不放,<code>key_up(value)</code>放开某个键<br>example: 输入<code>ctrl+c</code><pre class="line-numbers language-python" data-language="python"><code class="language-python">ActionChains<span class="token punctuation">(</span>driver<span class="token punctuation">)</span><span class="token punctuation">.</span>key_down<span class="token punctuation">(</span>Keys<span class="token punctuation">.</span>CONTROL<span class="token punctuation">)</span><span class="token punctuation">.</span>send_keys<span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>key_up<span class="token punctuation">(</span>Keys<span class="token punctuation">.</span>CONTROL<span class="token punctuation">)</span><span class="token punctuation">.</span>perform<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>使用方法:</p><ul><li>使用<code>ActionChains</code>实例化一个对象出来,该构造方法需要提供两个参数,一个<code>driver</code>,一个<code>duration</code>.<code>driver</code>必须提供,<code>duration</code>默认为250.</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriver<span class="token keyword">from</span> selenium<span class="token punctuation">.</span>webdriver <span class="token keyword">import</span> ActionChains<span class="token keyword">from</span> selenium<span class="token punctuation">.</span>webdriver<span class="token punctuation">.</span>common<span class="token punctuation">.</span>by <span class="token keyword">import</span> Byurl <span class="token operator">=</span> <span class="token string">"https://www.runoob.com/try/try.php?filename=jqueryui-api-droppable"</span>browser <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span>browser<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">)</span>browser<span class="token punctuation">.</span>switch_to<span class="token punctuation">.</span>frame<span class="token punctuation">(</span><span class="token string">"iframeResult"</span><span class="token punctuation">)</span>action <span class="token operator">=</span> ActionChains<span class="token punctuation">(</span>browser<span class="token punctuation">,</span>duration<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">)</span>source <span class="token operator">=</span> browser<span class="token punctuation">.</span>find_element<span class="token punctuation">(</span>By<span class="token punctuation">.</span>ID<span class="token punctuation">,</span><span class="token string">"draggable"</span><span class="token punctuation">)</span>target <span class="token operator">=</span> browser<span class="token punctuation">.</span>find_element<span class="token punctuation">(</span>By<span class="token punctuation">.</span>ID<span class="token punctuation">,</span><span class="token string">"droppable"</span><span class="token punctuation">)</span>action<span class="token punctuation">.</span>drag_and_drop<span class="token punctuation">(</span>source<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">.</span>perform<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="运行js"><a href="#运行js" class="headerlink" title="运行js"></a>运行js</h2><p>对于一些行为,<code>selenium</code>没有提供对应方法,比如<code>alert()</code>,比如进度条调整,但是<code>selenium</code>提供了<code>execute_script()</code>方法,在里面可以直接写入js.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriverbrowser <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span>url <span class="token operator">=</span> <span class="token string">"https://www.zhihu.com/explore"</span>browser<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">)</span>browser<span class="token punctuation">.</span>execute_script<span class="token punctuation">(</span><span class="token string">"window.scrollTo(0,document.body.scrollHeight)"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="切换frame"><a href="#切换frame" class="headerlink" title="切换frame"></a>切换frame</h2><p>网页中一种节点叫做<code>iframe</code>,既子<code>Frame</code>,相当于页面的子页面.在主页面无法通过<code>find_element</code>方法找到子页面的节点,需要切换<code>frame</code>才可获取.<br><code>switch_to.frame()</code>切换到指定<code>frame</code>,<code>switch_to.parent_frame()</code>切换到父页面<br>同时,<code>switch_to</code>也支持切换到其他东西,比如<code>switch_to.window()</code>能切换到指定选项卡.</p><h2 id="延时等待"><a href="#延时等待" class="headerlink" title="延时等待"></a>延时等待</h2><p>浏览器并不会一次性渲染完所有的信息,有些<code>Ajax</code>的信息需要额外时间等待.因此在查找节点的时候,必要的等待就很有必要.</p><h3 id="隐式等待"><a href="#隐式等待" class="headerlink" title="隐式等待"></a>隐式等待</h3><p>如果查询节点失败,<code>selenium</code>会等待特定时间,再进行下一次的查询,如果还是失败,则抛出异常,该默认时间就是隐式等待,默认值为0.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriverbrowser <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span>brower<span class="token punctuation">.</span>implicitly_wait<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token comment">##设定隐式等待时间为100ms</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="显式等待"><a href="#显式等待" class="headerlink" title="显式等待"></a>显式等待</h3><p>对于不同的查询设定不同的等待时间就是显式等待</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriver<span class="token keyword">from</span> selenium<span class="token punctuation">.</span>webdriver<span class="token punctuation">.</span>common<span class="token punctuation">.</span>by <span class="token keyword">import</span> By<span class="token keyword">from</span> selenium<span class="token punctuation">.</span>webdriver<span class="token punctuation">.</span>support<span class="token punctuation">.</span>ui <span class="token keyword">import</span> WebDriverWait<span class="token keyword">from</span> selenium<span class="token punctuation">.</span>webdriver<span class="token punctuation">.</span>support <span class="token keyword">import</span> expected_conditions <span class="token keyword">as</span> ECurl <span class="token operator">=</span> <span class="token string">"https://www.taobao.com/"</span>browser <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span>brower<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">)</span>wait <span class="token operator">=</span> WebDriverWait<span class="token punctuation">(</span>brower<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment">##实例化一个WebDriverWait对象,该对象实例化需要指定显示等待时间</span><span class="token builtin">input</span> <span class="token operator">=</span> wait<span class="token punctuation">.</span>until<span class="token punctuation">(</span>EC<span class="token punctuation">.</span>presence_of_element_located<span class="token punctuation">(</span><span class="token punctuation">(</span>By<span class="token punctuation">.</span>ID<span class="token punctuation">,</span><span class="token string">'q'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">## 显式等待时间为该节点出现,如果超过10s没出现则抛出异常</span>click <span class="token operator">=</span> wait<span class="token punctuation">.</span>until<span class="token punctuation">(</span>EC<span class="token punctuation">.</span>element_to_be_clickable<span class="token punctuation">(</span><span class="token punctuation">(</span>By<span class="token punctuation">.</span>CSS_SELECTOR<span class="token punctuation">,</span><span class="token string">'.bin-search'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">## element_to_be_clickable,等待节点可点击</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="前进和后退"><a href="#前进和后退" class="headerlink" title="前进和后退"></a>前进和后退</h2><p><code>forward</code>方法实现前进,<code>back</code>实现后退</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriver<span class="token keyword">from</span> selenium<span class="token punctuation">.</span>webdriver<span class="token punctuation">.</span>common<span class="token punctuation">.</span>by <span class="token keyword">import</span> By<span class="token keyword">from</span> selenium<span class="token punctuation">.</span>webdriver<span class="token punctuation">.</span>support<span class="token punctuation">.</span>ui <span class="token keyword">import</span> WebDriverWait<span class="token keyword">from</span> selenium<span class="token punctuation">.</span>webdriver<span class="token punctuation">.</span>support <span class="token keyword">import</span> expected_conditions <span class="token keyword">as</span> ECurl1 <span class="token operator">=</span> <span class="token string">"https://www.taobao.com/"</span>url2 <span class="token operator">=</span> <span class="token string">""</span>url3 <span class="token operator">=</span> <span class="token string">""</span>browser <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span>browser<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url1<span class="token punctuation">)</span>browser<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url2<span class="token punctuation">)</span>browser<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url3<span class="token punctuation">)</span>browser<span class="token punctuation">.</span>forward<span class="token punctuation">(</span><span class="token punctuation">)</span>browser<span class="token punctuation">.</span>back<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p><code>selenium</code>也有对<code>cookie</code>管理的函数</p><ul><li><code>get_cookies()</code>:获取<code>cookies</code></li><li><code>add_cookies()</code>:增加<code>cookies</code></li><li><code>delete_all_cookies()</code>:删除所有的<code>cookies</code></li></ul><h2 id="选项卡管理"><a href="#选项卡管理" class="headerlink" title="选项卡管理"></a>选项卡管理</h2><p>一个浏览器中会有多个选项卡,一次<code>get</code>方法会增加一个选项卡,<code>selenium</code>支持对选项卡进行操作.</p><ul><li><code>window_handles</code>:<code>browser</code>的属性,存储了该<code>browser</code>所有选项卡</li><li><code>switch_to.window()</code>切换到指定选项卡</li></ul><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p><code>selenium</code>内置了几种异常,下面列举出几种常见的异常,详见<a href="https://selenium-python.readthedocs.io/api.html#module-selenium.common.exceptions">官方文档</a></p><ul><li><strong><code>ElementNotInteractableException</code></strong>:不能互动的节点,有可能是因为节点没有加载完成.</li><li><strong><code>NoSuchElementException</code></strong>:没有找到节点</li><li><strong><code>InvalidSelectorException</code></strong>:选择器出现异常,可能是语法不对,也有可能是该表达式什么都不寻找</li></ul><h2 id="反屏蔽"><a href="#反屏蔽" class="headerlink" title="反屏蔽"></a>反屏蔽</h2><p>很多网站增加对<code>selenium</code>的检测,防止爬虫的爬取,这里介绍一种常用的反屏蔽策略.<br>在大多数情况下,检测的基本原理是检测当前浏览器窗口下的<code>window.navigator</code>对象中是否包含<code>webdriver</code>属性,因此可以使用<code>CDP(Chrome开发工具协议)</code>或者其他对应的浏览器开发工具协议</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriver<span class="token keyword">from</span> selenium<span class="token punctuation">.</span>webdriver <span class="token keyword">import</span> ChromeOptionsoption <span class="token operator">=</span> ChromeOptions<span class="token punctuation">(</span><span class="token punctuation">)</span>option<span class="token punctuation">.</span>add_experimental_option<span class="token punctuation">(</span><span class="token string">'excludeSwitches'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'enable-automation'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>option<span class="token punctuation">.</span>add_experimental_option<span class="token punctuation">(</span><span class="token string">'useAutomationExtension'</span><span class="token punctuation">,</span><span class="token boolean">False</span><span class="token punctuation">)</span>browser <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span>options <span class="token operator">=</span> option<span class="token punctuation">)</span>browser<span class="token punctuation">.</span>execute_cdp_cmd<span class="token punctuation">(</span><span class="token string">'Page.addScriptToEvaluateOnNewDocument'</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span>  <span class="token string">'source'</span><span class="token punctuation">:</span><span class="token string">'Object.defineProperty(navigator,"webdriver",&#123;get:() => undefined&#125;)'</span><span class="token punctuation">&#125;</span>browser<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 爬虫学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OO_Unit2_电梯难题</title>
      <link href="/2022/04/25/OO-Unit2-%E7%94%B5%E6%A2%AF%E9%9A%BE%E9%A2%98/"/>
      <url>/2022/04/25/OO-Unit2-%E7%94%B5%E6%A2%AF%E9%9A%BE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="电梯难题"><a href="#电梯难题" class="headerlink" title="电梯难题"></a>电梯难题</h1><p>这单元作业的主题是<del>电车</del>电梯难题,整体感觉还行,如果不去纠结最优,明白锁这个概念的话,实现难度还是挺低的。<del>（感觉不如第一单元。。。。难度）</del></p><h2 id="同步和锁"><a href="#同步和锁" class="headerlink" title="同步和锁"></a>同步和锁</h2><p>本次作业我没有使用<code>lock</code><del>(因为第一次作业用的<code>synchronized</code>,懒得改了)</del>.对于同步块的选择,我的想法如下</p><h3 id="为何需要同步代码块"><a href="#为何需要同步代码块" class="headerlink" title="为何需要同步代码块"></a>为何需要同步代码块</h3><p>同步块主要用于解决线程冲突问题.怎么判断线程冲突?我的判断方法是判断线程之间<strong>权力是否对等</strong>.</p><p>权力是否对等指的是读写权力是否相等.如果线程之间不是全读,或者全写的话,那么对这个临界数据的操作就<strong>必须是原子性</strong>的,既,其必须处于同步代码块.</p><h3 id="怎么放置同步代码块"><a href="#怎么放置同步代码块" class="headerlink" title="怎么放置同步代码块"></a>怎么放置同步代码块</h3><p>语法层面这个很简单,不赘诉了.<del>(有手就行)</del>重点是如何将其最小化,提高线程的效率.</p><p>我的原则如下:</p><ul><li><strong><code>run</code>方法里面没有锁</strong>:run方法不放置同步代码块,只调用类方法,锁由对应类方法实现,.这样使得run方法简单,也不会出现疏忽导致一个锁锁了不应该的方法.</li><li><strong>锁指出具体的对象,而不是锁方法</strong>:锁方法锁的是<code>this</code>指针,这代表着<code>this</code>被共享出去,但是实际情况下并不是这样,比如<strong>调度器既是生产者也是消费者</strong>,如果锁了<code>this</code>,那么电梯读数据的时候,调度器也不能从输入线程获得数据,这样<strong>输入线程和电梯线程同时被阻塞</strong>.</li><li><strong>变量的声明放出锁外,锁内只有对共享资源的读/写等操作</strong>:这个容易理解,让锁最小.</li></ul><h2 id="架构分享"><a href="#架构分享" class="headerlink" title="架构分享"></a>架构分享</h2><h3 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h3><p>下面是我最后一次迭代出来的架构:<br>这是我的处理请求的模型:<br><img src="images/%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86.png" alt="请求处理">  </p><p>这是我的UML图(红色部分为第二次作业加入内容,蓝色部分为第三次作业加入内容):<br><strong>调度器</strong>:<br><img src="images/%E8%B0%83%E5%BA%A6%E5%99%A8.jpg" alt="调度器"><br>主调度器使用了单例模式<br>第二次作业中因为floor电梯的加入,我重构了整个subDispatch分支,抽象了部分subDispatchBuilding的行为出来.<br>第三次作业加入了TransferTable.<br>TransferTable保存了整个大楼的联通情况,通过Dijstra算法获得最优路径.<br><strong>电梯</strong>:<br><img src="images/%E7%94%B5%E6%A2%AF.jpg" alt="电梯"><br>第二次作业我重构了整个Elevetor的子类,增加了ElevatorBuilding和ElevatorFloor,将部分Elevetor的属性下放.<br>ElevatorFloorA和ElevatorBuildingA本是为了防止特种电梯,比如停奇数楼层等,但是没有这种电梯,但是架构就没有改变,留下了拓展的余地.<br>OutputThread是用于输出信息的,加了一层封装保证线程安全<br>这是我的协作图:<br>主函数/Input Thread:<br><img src="images/Input_Thread.png" alt="Input_Thread"><br>主调度器的协作图:<br><img src="images/Main_Dispatch.png" alt="Main_Dispatch"><br>副调度器:<br><img src="images/SubDispatch.png" alt="SubDispatch"><br>电梯:<br><img src="images/Elevetor.png" alt="Elevetor"><br>Strategy本是为了应付早高峰等特殊场景二出现的,但是因为没有这些要求,所以Strategy整个就是一个空类.</p><h3 id="细节分析"><a href="#细节分析" class="headerlink" title="细节分析"></a>细节分析</h3><h4 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h4><p>我的调度器分为主调度器<code>(Main Dispatch)</code>和副调度器<code>(SubDispatch)</code>.</p><p><strong>主调度器</strong>负责获得输入线程的请求,规划请求的路线,并把请求分配给对应的副调度器</p><p><strong>副调度器</strong>负责获得主调度器分配的请求,并根据请求的<code>from</code>安置在容器的不同位置,方便电梯根据自己的位置寻找请求.</p><p>因此调度器既是生产者也是消费者.</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Dispatch</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">&#123;</span>  <span class="token comment">//...</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">MyPersonRequest</span> get <span class="token operator">=</span> <span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//消费者获得数据</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>isInterrupted<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//用于终止子线程</span>          <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">distributeRequest</span><span class="token punctuation">(</span>get<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 分发数据</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="电梯"><a href="#电梯" class="headerlink" title="电梯"></a>电梯</h4><p>电梯我的策略是类似<code>als</code>的策略,使用的自由竞争的策略.<br><strong>电梯的启动</strong><br>电梯静置状态搜索队列,寻找离自己最远的哪一个请求,然后行驶到对应的位置接受请求.<br><strong>电梯的捎带</strong><br>电梯在行驶到目的地之前会捎带沿途中同方向的请求.捎带请求之后,更新自己的目的地.</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Elevator</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">&#123;</span>  <span class="token comment">//...</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">MyPersonRequest</span> get <span class="token operator">=</span> <span class="token function">getFreeRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>isInterrupted<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token function">running</span><span class="token punctuation">(</span>get<span class="token punctuation">.</span><span class="token function">getTo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">running</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isArrival</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">needOpen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">getIn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">getOff</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//去往下一层</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="请求的规划和换乘"><a href="#请求的规划和换乘" class="headerlink" title="请求的规划和换乘"></a>请求的规划和换乘</h3><h4 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h4><p>本次作业,对于请求的规划我使用的是<code>Dijstra</code>算法求得路径最短和换乘最少的一个最优结果.</p><p><strong>图的初始化</strong>:<br>对于请求换乘只存在环状电梯,所以换乘最少也是只针对环状电梯,因此,对于图我的初始化方法是:</p><ul><li>对于<strong>竖形电梯</strong>,两个结点的距离如下:<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> dist <span class="token operator">=</span> <span class="token function">abs</span><span class="token punctuation">(</span>floor1<span class="token operator">-</span>floor2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>对于<strong>环形电梯</strong>,两个结点的距离如下:<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> dist <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">nonStop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token operator">:</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">114514</span><span class="token punctuation">;</span> <span class="token comment">//如果这两个结点能直达则为1,不能直达则为一个极大值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p>这样如果两个环状电梯结点不能直达,则其路径长度大于等于2,如果能直达则为1,相当于加入了<strong>换乘惩罚</strong>.</p><p>至于Dijstra算法则不再赘述,求得最短路径,获得前导结点,修改请求即可.</p><h4 id="换乘"><a href="#换乘" class="headerlink" title="换乘"></a>换乘</h4><p>在第一次作业中,为了防止电梯没有完成任务就结束,我建立了电梯和主调度器的反馈管道.当任务完成,则主调度器记录完成的任务增加,这样在结束的时候,只需要判断完成的任务是否等于输入的任务.这一个反馈管道在第三次作业中也承担了换乘请求的处理,电梯完成第一阶段任务之后,将请求返回主调度器,主调度器就能继续对其进行分发.</p><h4 id="请求的维护"><a href="#请求的维护" class="headerlink" title="请求的维护"></a>请求的维护</h4><p>如果一个请求为<code>1-FROM-A-5-TO-D-8</code>,经过Dijstra算法之后,其路径为:<br><img src="images/%E8%AF%B7%E6%B1%82%E9%93%BE%E8%A1%A8.png" alt="请求链表">  </p><p>为了防止电梯获得不应该获得的数据,对于请求的读取由两个指针控制,分别为<code>from</code>,<code>to</code>,这样,完成一个任务之后,把<code>from</code>指针对应的结点删除,两个结点移动一个结点,这就变成了一个新的请求.其流程图如下:</p><p><img src="images/%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="请求处理流程图">  </p><h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><p>本单元的自动化测试特别感想<code>@wzm</code>大佬,和我一起<del>结对编程</del>,我负责数据生成部分,他负责正确性判断.</p><p>数据生成思路:<br>主要数据分类为<strong>增加电梯指令</strong>,<strong>高并发数据</strong>,<strong>捎带数据</strong>,<strong>弱数据</strong>.</p><h3 id="竖形电梯数据"><a href="#竖形电梯数据" class="headerlink" title="竖形电梯数据:"></a>竖形电梯数据:</h3><p>  该类数据生成较为简单,只需要选定起始楼层和终止楼层即可.为了数据强度,在决定起始楼层之后,在确定一个gap大小,则<br>  $$[baseFloor-gap,baseFloor) \bigcup (baseFloor,baseFloor+gap]$$则为目的楼层的范围,在这个范围内的值多次取值则为目的楼层.只要取值次数够多,则并发数据强度就够高.同时,对于捎带类数据,选择该范围内的数据为起始楼层,就能建立数据之间的捎带关系.</p><h3 id="环状电梯数据"><a href="#环状电梯数据" class="headerlink" title="环状电梯数据:"></a>环状电梯数据:</h3><p>  数据生成方法和上面类似,只是,环状电梯需要维护一个<code>transferTable</code>表,该表记录了<code>building</code>之间的联通关系,在生成新的电梯之后更新它,之后在生成并发数据和捎带数据,则要在表中记录的楼层周围生成,以测试环状电梯的功能.</p><h2 id="bug分析"><a href="#bug分析" class="headerlink" title="bug分析"></a>bug分析</h2><h3 id="自我bug分析"><a href="#自我bug分析" class="headerlink" title="自我bug分析"></a>自我bug分析</h3><p>我对自己代码的检查方法主要是<strong>单元测试</strong>,在实现一个功能之后,先测试功能的正确性,再继续编写其他部分.比如路径规划部分,在编写完之后,输入请求测试其功能.在整体编写完毕之后,则是使用评测机进行随机测试.</p><p>分享一个很有意思的bug:</p><p>我调度器的<code>run</code>方法会在开始的时候将该调度器管理的电梯全部<code>start</code>.同时,输入线程如果输入增加电梯的请求,那么副调度其会在容器里面增加对应的电梯,并<code>start</code>该电梯.这个时候问题就出现了,如果一个新增的电梯的请求在调度器<code>start</code>电梯之前出现,那么这个电梯就会被<code>start</code>两次.其原因就是增加电梯这件事情不是由副调度器完成,而是主调度器直接访问对应副调度器的容器然后增加,并且<code>start</code>,也就是说<strong>一个线程是两个线程的子线程</strong>,这是不安全的.</p><p>最后的解决方法则是将容器分裂为两个,一个面向副调度器,一个面向主调度器.这样一个解决方法并不优雅,<del>但能用就行</del>.</p><h3 id="他人bug分析"><a href="#他人bug分析" class="headerlink" title="他人bug分析"></a>他人bug分析</h3><p>对于他人的bug的发现方法主要是评测机跑数据.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次作业感觉在处理上面没有第一单元困难,只需要写好每一个电梯的功能即可,因此只要明白锁和一些设计模式(流水线模式等),即可完成本单元作业,哪怕使用自由竞争也依然有很高的性能分.<br>线程安全上,只要按照前面的原则判断是否需要同步代码块,怎样安排同步代码块,至少先线程通信的时候,临界区的线程安全是没有问题的.<br>架构设计上,主要就是生产者消费者模型和流水线模型,分清楚每一个类在和不同线程之间中承担什么工作,做好抽象,难度尚可.<br>至于细节上面,使用Dijstra这些成熟的算法,而不是自己造轮子.<br>希望下一单元越来越好.</p>]]></content>
      
      
      <categories>
          
          <category> 面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>页面置换算法实现</title>
      <link href="/2022/04/15/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/04/15/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>python实现的页面置换算法:<code>OPT</code>,<code>FIFO</code>,<code>LRU</code><br>最后输出三个算法分别的缺页数量随页框数n的变化曲线</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> pltrequest<span class="token punctuation">:</span><span class="token builtin">list</span><span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">OPTInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    ret<span class="token punctuation">:</span><span class="token builtin">dict</span><span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        ret<span class="token punctuation">.</span>get<span class="token punctuation">(</span>request<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token keyword">return</span> ret<span class="token keyword">def</span> <span class="token function">FindUsedless</span><span class="token punctuation">(</span>Schedule<span class="token punctuation">:</span><span class="token builtin">dict</span><span class="token punctuation">,</span>PTable<span class="token punctuation">:</span><span class="token builtin">list</span><span class="token punctuation">,</span>current<span class="token punctuation">:</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    ret <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> each <span class="token keyword">in</span> PTable<span class="token punctuation">:</span>        flag <span class="token operator">=</span> <span class="token number">0</span>        getApperance <span class="token operator">=</span> Schedule<span class="token punctuation">.</span>get<span class="token punctuation">(</span>each<span class="token punctuation">)</span>        <span class="token comment"># 查询list中下一次出现的时候</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> getApperance <span class="token punctuation">:</span>            <span class="token keyword">if</span> current <span class="token operator">&lt;</span> i<span class="token punctuation">:</span>                ret<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token operator">-</span>current<span class="token punctuation">)</span>                flag <span class="token operator">=</span> <span class="token number">1</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> flag <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">:</span> <span class="token comment"># 没有查询到下一次的出现</span>            ret<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">114514</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> ret<span class="token keyword">def</span> <span class="token function">MarkTheUnused</span><span class="token punctuation">(</span>usedTime<span class="token punctuation">:</span><span class="token builtin">list</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    maxtime <span class="token operator">=</span> <span class="token number">0</span>    tag <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>usedTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> usedTime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> maxtime<span class="token punctuation">:</span>            maxtime <span class="token operator">=</span> usedTime<span class="token punctuation">[</span>j<span class="token punctuation">]</span>            tag <span class="token operator">=</span> j    <span class="token keyword">return</span> tag<span class="token keyword">def</span> <span class="token function">OPT</span><span class="token punctuation">(</span>n<span class="token punctuation">:</span><span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    PTable<span class="token punctuation">:</span><span class="token builtin">list</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    Schedule <span class="token operator">=</span> OPTInit<span class="token punctuation">(</span><span class="token punctuation">)</span>    ret <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment">## 没满就无脑装入</span>        <span class="token keyword">if</span> request<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">not</span> <span class="token keyword">in</span> PTable<span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>PTable<span class="token punctuation">)</span> <span class="token operator">>=</span> n<span class="token punctuation">:</span>                usedTime<span class="token punctuation">:</span><span class="token builtin">list</span> <span class="token operator">=</span> FindUsedless<span class="token punctuation">(</span>Schedule<span class="token punctuation">,</span>PTable<span class="token punctuation">,</span>i<span class="token punctuation">)</span> <span class="token comment">## 寻找下一次的使用时间</span>                tag <span class="token operator">=</span> MarkTheUnused<span class="token punctuation">(</span>usedTime<span class="token punctuation">)</span> <span class="token comment">## 找到使用间隔最长的页表</span>                PTable<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>PTable<span class="token punctuation">[</span>tag<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">## 删除对应页表</span>            PTable<span class="token punctuation">.</span>append<span class="token punctuation">(</span>request<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            ret<span class="token operator">+=</span><span class="token number">1</span> <span class="token comment">## 缺页异常</span>    <span class="token keyword">return</span> ret<span class="token keyword">def</span> <span class="token function">FIFO</span><span class="token punctuation">(</span>n<span class="token punctuation">:</span><span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    PTable<span class="token punctuation">:</span><span class="token builtin">list</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment">## 没满就无脑装入</span>        <span class="token keyword">if</span> request<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">not</span> <span class="token keyword">in</span> PTable<span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>PTable<span class="token punctuation">)</span> <span class="token operator">>=</span> n<span class="token punctuation">:</span>                PTable<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>PTable<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">## 把第一个进来的删掉</span>            PTable<span class="token punctuation">.</span>append<span class="token punctuation">(</span>request<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            ret<span class="token operator">+=</span><span class="token number">1</span> <span class="token comment">## 缺页异常</span>    <span class="token keyword">return</span> ret<span class="token keyword">def</span> <span class="token function">MarkTheLessUsed</span><span class="token punctuation">(</span>usedTime<span class="token punctuation">:</span><span class="token builtin">list</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    mintime <span class="token operator">=</span> <span class="token number">114514</span>    tag <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>usedTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> usedTime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> mintime<span class="token punctuation">:</span>            mintime <span class="token operator">=</span> usedTime<span class="token punctuation">[</span>j<span class="token punctuation">]</span>            tag <span class="token operator">=</span> j    <span class="token keyword">return</span> tag<span class="token keyword">def</span> <span class="token function">LRU</span><span class="token punctuation">(</span>n<span class="token punctuation">:</span><span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    PTable<span class="token punctuation">:</span><span class="token builtin">list</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    UsedTimes<span class="token punctuation">:</span><span class="token builtin">list</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment">## 没满就无脑装入</span>        <span class="token keyword">if</span> request<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">not</span> <span class="token keyword">in</span> PTable<span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>PTable<span class="token punctuation">)</span> <span class="token operator">>=</span> n<span class="token punctuation">:</span>                tag <span class="token operator">=</span> MarkTheLessUsed<span class="token punctuation">(</span>UsedTimes<span class="token punctuation">)</span>                PTable<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>PTable<span class="token punctuation">[</span>tag<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">## 把使用最少的哪一个删掉</span>                UsedTimes<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>UsedTimes<span class="token punctuation">[</span>tag<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">## 对应记录使用次数的元素删掉</span>            PTable<span class="token punctuation">.</span>append<span class="token punctuation">(</span>request<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            UsedTimes<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>            ret<span class="token operator">+=</span><span class="token number">1</span> <span class="token comment">## 缺页异常</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            UsedTimes<span class="token punctuation">[</span>PTable<span class="token punctuation">.</span>index<span class="token punctuation">(</span>request<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token keyword">return</span> retDefaultInOPT <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>DefaultInLRU <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>DefaultInFIFO <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    DefaultInOPT<span class="token punctuation">.</span>append<span class="token punctuation">(</span>OPT<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>    DefaultInLRU<span class="token punctuation">.</span>append<span class="token punctuation">(</span>LRU<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>    DefaultInFIFO<span class="token punctuation">.</span>append<span class="token punctuation">(</span>FIFO<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>stick <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">]</span>fig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token punctuation">)</span>axe <span class="token operator">=</span> fig<span class="token punctuation">.</span>add_axes<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0.1</span><span class="token punctuation">,</span><span class="token number">0.1</span><span class="token punctuation">,</span><span class="token number">0.8</span><span class="token punctuation">,</span><span class="token number">0.8</span><span class="token punctuation">]</span><span class="token punctuation">)</span>axe<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>stick<span class="token punctuation">,</span>DefaultInOPT<span class="token punctuation">,</span>label<span class="token operator">=</span><span class="token string">'OPT'</span><span class="token punctuation">)</span>axe<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>stick<span class="token punctuation">,</span>DefaultInLRU<span class="token punctuation">,</span>label<span class="token operator">=</span><span class="token string">'LRU'</span><span class="token punctuation">)</span>axe<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>stick<span class="token punctuation">,</span>DefaultInFIFO<span class="token punctuation">,</span>label<span class="token operator">=</span><span class="token string">'FIFO'</span><span class="token punctuation">)</span>axe<span class="token punctuation">.</span>legend<span class="token punctuation">(</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-进程管理</title>
      <link href="/2022/04/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>/2022/04/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><h3 id="并发-Concurrent"><a href="#并发-Concurrent" class="headerlink" title="并发(Concurrent)"></a>并发(Concurrent)</h3><p>设两个活动<code>a</code>和<code>b</code>,在某一个指定时间t后,只要<code>a</code>和<code>b</code>都处在起点和终点之间的某一处,那就称之为<strong>并发</strong>.</p><h3 id="并行-Parallel"><a href="#并行-Parallel" class="headerlink" title="并行(Parallel)"></a>并行(Parallel)</h3><p>设两个程序,如果在同一个时间度量下同时运行在不同的处理机上,则陈这两个程序是<strong>并行</strong>的.</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>并行一定并发,并发不一定并行.</p><h3 id="并发执行的特征"><a href="#并发执行的特征" class="headerlink" title="并发执行的特征"></a>并发执行的特征</h3><ul><li>间断性: 并发程序具有”执行—暂停—执行”间断性的活动规律.</li><li>非封闭性: 多个程序会共享系统中的资源,该资源状态会被多个程序改变,程序之间会互相影响.</li><li>不可再现性: 在输入相同的情况下,输出还和执行次序有关.<h2 id="Bernstein条件"><a href="#Bernstein条件" class="headerlink" title="Bernstein条件"></a>Bernstein条件</h2>该条件是判断程序并发执⾏行结果是否可再现的充分条件。<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3></li><li>$R(S_i)$: $S_i$的读子集,表示在$S_i$中被引用的变量的集合.</li><li>$W(S_i)$: $S_i$的写子集,表示在$S_i$中被修改的变量的集合.</li></ul><p>两个进程可并发,当且仅当下列条件同时成立的时候:<br>$$\begin{aligned}<br>    R(S_1) \cap W(S_1) = \emptyset \\<br>    W(S_1) \cap R(S_1) = \emptyset<br>\end{aligned}$$<br>也可以理解为两个进程对于同一个共享变量的权力对等的时候才是可并发的,既二者都是读或者二者都是写.</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>进程是程序在一个数据集合上运行的<strong>过程</strong>，它是系统进行资源分配和调度的一个<strong>独立单位</strong>。</p><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul><li><strong>动态性</strong>：进程是程序的一次执行过程。因创建而诞生，因调度而执行，因无资源而暂停，因撤销而消亡。</li><li><strong>并发性</strong>：多个进程实体同时存在于内存中，能在一段时间内同时运行。</li><li><strong>独立性</strong>：在传统<code>os</code>中，进程是独立运行的基本单位。</li><li><strong>异步性</strong>：进程之间相互制约，进程自己以各自独立的不可预知的速度向前推进。</li><li><strong>结构特征</strong>：程序段，数据段，进程控制块<code>PCB</code>。</li></ul><p>进程应该包括：</p><ul><li>程序代码</li><li>程序数据</li><li>PC值</li><li>一组通用寄存器的<strong>值</strong>（不是寄存器本身），堆，栈</li><li>一组系统资源（比如打开的文件）</li></ul><h2 id="进程的状态与控制"><a href="#进程的状态与控制" class="headerlink" title="进程的状态与控制"></a>进程的状态与控制</h2><h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>进程有三种基本状态：就绪状态，执行状态，阻塞状态。</p><ul><li>就绪状态：进程已经获得了除处理器资源外的所有资源，等待调度。</li><li>执行状态：占用处理器资源，处于此状态的进程数目小于等于处理器数量. 在没有其他进程可以执行时, 通常会自动执行系统的idle进程(相当于空操作)。</li><li>阻塞状态：正在执行的进程，因为某种原因无法继续执行，放弃处理器资源。<h3 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h3>进程控制块在进程控制中的作用：</li><li>随着进程创建而创建，随着进程撤销而撤销</li><li>是进程的唯一标志</li><li>限制系统进程数目（有些操作系统PCID只有6bit，最多容纳64个进程）</li></ul><p>进程控制块是进程管理与控制中最重要的数据结构，每一个进程均有一个PCB。其包含以下内容：</p><ul><li><strong>进程标识符</strong>：每一个进程都必须有一个唯一的标识符, 可以是字符串, 也可以是数字. 在进程创建时被系统赋予。</li><li><strong>程序与数据地址</strong>：把PCB与其对应的程序与数据联系起来。</li><li><strong>进程状态</strong>：表示进程状态，为了方便管理，<code>os</code>将相同状态的进程统一管理。</li><li><strong>现场保留区</strong>：当进程放弃处理器的时候，应把处理器中的各种状态信息保存起来，待重新获得处理器之后恢复现场。</li><li><strong>同步互斥机制相关的域</strong>：用于实现进程间互斥，同步所需的信号量。</li><li><strong>进程通信机制相关的域</strong>：用于实现进程间通信所需的字段</li><li><strong>资源清单</strong>：列出所拥有的除处理器外的资源记录，如拥有的I/O设备，打开的文件列表。</li><li><strong>家族关系</strong>：关于父进程，子进程的信息。</li><li><strong>链接字</strong>：根据进程所处的现行状态，进程相应的PCB加入到不同的队列中，PCB链接字指出该进程所在队列中下一个PCB的首地址。（链表指向下一个结点的指针。）</li></ul><h3 id="PCB的组织方式"><a href="#PCB的组织方式" class="headerlink" title="PCB的组织方式"></a>PCB的组织方式</h3><p><strong>线性表</strong><br>不论进程的状态如何，将所有的PCB连续地存放在内存的系统区。这种方式适用于系统中进程数目不多的情况。</p><p><strong>链接方式</strong><br>系统按照进程的状态将进程的PCB组成队列，从而形成就绪队列、阻塞队列、运行队列等。</p><p><strong>索引方式</strong><br>该方式是线性表方式的改进，系统按照进程的状态分别建立就绪索引表、阻塞索引表等。</p><h3 id="中断处理触发的进程切换流程"><a href="#中断处理触发的进程切换流程" class="headerlink" title="中断处理触发的进程切换流程"></a>中断处理触发的进程切换流程</h3><ul><li>栈储存进程的PC</li><li>硬件从中断向量中载入新进程的PC</li><li>汇编程序保存寄存器的值</li><li>汇编程序建立新的栈</li><li>C语言中断服务运行</li><li>调度器决定下一个进程</li><li>C语言程序返回到汇编代码</li><li>汇编程序开启下一个新进程</li></ul><h3 id="进程上下⽂文切换-vs-陷⼊入内核"><a href="#进程上下⽂文切换-vs-陷⼊入内核" class="headerlink" title="进程上下⽂文切换 vs 陷⼊入内核"></a>进程上下⽂文切换 vs 陷⼊入内核</h3><p>进程从用户态到内核态的切换和进程之间的切换不同，mode switch还是在本进程之内，所以上下文切换的时候主要是寄存器上下文切换，栈的切换（防止恶意程序读共享栈中的内核数据导致信息泄露）。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程的引入"><a href="#线程的引入" class="headerlink" title="线程的引入"></a>线程的引入</h3><p>进程的不足：</p><ul><li>一个进程只能在一个时间干一件事</li><li>多个进程直接切换开销很大</li><li>多个进程共享数据和通讯开销很大</li></ul><p>因此引入了线程，线程可以看成轻量级的进程（但是线程和进程是两码事），线程之间的共享数据，并发执行，上下文切换更轻松。</p><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><p>进程是系统进行资源分配和调度的一个<strong>独立单位</strong>，它同时包含两个概念：资源拥有者和可执行单元。<br>操作系统将资源拥有者称为<strong>进程</strong>（<code>process</code>，<code>task</code>），可执行单元称为<strong>线程</strong>（<code>Thread</code>）。</p><ul><li>一个进程可以有多个线程，但是一个线程只能同时被一个进程拥有。</li><li>进程是资源分配的基本单位，线程是处理机调度的基本单位，所有线程共享其所属进程的所有资源和代码。</li><li>线程执行过程中很容易协作同步，而进程需要通过消息通信进行同步。</li><li>线程的划分制度更小，并发性更高。</li><li>线程既共享进程的数据，也有自己的堆栈。</li><li>线程不能单独执行，但是每一个线程都有程序的入口、执行序列以及程序出口。它必须组成进程才能被执行。</li></ul><h3 id="线程实现"><a href="#线程实现" class="headerlink" title="线程实现"></a>线程实现</h3><h4 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h4><p>线程在用户空间, 通过<code>library</code>模拟的<code>thread</code>,不需要或仅需要极少的<code>kernel</code>支持。<br>其上下文切换比较快，不需要更改页表。</p><p><strong>主要功能</strong></p><ul><li>创建和销毁线程</li><li>线程之间传递信息和数据</li><li>调度线程执行</li><li>保存和恢复线程上下文</li></ul><blockquote><p>用户级线程库: POSIX Pthreads, Mach C-threads, Java Threads.<br>POSIX Pthreads:</p><ul><li>用于线程创建和同步的 POSIX 标准 API(IEEE 1003.1c).</li><li>可在用户级或内核级实现.</li><li>API 规定了线程库的行文, 但不限定实现方法.</li><li>类 Unix 操作系统中很常见: Solaris, Linux, MacOS X.</li></ul></blockquote><p><strong>优缺点</strong><br>优点:</p><ul><li>线程切换与内核无关</li><li>线程的调度由应用决定,容易进行优化</li><li>可移植性强,只要线程库支持即可</li></ul><p>缺点</p><ul><li>很多系统调用会引起阻塞,内核因此会阻塞所有相关线程</li><li>内核<strong>只能将处理器分配给进程</strong>(进程是资源分配的基本单位)，即使有多个处理器，也无法实现一个进程中的多个线程的并行执行。</li></ul><h4 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h4><p>线程在内核空间. 内核有多个分身, 每一个分身都可以用来处理一个任务. 这用来处理非同步事件很有效, 内核可以对每一个非同步事件产生一个分身来进行处理.</p><blockquote><p>支持内核线程的操作系统内核称作<strong>多线程内核</strong></p></blockquote><p><strong>优缺点</strong><br>优点:</p><ul><li>内核可以在多个处理器上调度一个进程的多个线程实现同步并行执行</li><li>阻塞只发生在线程级别</li><li>内核中的一些处理可以通过多线程实现</li></ul><p>缺点:</p><ul><li>一个进程中的线程切换需要内核参与,线程的切换涉及到两个模式的切换(进程-进程、线程-线程)</li><li>效率低下</li></ul><h4 id="线程比较"><a href="#线程比较" class="headerlink" title="线程比较"></a>线程比较</h4><ul><li>内核支持线程是OS内核可感知的，而用户级线程是OS内核不可感知的</li><li>用户级线程的创建，撤销和调度不需要OS内核的支持；内核支持线程的创建，撤销和调度则需要OS内核支持</li><li>用户级线程执行系统调用的时候将中断当前进程，而内核支持线程系统调用的时候只中断线程。</li><li>在只有用户级线程的系统内，CPU调度还是以进程为单位，处于运行状态的进程中的多个线程，由用户程序控制线程的轮换运行</li><li>在有内核支持线程的系统内，CPU调度则以线程为单位，由OS的线程调度程序负责线程的调度。</li></ul><h4 id="混合实现"><a href="#混合实现" class="headerlink" title="混合实现"></a>混合实现</h4><p>系统实现内核级线程<br>用户实现用户级线程<br>可以认为用户的进程是建立在内核线程上的</p><h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><p>有些系统同时支持用户线程和内核线程由此产生了不同的多线程模型，即实现用户级线程和内核级线程的连接方式。</p><h4 id="Many-to-One-模型"><a href="#Many-to-One-模型" class="headerlink" title="Many-to-One 模型"></a>Many-to-One 模型</h4><p>将多个用户级线程映射到一个内核级线程，线程管理在用户空间完成</p><p>该模型和纯的用户线程类似，线程的操作不需要经过内核，效率高，但是系统调用将中断整个进程</p><h4 id="One-to-One-模型"><a href="#One-to-One-模型" class="headerlink" title="One-to-One 模型"></a>One-to-One 模型</h4><p>每个用户级线程映射到一个内核级线程</p><p>该模型和纯的内核线程类似，系统调用效率高，线程之间可并发，但是线程的创建开销很大</p><h4 id="Many-to-Many-模型"><a href="#Many-to-Many-模型" class="headerlink" title="Many-to-Many 模型"></a>Many-to-Many 模型</h4><p>将<code>n</code>个用户级线程映射到<code>m</code>个内核级线程上，要求<code>m &lt;= n</code>。</p><p>在多对一模型和一对一模型中取了个折中，克服了多对一模型的并发度不高的缺点，又克服了一对一模型的一个用户进程占用太多内核级线程，开销太大的缺点。又拥有多对一模型和一对一模型各自的优点，可谓集两者之所长。</p><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>进程调度就是CPU选择合适的就绪态进程(Runnable|Ready)获得CPU计算资源。</p><p>cpu调度再CPU资源稀缺，任务量繁重的时候很重要。合理的调度机制能保证每个进程都能再合适的时间处理完成。比如用户交互的进程对于延迟要求很高，如果调度的时候该进程很久能获得一次CPU资源，那么用户的使用体验及其糟糕。</p><p>其要解决的问题如下：</p><ul><li>合适分配CPU</li><li>如何分配CPU（进程的上下文切换）</li><li>按照什么原则选择下面一个要执行的进程</li></ul><h3 id="调度类型-CPU的三级调度"><a href="#调度类型-CPU的三级调度" class="headerlink" title="调度类型|CPU的三级调度"></a>调度类型|CPU的三级调度</h3><ul><li><strong>高级调度</strong>：又称“宏观调度”，作业调度。从<strong>用户工作流程</strong>的角度，一次提交若干个作业，对每个作业进行调度。</li><li><strong>中级调度</strong>：又称“内外存交换”，从*<em>存储器资源</em>的角度，将进程的部分或全部换出到外存上，将当前所需部分换入内存。指令和数据必须再内存里才能被CPU访问。</li><li><strong>低级调度</strong>：又称“微观调度”，“进程或线程调度”，从<strong>CPU资源</strong>的角度的调度，调度频繁，要求高效率。<br><img src="%E4%B8%89%E7%BA%A7%E8%B0%83%E5%BA%A6.png" alt="三级调度"></li></ul><h3 id="进程的特性和分类"><a href="#进程的特性和分类" class="headerlink" title="进程的特性和分类"></a>进程的特性和分类</h3><ul><li><strong><code>I/O Bound</code></strong>(I/O密集型)</li></ul><p>频繁进行<code>I/O</code>,花费大量时间在等待I/O<br>计算花费时间短,计算少</p><ul><li><strong><code>CPU Bound</code></strong>(CPU密集型)</li></ul><p>计算量大</p><h3 id="进程-线程-调度的分类"><a href="#进程-线程-调度的分类" class="headerlink" title="进程(线程)调度的分类"></a>进程(线程)调度的分类</h3><h4 id="根据是否在时钟中断作出调度决策"><a href="#根据是否在时钟中断作出调度决策" class="headerlink" title="根据是否在时钟中断作出调度决策"></a>根据是否在时钟中断作出调度决策</h4><ul><li>非抢占式: 该方法等待进程主动放弃CPU才做出调度决策,时钟中断不会做调度决策.</li><li>抢占式:给每个进程一个固定的最大时间段,如果到了最大时间段进程还在运行,则强行挂起进程,执行调度策略,在时钟中断的时候做调度决策.</li></ul><h4 id="根据不同的应用领域"><a href="#根据不同的应用领域" class="headerlink" title="根据不同的应用领域"></a>根据不同的应用领域</h4><ul><li>批处理系统:减少切换改善性能,尽力让每个作业完成工作,使用<strong>非抢占式算法或分配长时间周期的抢占算法</strong>.</li><li>交互式系统:该系统服务于多个用户,要避免一个用户霸占CPU,使用<strong>抢占式算法</strong></li><li>实时系统:该系统及时性要求很高,满足确定性的截止时间需求,抢占式为主,非抢占式也有应用. </li></ul><h3 id="调度算法的目标"><a href="#调度算法的目标" class="headerlink" title="调度算法的目标"></a>调度算法的目标</h3><p><strong>普适性目标</strong></p><ul><li>公平:给每个进程公平的CPU份额,相似的进程获得相似的份额,不同类型的进程可以有区别(每个进程都需要完成,但是完成途径不同,比如及时性要求高的进程优先级高,但每次给的块小,及时性要求低的进程,每次给的块大,但优先级低)</li><li>严格:<del>强制力</del> 保证策略严格执行</li><li>平衡: 尽量让系统每个部件忙碌,组合CPU密集型和I/O密集型进程</li><li>简单:易于实现</li><li>轻量:执行开销小</li></ul><p><strong>不同系统的特异性目标</strong></p><h4 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h4><ul><li>提升吞吐量(每小时完成的作业数)</li><li>减少周转时间(一批作业从提交到完成所经历的统计平均时间)</li><li>CPU利用率:接近100说明硬件不够用了</li></ul><p>对批处理系统的度量指标:</p><ul><li>吞吐量:作业数/总执行时间</li><li>周转时间:完成时间-提交时间</li><li>带权周转时间:周转时间/服务时间(执行时间) 反映作业等待执行的情况</li><li>平均周转时间:一组作业周转时间之和/作业数</li><li>平均带权周转时间:一组作业带权周转时间之和/作业数</li></ul><h4 id="交互式系统"><a href="#交互式系统" class="headerlink" title="交互式系统"></a>交互式系统</h4><ul><li>最小化响应时间:用户输入一个请求到系统首次相应</li><li>等比例变化:任务花费时间随着其复杂度应该线性增长</li><li>满足截止时间:满足所有或者大多数应用 的截止时间,保证及时性</li><li>可预测性:保证可预测性和规律性</li></ul><h3 id="批处理系统的调度算法"><a href="#批处理系统的调度算法" class="headerlink" title="批处理系统的调度算法"></a>批处理系统的调度算法</h3><h4 id="FCFS-First-Come-First-Serveice-算法"><a href="#FCFS-First-Come-First-Serveice-算法" class="headerlink" title="FCFS(First Come First Serveice)算法"></a>FCFS(First Come First Serveice)算法</h4><p>按照作业进入就绪状态的次序分派CPU,占有CPU之后知道执行完成或者阻塞主动放弃CPU才调度下一个作业.</p><p><strong>特点</strong></p><ul><li>公平,容易理解和实现</li><li>有利于长作业</li><li>有利于CPU密集型作业,不利于I/O密集型作业</li></ul><h4 id="SJF-Shortest-Job-First-算法"><a href="#SJF-Shortest-Job-First-算法" class="headerlink" title="SJF(Shortest Job First)算法"></a>SJF(Shortest Job First)算法</h4><p>又称SPN(Shortest Proess Next)算法.对预期执行作业段的作业优先分配处理机,后面来的短作业不抢占正在执行的作业</p><p><strong>优点</strong></p><ul><li>对FCFS的改进,提升了吞吐量</li><li>改善了平均周转时间和平均带权周转时间</li></ul><p><strong>缺点</strong></p><ul><li>对长作业不利</li><li>难以准确估计作业执行时间时</li><li>如果正在执行进程很慢,后面的短作业无法执行(因为是非抢占调度)</li></ul><h4 id="SRTN-Shortest-Remaining-Time-Next"><a href="#SRTN-Shortest-Remaining-Time-Next" class="headerlink" title="SRTN(Shortest Remaining Time Next)"></a>SRTN(Shortest Remaining Time Next)</h4><p>对<code>SJF</code>的改进,变成了抢占式调度.当一个新就绪的进程到达时,如果它比当前运行进程具有更短的完成时间,系统抢占当前进程,选择新的进程执行.<br><strong>缺点</strong>:</p><ul><li>长时间的进程可能被源源不断的短进程打断,进入进程饥饿.</li></ul><h4 id="HRRN-Hightest-Response-Ratio-Next-最高响应比优先算法"><a href="#HRRN-Hightest-Response-Ratio-Next-最高响应比优先算法" class="headerlink" title="HRRN(Hightest Response Ratio Next)最高响应比优先算法"></a>HRRN(Hightest Response Ratio Next)最高响应比优先算法</h4><p>是FCFS和SJF算法的折中.既考虑作业的运行时间,又考虑作业的等待时间,照顾短作业又避免饿死长作业.<br>每次进行调度的时候,先计算后备作业队列每个作业的的<strong>响应优先级</strong>,优先级最大的作业运行.<br>Response Priority = 1 + 已等待时间/要求运行时间<br><strong>算法效果</strong>:<br>多作业容易等到很高的响应比,长作业等待时间足够长之后,也能获得足够高的响应比.<br><strong>缺点</strong>:<br>每次计算响应比又一定时间开销,性能略差</p><h3 id="交互式系统的调度算法"><a href="#交互式系统的调度算法" class="headerlink" title="交互式系统的调度算法"></a>交互式系统的调度算法</h3><h4 id="RR-Round-Robin-时间片轮转算法"><a href="#RR-Round-Robin-时间片轮转算法" class="headerlink" title="RR(Round Robin)时间片轮转算法"></a>RR(Round Robin)时间片轮转算法</h4><p>通过时间片轮转,提高进程并发性和响应时间特性,进而提高资源利用率.<br>各个就绪进程按照FCFS原则,排成一个队列,每次调度时将CPU分配给队首进程,时间片结束或者进程放弃CPU,则进行CPU切换,该队列进入就绪态队列末尾,或者进入阻塞态.</p><h4 id="PS-Priority-Scheduling-优先级调度"><a href="#PS-Priority-Scheduling-优先级调度" class="headerlink" title="PS( Priority Scheduling)优先级调度"></a>PS( Priority Scheduling)优先级调度</h4><p>该算法是对RR的改进.优先级调度赋予每个进程不同优先级,高优先级先运行,可以静态或者动态赋予进程优先级.<br><strong>静态优先级</strong><br>进程创建时指定,运行过程中不再改变.该优先级根据进程类型,资源需求,用户要求等创建.</p><p><strong>动态优先级</strong><br>在进程运行过程中可以动态改变优先级,以便获得更好的调度性能.</p><ul><li>在队列中,等待时间越长则优先级提高,防止进程饥饿</li><li>进程每执行一个时间片就降低优先级,防止进程霸占CPU</li><li>I/O密集型进程优先级较高</li></ul><h4 id="MQ-Multi-Queue-多级队列算法"><a href="#MQ-Multi-Queue-多级队列算法" class="headerlink" title="MQ(Multi Queue)多级队列算法"></a>MQ(Multi Queue)多级队列算法</h4><p>本算法引入多个就绪队列,通过对各队列的区别对待,达到一个综合的调度目标.</p><p>对多个进程按照优先级进行分类,每类一个队列,各个队列之间按照PS进行调度,队列里面按照FCFS调度.</p><h4 id="MFQ-多级反馈队列算法"><a href="#MFQ-多级反馈队列算法" class="headerlink" title="MFQ 多级反馈队列算法"></a>MFQ 多级反馈队列算法</h4><p>引入多级优先队列,队列优先级越高则时间片越短,越低则越高.进程在某个队列运行完时间片之后,会被移入下一级队列,队列内部FCFS,队列间PS.<br>MFQ = PS(动态优先级) + FCFS + MQ</p><h3 id="彩票调度"><a href="#彩票调度" class="headerlink" title="彩票调度"></a>彩票调度</h3><p>为了给不同进程不同的调度份额,CPU资源使用权以彩票的形式发给进程,每次进行随机抽奖,中奖的进程得到资源.通过控制一个进程得到的彩票数比例,可以控制其得到系统资源的概率.</p><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><ul><li>用户级线程:内核调度进程,进程调度线程</li><li>内核级线程:内核直接调度线程</li></ul><h3 id="优先级倒转及其调度方法"><a href="#优先级倒转及其调度方法" class="headerlink" title="优先级倒转及其调度方法"></a>优先级倒转及其调度方法</h3><h4 id="优先级倒转现象"><a href="#优先级倒转现象" class="headerlink" title="优先级倒转现象"></a>优先级倒转现象</h4><p>例如有三个进程A,B,C,优先级依次降低.A和C共享资源X.这时C占有共享资源,一直没有放锁,A需要使用X,但因为C的优先级太低,A需要等待很久才能使用C.<br>这种高优先级进程（或线程）被低优先级进程（或线程）延迟或阻塞的现象叫<strong>优先级倒转现象</strong></p><h4 id="解决办法–优先级置项"><a href="#解决办法–优先级置项" class="headerlink" title="解决办法–优先级置项"></a>解决办法–优先级置项</h4><p>还是上面那个例子,当C进入临界区之后,C所占有的处理机不允许被抢占.<br><strong>缺点</strong></p><ul><li>如果临界区过长,A进程还是会等很长时间</li></ul><h4 id="优先级继承"><a href="#优先级继承" class="headerlink" title="优先级继承"></a>优先级继承</h4><p>当A因为临界区被阻塞的时候,C继承A的优先级,并一致保持到C退出临界区.</p><h3 id="实时系统的调度算法"><a href="#实时系统的调度算法" class="headerlink" title="实时系统的调度算法"></a>实时系统的调度算法</h3><p>实时系统分为<strong>硬实时系统</strong>和<strong>软实时系统</strong>,硬实时系统要求绝对满足截至时间要求,软实时系统可以偶尔不满足截至时间要求.</p><h4 id="静态表调度"><a href="#静态表调度" class="headerlink" title="静态表调度"></a>静态表调度</h4><p>通过对所有周期性任务的分析预测,事先确定一个固定的调度方案.<br><strong>优点</strong></p><ul><li>无任何动态计算,开销小</li><li>无灵活性,只适用于完全固定的任务场景</li></ul><h4 id="单调速率调度RMS"><a href="#单调速率调度RMS" class="headerlink" title="单调速率调度RMS"></a>单调速率调度RMS</h4><p>RMS是<strong>单处理器下</strong>的<strong>最优静态调度算法</strong></p><p><strong>定义</strong></p><ul><li>任务周期越小,频率越高,其优先级越高,最先调度优先级最高的任务</li><li>如果两个任务的优先级一样,则随机选择</li></ul><h4 id="最早截止期优先EDF"><a href="#最早截止期优先EDF" class="headerlink" title="最早截止期优先EDF"></a>最早截止期优先EDF</h4><p><strong>定义</strong></p><ul><li>任务截止日期越早,其优先级越高,最先调度优先级最高的任务</li><li>如果两个任务的优先级一样,则随机选择</li></ul><h3 id="多处理机调度"><a href="#多处理机调度" class="headerlink" title="多处理机调度"></a>多处理机调度</h3><h4 id="AMP-Asymmetric-Multi-Processor-非对称多处理系统"><a href="#AMP-Asymmetric-Multi-Processor-非对称多处理系统" class="headerlink" title="AMP(Asymmetric Multi-Processor)非对称多处理系统"></a>AMP(Asymmetric Multi-Processor)非对称多处理系统</h4><p>AMP指多处理器系统中各个处理器的地位不同,不同处理器负责不同分工,比如一个执行os功能,一个执行I/O.</p><p>该处理系统由主处理机管理一个公共就绪队列,并分派进程给从处理器执行.</p><h4 id="SMP-Symmetric-Multi-Processor-对称式多处理系统"><a href="#SMP-Symmetric-Multi-Processor-对称式多处理系统" class="headerlink" title="SMP(Symmetric Multi-Processor)对称式多处理系统"></a>SMP(Symmetric Multi-Processor)对称式多处理系统</h4><p>和AMP相反,SMP中各个处理器的地位相同.</p><ul><li><strong>静态分配</strong><br>每个CPU设立一个就绪队列，进程从开始执行到完成，都在同一个CPU上。</li></ul><p><strong>优点</strong><br>调度算法开销小<br><strong>缺点</strong><br>难以准确预测执行时间,容易出现忙闲不均</p><ul><li><strong>动态分配</strong><br>各个CPU采用一个公共就绪队列，队首进程每次分派到当前空闲的CPU上执行。可防止系统中多个处理器忙闲不均。</li><li><strong>自调度</strong><br>各个CPU采用一个公共就绪队列，每个处理机都可以从队列中选择适当进来执行。需要对就绪队列的数据结构进行互斥访问控制。是最常用的算法,实现时易于移植。</li></ul><p><strong>优点</strong><br>不需要专门的处理机从事任务分派工作<br><strong>缺点</strong><br>当处理机个数较多时,对就绪队列的访问可能成为系统的瓶颈</p><ul><li><strong>成组调度</strong><br>将一个进程中的一组线程,每次分配时到一组处理机上执行,在剥夺处理机时也同时对这一组线程进行.</li></ul><p><strong>优点</strong></p><ul><li><ul><li>通常这样的一组线程在应用逻辑上相互何做,成组调度提高了这些线程的执行并行度,有利于减少阻塞和加快推进速度,最终提高系统吞吐量.</li></ul></li><li><ul><li>每次调度可以完成多个线程的分派,在系统内线程总数相同时能够减少调度次数,从而减少调度算法的开销.</li></ul></li><li><strong>专用处理机调度</strong><br>为进程中的每个线程都固定分配一个CPU, 直到该线程执行完成.<br>只适用于CPU数量众多的高度并行系统, 单个CPU的利用率已经不太重要.</li></ul><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><p>进程同步主要体现于多个进程同时访问临界区(对共享资源进行访问的程序片段).<br>其原则为:</p><ul><li>空闲让进:没人在临界区则进入</li><li>忙则等待:有进程在临界区则等待</li><li>有限等待:进入临界区的进程要及时离开临界区,防止死锁</li><li>让权等待:进程长时间不能进入临界区则应该放出处理器,防止轮询<h3 id="基于忙等待的互斥方法"><a href="#基于忙等待的互斥方法" class="headerlink" title="基于忙等待的互斥方法"></a>基于忙等待的互斥方法</h3><h4 id="严格轮换法"><a href="#严格轮换法" class="headerlink" title="严格轮换法"></a>严格轮换法</h4>设立公用变量<code>turn</code>,描述允许进入临界区的进程标识.<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>turn <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// until the turn = 0,into  the critical region</span>        <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        turn <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>问题:<br>一个进程可能被一个不在临界区的进程阻塞<h4 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h4>进入临界区判断其他进程对其有没有兴趣,如果有则等待<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">enter_region</span><span class="token punctuation">(</span><span class="token keyword">int</span> process<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> other <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">-</span> process<span class="token punctuation">;</span>    interested<span class="token punctuation">[</span>process<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    turn <span class="token operator">=</span> process<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>turn <span class="token operator">==</span> process <span class="token operator">&amp;&amp;</span> interested<span class="token punctuation">[</span>other<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>特点:<br>如果同一个时刻两个进程都进入临界区，interested和turn是竞争访问，后设置turn的进程会循环，先设置的进入</li></ul><h4 id="硬件指令机制"><a href="#硬件指令机制" class="headerlink" title="硬件指令机制"></a>硬件指令机制</h4><p>Test and Set Lock指令简称TSL,执行该指令的CPU会通过锁住内存总线,禁止其他CPU访问内存<br>XCHG:原子性的交换两个位置的内容</p><h4 id="Bakery-Algorithm"><a href="#Bakery-Algorithm" class="headerlink" title="Bakery Algorithm"></a>Bakery Algorithm</h4><p>设置静态变量,每进入一个进程分配一个序号,如果多个进程分配到同一个序号,则根据进程号再排序.最后进程根据序号和进程号排序,最小的先进.</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在没有进入临界区,进程会等待,消耗CPU资源,对于这些进程应该将其阻塞,带到空闲再进入Runnable队列.</p><h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><p>信号量是一种新的变量类型 Semaphore , 只能通过初始化和标准原语 P/V 来访问, 作为OS核心代码执行, 不受进程调度打断.</p><ul><li>P(s):表示将要操作共享资源<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span>s<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//阻塞</span>s<span class="token operator">--</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>V(s):表示释放操作资源<pre class="line-numbers language-c" data-language="c"><code class="language-c">s<span class="token operator">++</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>对于不同的操作系统,初值设置可以不一样.<h4 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h4>$$\begin{matrix}<br>A:P(s) \rightarrow 临界区 \rightarrow V(s)\\<br>B:P(s) \rightarrow 临界区 \rightarrow V(s)<br>\end{matrix}<br>$$<h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4>$$\begin{matrix}<br>A:代码A \rightarrow P(s) \rightarrow 代码A\\<br>B:代码B \rightarrow V(s)\\<br>s初始值为0,A进程等待B完成之后才能继续进行\\<br>\end{matrix}<br>$$<h4 id="汇合"><a href="#汇合" class="headerlink" title="汇合"></a>汇合</h4>$$\begin{matrix}<br>A:a1 \rightarrow V(a) \rightarrow P(b) \rightarrow a2\\<br>B:b1 \rightarrow V(b) \rightarrow P(a) \rightarrow b2<br>\end{matrix}<br>$$<h4 id="屏障"><a href="#屏障" class="headerlink" title="屏障"></a>屏障</h4><pre class="line-numbers language-none"><code class="language-none">VAR n &#x2F;&#x2F;numofProcessVAR count &#x3D; 0P(a)count++V(a)if count &#x3D;&#x3D; n: 直到所有进程都完成了,才能继续b操作    V(b)P(b)V(b)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4>s = n,就能保证最多n个线程同时进行<h3 id="信号量集"><a href="#信号量集" class="headerlink" title="信号量集"></a>信号量集</h3><h4 id="AND型信号量集"><a href="#AND型信号量集" class="headerlink" title="AND型信号量集"></a>AND型信号量集</h4></li></ul><p><strong>基本思想</strong>: 一次性分配全部所需共享资源给进程, 待进程使用完后, 再一次性释放.</p><pre class="line-numbers language-none"><code class="language-none">SP (S1, S2, ..., Sn) :    while(1) &#123;        if ( S1 &gt;&#x3D; 1 &amp;&amp; S2 &gt;&#x3D; 1 &amp;&amp; ... &amp;&amp; Sn &gt;&#x3D; 1)&#123;&#125;            S1 &#x3D; S1 - 1;            S2 &#x3D; S2 - 1;            ...            Sn &#x3D; Sn - 1;            break;        &#125;    &#125;SV (S1, S2, ..., Sn) :    S1 &#x3D; S1 + 1;    S2 &#x3D; S2 + 1;    ...    Sn &#x3D; Sn + 1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="一般信号量集"><a href="#一般信号量集" class="headerlink" title="一般信号量集"></a>一般信号量集</h4><p><strong>基本思想</strong>: 在AND型信号量集的基础上进行扩充. 进程对信号量 Si 的测试值为 ti, 占用值为 di.</p><pre class="line-numbers language-none"><code class="language-none">SP (S1, t1, d1, S2, t2, d2, ..., Sn, tn, dn) :    while(1) &#123;        if (S1 &gt;&#x3D; t1 &amp;&amp; S2 &gt;&#x3D; t2 &amp;&amp; ... &amp;&amp; Sn &gt;&#x3D; tn )&#123;            S1 &#x3D; S1 - d1            S2 &#x3D; S2 - d2            ...            Sn &#x3D; Sn - dn            break;        &#125;    &#125;SV (S1, d1, S2, d2, ..., Sn, dn) :    S1 &#x3D; S1 + d1    S2 &#x3D; S2 + d2    ...    Sn &#x3D; Sn + dn<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h4><ul><li>SP(S,d,d):表示每次申请d个资源，当资源数量少于d个时，便不<br>予分配</li><li>SP(S,1,1):表示互斥信号量</li><li>SP(S,1,0):$S \ge 1$是允许多个进程,$S = 1$禁止任何进程</li></ul><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>优点:<ul><li>简单,表达能力强</li></ul></li><li>缺点:<ul><li>不够安全,可能死锁.</li><li>实际编程中,多个共享数据,加重了编程负担</li></ul></li></ul><h3 id="管程-Monitor"><a href="#管程-Monitor" class="headerlink" title="管程(Monitor)"></a>管程(Monitor)</h3><p>为了应付信号量不够安全,和编程负担过重的问题,提出了管程用于<strong>集中分散的临界区</strong>,<strong>统一管理个进程对可共享资源的访问</strong>.</p><p>管程可以由函数库的形式实现,是一种高级同步原语.</p><p>为每个共享资源设立一个管程,由用户编写,对共享变量的访问通过其共有接口实现,有点像面向对象的思路.</p><h4 id="管程的实现"><a href="#管程的实现" class="headerlink" title="管程的实现"></a>管程的实现</h4><p>下面是java 对管程实现的思路</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Monitor</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> buffer<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>lo <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>hi <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//对生产者的接口</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token class-name">N</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">go_to_sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        buffer<span class="token punctuation">[</span>hi<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span>        hi <span class="token operator">=</span> <span class="token punctuation">(</span>hi<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token class-name">N</span><span class="token punctuation">;</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//对消费者的接口</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">go_to_sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> ret <span class="token operator">=</span> buffer<span class="token punctuation">[</span>lo<span class="token punctuation">]</span><span class="token punctuation">;</span>        lo <span class="token operator">=</span> <span class="token punctuation">(</span>lo<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token class-name">N</span><span class="token punctuation">;</span>        count<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token class-name">N</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上面代码的思路,管程就是将零碎的共享资源进行封装,提供统一的接口进行操作,在管程里面对共享资源的操作都是互斥的.<br>管程中有如下信息:</p><ul><li><strong>临界资源</strong>:管程管理的共享资源,每一个临界资源的创立都有一个对应的等待队列.</li><li><strong>控制变量</strong>:管程内部,用于控制进程运行状态的变量(上述代码中的N,hi,lo)</li><li><strong>操作原语</strong>:对控制变量和临界资源进行操作的一组代码,是提供给外部的唯一指定途径</li></ul><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>优点<ul><li>统一管理临界资源,更加安全</li></ul></li><li>缺点<ul><li>依赖语言</li><li>不适用于分布式系统</li></ul></li></ul><h3 id="进程通信的主要方法"><a href="#进程通信的主要方法" class="headerlink" title="进程通信的主要方法"></a>进程通信的主要方法</h3><h4 id="通信的分类"><a href="#通信的分类" class="headerlink" title="通信的分类"></a>通信的分类</h4><ul><li>低级通信:只能传递状态和整数值<ul><li>缺点:<ul><li>传输信息量小</li><li>用户直接实现通信的细节,容易出错</li></ul></li></ul></li><li>高级通信:能够传送任意数量的数据,包括三类:管道,共享内存,信息系统<ul><li>管道通信(Pipe):管道是用于连接读进程和写进程以实现两个进程通信的<strong>共享文件</strong>,又称管道文件.在UNIX系统中分为无名管道和有名管道</li></ul></li></ul><h4 id="无名管道-Pipe"><a href="#无名管道-Pipe" class="headerlink" title="无名管道(Pipe)"></a>无名管道(Pipe)</h4><p>该管道是单向管道,数据只能向一个方向流动,而且该管道只能用于父子进程和兄弟进程之间.</p><p>单独构成一种<strong>独立的文件系统</strong></p><blockquote><p>管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只<strong>存在在内存中</strong>。</p></blockquote><p>数据的读出和写入:</p><blockquote><p>一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。</p></blockquote><p>由此可见,两个进程对管道文件的权限不同,一个只读,一个只写(无名管道是<strong>单向管道</strong>)</p><h4 id="有名管道-Named-Pipe-或-FIFO"><a href="#有名管道-Named-Pipe-或-FIFO" class="headerlink" title="有名管道(Named Pipe 或 FIFO)"></a>有名管道(Named Pipe 或 FIFO)</h4><p>有名管道克服了无名管道只能用于亲缘关系之间通信的问题.</p><p>该管道通过提供一个路径名与之关联,只要通过访问该路径,就能凭借该管道通信.</p><p>该管道对于不同进程的数据管理是FIFO,先进先出.</p><h4 id="信息传递"><a href="#信息传递" class="headerlink" title="信息传递"></a>信息传递</h4><p>信息传递的方式提供了两个通信原语(是一个系统调用):</p><ul><li><code>send(destination,&amp;message)</code></li><li><code>receive(source,&amp;message)</code></li></ul><p><strong>调用方式</strong>:</p><ul><li>阻塞调用</li><li>非阻塞调用(maybe内核线程)</li></ul><p><strong>主要问题</strong>:</p><ul><li>解决信息丢失,延迟问题</li><li>编址问题</li></ul><p><strong>传递过程</strong>:<br>调用send()之后,首先<strong>陷入内核态</strong>,然后<strong>复制message于消息缓冲区</strong>.之后将消息缓冲区<strong>挂载到接受进程的消息队列</strong>.之后调用receive()函数则将消息队列的消息<strong>复制</strong>过来.</p><h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>该方式是最有用的进程通信方式,因为省去了开销很大的缓冲复制过程.</p><p>共享内存意味着同一块物理内存被映射到了两个不同进程的进程地址空间.通过信号量等方法实现共享内存的互斥和同步.</p><h3 id="经典进程同步问题"><a href="#经典进程同步问题" class="headerlink" title="经典进程同步问题"></a>经典进程同步问题</h3><h4 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h4><p>基础生产者消费者问题:</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token constant">SEMAPHORE</span> full <span class="token operator">=</span> <span class="token number">0</span><span class="token constant">SEMAPHORE</span> empty <span class="token operator">=</span> <span class="token constant">N</span><span class="token constant">SEMAPHORE</span> mutex <span class="token operator">=</span> <span class="token number">1</span>         <span class="token comment">// protect buffer</span><span class="token constant">VAR</span> buffer<span class="token punctuation">[</span><span class="token constant">N</span><span class="token punctuation">]</span><span class="token constant">VAR</span> buf_in <span class="token operator">=</span> <span class="token number">0</span><span class="token constant">VAR</span> buf_out <span class="token operator">=</span> <span class="token number">0</span><span class="token constant">PRODUCER</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span>    <span class="token constant">WHILE</span> <span class="token constant">TRUE</span> <span class="token operator">:</span>        next <span class="token operator">=</span> <span class="token comment">// produce `next` //</span>        <span class="token constant">P</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span>        <span class="token constant">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span>        buffer<span class="token punctuation">[</span>buf_in<span class="token punctuation">]</span> <span class="token operator">=</span> next        buf_in <span class="token operator">=</span> <span class="token punctuation">(</span>buf_in <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token constant">N</span>        <span class="token constant">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span>        <span class="token constant">V</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token constant">CONSUMER</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span>    <span class="token constant">WHILE</span> <span class="token constant">TRUE</span> <span class="token operator">:</span>        <span class="token constant">P</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span>        <span class="token constant">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span>        next <span class="token operator">=</span> buffer<span class="token punctuation">[</span>buf_out<span class="token punctuation">]</span>        buf_out <span class="token operator">=</span> <span class="token punctuation">(</span>buf_out <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token constant">N</span>        <span class="token constant">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span>        <span class="token constant">V</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span>        <span class="token comment">// consume `next` //</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>扩展问题:设有一个可以装A, B两种物品的仓库, 其容量无限大, 但要求仓库中A, B两种物品的数量 $C_A$ 和 $C_B$​ 满足下述不等式:<br>$$−M \le C_A​−C_B ​\le N \quad (M,N \in Z+)$$</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token constant">SEMAPHORE</span> mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token constant">SEMAPHORE</span> sem_a <span class="token operator">=</span> <span class="token constant">N</span><span class="token constant">SEMAPHORE</span> sem_b <span class="token operator">=</span> <span class="token constant">M</span><span class="token constant">A</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span>    <span class="token constant">WHILE</span> <span class="token constant">TRUE</span> <span class="token operator">:</span>        <span class="token constant">P</span><span class="token punctuation">(</span>sem_a<span class="token punctuation">)</span>           <span class="token constant">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span>        <span class="token comment">// A --> warehouse //</span>        <span class="token constant">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span>        <span class="token constant">V</span><span class="token punctuation">(</span>sem_b<span class="token punctuation">)</span> <span class="token comment">//增加B的上限</span><span class="token constant">B</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span>    <span class="token constant">WHILE</span> <span class="token constant">TRUE</span> <span class="token operator">:</span>        <span class="token constant">P</span><span class="token punctuation">(</span>sem_b<span class="token punctuation">)</span>        <span class="token constant">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span>        <span class="token comment">// B --> warehouse //</span>        <span class="token constant">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span>        <span class="token constant">V</span><span class="token punctuation">(</span>sem_a<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h4><p>读者优先:</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">int readers <span class="token operator">=</span> <span class="token number">0</span>Semaphore mutex <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment">//互斥</span>Semaphore roomEmpty <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment">//是否能容下其他人</span>Semaphore turnstile <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment">//闸机控制</span><span class="token literal-property property">Reader</span><span class="token operator">:</span><span class="token comment">//进入</span><span class="token constant">P</span><span class="token punctuation">(</span>turnstile<span class="token punctuation">)</span><span class="token constant">V</span><span class="token punctuation">(</span>turnstile<span class="token punctuation">)</span><span class="token constant">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span>    readers <span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> readers <span class="token operator">==</span> <span class="token number">1</span><span class="token operator">:</span>        <span class="token constant">P</span><span class="token punctuation">(</span>roomEmpty<span class="token punctuation">)</span> <span class="token comment">//不允许写者进入</span><span class="token constant">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token comment">//read critical region</span><span class="token comment">//离开</span><span class="token constant">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span>    readers<span class="token operator">--</span>    <span class="token keyword">if</span> readers <span class="token operator">==</span> <span class="token number">0</span><span class="token operator">:</span>        <span class="token constant">V</span><span class="token punctuation">(</span>roomEmpty<span class="token punctuation">)</span><span class="token constant">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token literal-property property">Writer</span><span class="token operator">:</span><span class="token constant">P</span><span class="token punctuation">(</span>turnstile<span class="token punctuation">)</span> <span class="token comment">//禁止其他读者进入</span>    <span class="token constant">P</span><span class="token punctuation">(</span>roomEmpty<span class="token punctuation">)</span> <span class="token comment">//等待里面的读者出来</span>    <span class="token comment">//write critical region</span><span class="token constant">V</span><span class="token punctuation">(</span>roomEmpty<span class="token punctuation">)</span><span class="token constant">V</span><span class="token punctuation">(</span>turnstile<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>公平</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">int readers <span class="token operator">=</span> <span class="token number">0</span>Semaphore roomEmpty <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment">//是否能容下其他人</span>Semaphore turnstile <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment">//闸机控制</span><span class="token literal-property property">Reader</span><span class="token operator">:</span><span class="token comment">//进入</span><span class="token constant">P</span><span class="token punctuation">(</span>turnstile<span class="token punctuation">)</span><span class="token constant">V</span><span class="token punctuation">(</span>turnstile<span class="token punctuation">)</span><span class="token constant">P</span><span class="token punctuation">(</span>roomEmpty<span class="token punctuation">)</span><span class="token comment">//read critical region</span><span class="token constant">V</span><span class="token punctuation">(</span>roomEmpty<span class="token punctuation">)</span><span class="token literal-property property">Writer</span><span class="token operator">:</span><span class="token constant">P</span><span class="token punctuation">(</span>turnstile<span class="token punctuation">)</span> <span class="token comment">//禁止其他读者进入</span>    <span class="token constant">P</span><span class="token punctuation">(</span>roomEmpty<span class="token punctuation">)</span> <span class="token comment">//等待里面的读者出来</span>    <span class="token comment">//write critical region</span><span class="token constant">V</span><span class="token punctuation">(</span>roomEmpty<span class="token punctuation">)</span><span class="token constant">V</span><span class="token punctuation">(</span>turnstile<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p><strong>死锁</strong>:如果一个进程集合中的<strong>每个进程</strong>都在等待只能由该进程集合中其他进程才能<strong>引发的事件</strong>，那么该进程集合就是死锁的。</p><p><strong>资源死锁</strong>:如果<strong>每个进程</strong>等待的事件是释放该进程集合中其他进程所占有的<strong>资源</strong>。</p><h3 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h3><ul><li><strong>互斥条件</strong>:指进程对所分配到的资源进行排他性使用,即在一段时间内资源只能有一个进程占用</li><li><strong>保持和请求条件</strong>:已经获得资源的线程可以请求新的资源</li><li><strong>不剥夺条件</strong>:指进程已获得的资源,再未使用完之前不能被强制剥夺,只能在使用完时由自己释放</li><li><strong>环路等待条件</strong>:指在发生死锁时,必然存在两个或多个进程组成的环形链,每个进程都在等待环形链中下一个节点占用的资源.</li></ul><h3 id="死锁处理方法"><a href="#死锁处理方法" class="headerlink" title="死锁处理方法"></a>死锁处理方法</h3><h4 id="鸵鸟算法"><a href="#鸵鸟算法" class="headerlink" title="鸵鸟算法"></a>鸵鸟算法</h4><p><del><strong>神中神</strong></del>.<br>OS无所作为,全部交给程序员来负责</p><h4 id="死锁检测与死锁恢复"><a href="#死锁检测与死锁恢复" class="headerlink" title="死锁检测与死锁恢复"></a>死锁检测与死锁恢复</h4><p>允许死锁发生,当检测死锁放生之后,采取措施恢复<br>死锁检测算法:</p><ul><li>基于资源分配图,每类一个资源</li><li>基于资源向量计算,每类多个资源</li></ul><h4 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h4><p>破坏死锁的四个必要条件.</p><h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><p>在资源分配之前判断是否安全,仅当安全才进行分配.需要依赖执行前获取额外信息.</p><h3 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h3><p>每类资源一个的死锁检测<br>按照资源请求和释放的序列对图进行操作，并在每步操作后检查是否存在环。<br>可用作分析是否存在死锁的工具</p><h3 id="资源向量计算"><a href="#资源向量计算" class="headerlink" title="资源向量计算"></a>资源向量计算</h3><p>矩阵介绍:</p><ul><li>E:存在资源向量:表示每类资源的总量</li><li>A:可用资源向量:表示当前未分配可使用的资源数</li><li>C:当前分配矩阵:表示第i个行向量对应第i个进程已经分配到的各类资源数量</li><li>R:请求矩阵:第i个行向量表示进程i所需要的资源数量<br>$\displaystyle \sum C_{ij} + A_j = E_j$</li></ul><p>算法步骤:</p><ul><li>寻找进程$P_i$,其在R矩阵中对应的第i行小于等于A</li><li>如果找到,将C矩阵的第i行加入A,标记该进程执行完毕,转到第一步</li><li>如果找不到,结束</li></ul><h3 id="死锁恢复"><a href="#死锁恢复" class="headerlink" title="死锁恢复"></a>死锁恢复</h3><ul><li>资源抢占法:<br>挂起一些占有资源的进程，剥夺它们的资源以解除死锁，将资源分配给另一个死锁进程使其能够执行完毕，然后再激活被挂起的进程</li><li>杀死进程法:<ul><li>杀死一个或者若干个进程,杀死的线程应该是重新执行无副作用的进程,根据资源情况,杀死环内或者环外的进程</li></ul></li><li>回滚法:<ul><li>设置检查点,根据死锁时所需要的资源,将一个拥有资源的进程滚回一个未占用资源的检查点状态,从而使得其他死锁进程能够获得响应的资源</li></ul></li></ul><h3 id="死锁预防-1"><a href="#死锁预防-1" class="headerlink" title="死锁预防"></a>死锁预防</h3><ul><li><strong>打破互斥</strong>:<br>允许进程同时访问某些资源</li><li><strong>打破保持和请求条件</strong>:<br>在进程开始执行前请求所需的全部资源。只有当系统能够满足当前进程的全部资源需求时，才一次性地将所申请的资源全部分配给该进程，否则不分配任何资源。或者请求之前先释放资源,再尝试获得所有资源<ul><li>缺点:<ul><li>资源不可预测</li><li>资源利用率低</li><li>降低进程并发</li></ul></li></ul></li><li><strong>打破不可抢占条件</strong>:<br>允许进程强行从占有者哪里夺取那些资源.</li><li><strong>打破循环等待条件</strong>:<br>实行资源有序分配策略。即把资源事先分类编号，所有进程对资源的请求必须严格按资源序号递增的顺序提出，使进程在申请，占用资源时不会形成环路，从而预防了死锁。<ul><li>缺点:增加开销,增加了进程对资源的占用时间</li></ul></li></ul><h3 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h3><p>5个哲学家围绕一张圆桌而坐，桌子上放着5支筷子(叉子)，每两个哲学家之间放一支；哲学家必须拿到左右两只筷子才能吃饭。<br><strong>方法</strong>:</p><ul><li><strong>破除循环等待</strong>:<ul><li>至多允许四个哲学家同时拿起筷子,保证至少一个哲学家就餐.</li><li>奇数号哲学家先拿左再拿右,偶数人反之</li><li>同时拿起两根筷子,或者不拿起</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异步爬虫学习</title>
      <link href="/2022/04/05/%E5%BC%82%E6%AD%A5%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/04/05/%E5%BC%82%E6%AD%A5%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="异步爬虫"><a href="#异步爬虫" class="headerlink" title="异步爬虫"></a>异步爬虫</h1><h2 id="相关库"><a href="#相关库" class="headerlink" title="相关库"></a>相关库</h2><ul><li><strong><code>asyncio</code></strong>: 实现协程的库</li><li><strong><code>aiohttp</code></strong>: 发送请求的第三方库,和<code>requests</code>,<code>urllib</code>这些爬虫库的区别是该库的请求方法都是异步请求方法<h2 id="协程知识"><a href="#协程知识" class="headerlink" title="协程知识"></a>协程知识</h2>协程和多线程类似,对于共用数据的使用也需要加锁等待,具体细节参照多线程.</li></ul><h2 id="asyncio的使用"><a href="#asyncio的使用" class="headerlink" title="asyncio的使用"></a><code>asyncio</code>的使用</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><code>event_loop</code>:事件循环,相当于无限循环,我们可以把一些函数注册到上面,当满足发生条件时,则调用对应的处理方法.</li><li><code>coroutine</code>: 协程,指<code>python</code>中的协程对象,该协程对象通过注册到事件循环中调用.</li><li><code>task</code>:对协程对象的进一步封装,增加了协程对象的状态</li><li><code>future</code>:代表未来执行或者没有执行的任务的结果,和<code>task</code>没有区别.<h3 id="新加关键字"><a href="#新加关键字" class="headerlink" title="新加关键字"></a>新加关键字</h3><code>asyncio</code>新增了几个关键字,下面分别解释.</li><li><strong><code>async</code></strong>:对方法或者协程对象使用,使用该方法定义的方法无法直接执行,而是返回一个协程对象,该对象必须注册到事件循环中执行(类似<code>java</code>的<code>Thread</code>需要<code>start</code>)<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><strong><code>await</code></strong>: 将耗时等待的操作挂机,让出控制权,类似<code>java</code>中的<code>wait</code>方法.<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">getResponse</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">:</span>    response <span class="token operator">=</span> <span class="token keyword">await</span> get<span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">get</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">:</span>    session <span class="token operator">=</span> aiohttp<span class="token punctuation">.</span>ClientSession<span class="token punctuation">(</span><span class="token punctuation">)</span>    response <span class="token operator">=</span> <span class="token keyword">await</span> session<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">)</span>    <span class="token keyword">await</span> response<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">await</span> session<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> response<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3>代码样例:<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> asyncio<span class="token keyword">import</span> aiohttp<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">getResponse</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">:</span>    response <span class="token operator">=</span> <span class="token keyword">await</span> get<span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">get</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">:</span>    session <span class="token operator">=</span> aiohttp<span class="token punctuation">.</span>ClientSession<span class="token punctuation">(</span><span class="token punctuation">)</span>    response <span class="token operator">=</span> <span class="token keyword">await</span> session<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">)</span>    <span class="token keyword">await</span> response<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">await</span> session<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> responseurl <span class="token operator">=</span> <span class="token string">""</span>tasks <span class="token operator">=</span> <span class="token punctuation">[</span>asyncio<span class="token punctuation">.</span>ensure_future<span class="token punctuation">(</span>getResponse<span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token comment">## 创建协程对象的列表,其中ensure_future方法和creat_task方法可以混用</span>loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_envent_loop<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">## 创建事件循环</span>loop<span class="token punctuation">.</span>run_until_complete<span class="token punctuation">(</span>asyncio<span class="token punctuation">.</span>wait<span class="token punctuation">(</span>tasks<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">## 调用tasks</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="aiohttp的使用"><a href="#aiohttp的使用" class="headerlink" title="aiohttp的使用"></a>aiohttp的使用</h2><p><code>aiohttp</code>是实现异步<code>http</code>协议操作的模块.该模块基于<code>asyncio</code>的异步<code>http</code>网络模块,既提供了服务端,也提供了客户端.服务端主要是用于处理请求与返回请求.客户端主要用于发起异步请求.爬虫只需要客户端就行.</p><p>样例代码</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> aiohttp<span class="token keyword">import</span> asyncio<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">fetch</span><span class="token punctuation">(</span>session<span class="token punctuation">,</span>url<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">async</span> <span class="token keyword">with</span> session<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>params <span class="token operator">=</span> params<span class="token punctuation">)</span> <span class="token keyword">as</span> response<span class="token punctuation">:</span> <span class="token comment">## with as用于python增加一个上下文管理器,自动分配和管理资源</span>        <span class="token keyword">return</span> <span class="token keyword">await</span> response<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>response<span class="token punctuation">.</span>status          <span class="token comment">## params 用于设置URL参数,和requests类似</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span>url<span class="token punctuation">:</span><span class="token builtin">str</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">async</span> <span class="token keyword">with</span> aiohttp<span class="token punctuation">.</span>ClientSession<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> session<span class="token punctuation">:</span>        html<span class="token punctuation">,</span>status <span class="token operator">=</span> <span class="token keyword">await</span> fetch<span class="token punctuation">(</span>url<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    url <span class="token operator">=</span> <span class="token string">''</span>    loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_event_loop<span class="token punctuation">(</span><span class="token punctuation">)</span>    loop<span class="token punctuation">.</span>run_until_complete<span class="token punctuation">(</span>main<span class="token punctuation">(</span>url<span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>aiohttp同样支持post请求等,和requests请求类似,就不赘述了</p><h3 id="并发限制"><a href="#并发限制" class="headerlink" title="并发限制"></a>并发限制</h3><p>使用<code>asyncio</code>的<code>Semaphore</code>控制并发量,防止网站崩掉<br>类似于<code>P/V</code>原语,<code>Semaphore</code>定义的信号量需要自己手动管理,这个时候就展示出<code>with</code>的妙用了</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> asyncioCONCURRENCE <span class="token operator">=</span> <span class="token number">10</span>semaphore <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>Semaphore<span class="token punctuation">(</span>CONCURRENCE<span class="token punctuation">)</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">getURL</span><span class="token punctuation">(</span>URL<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">async</span> <span class="token keyword">with</span> semaphore<span class="token punctuation">:</span> <span class="token comment">##相当于在开头结尾增加 P(semaphore)  V(semaphore)</span>        <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 爬虫学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统_链接与重定位</title>
      <link href="/2022/03/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E9%93%BE%E6%8E%A5%E4%B8%8E%E9%87%8D%E5%AE%9A%E4%BD%8D/"/>
      <url>/2022/03/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E9%93%BE%E6%8E%A5%E4%B8%8E%E9%87%8D%E5%AE%9A%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="链接与重定位"><a href="#链接与重定位" class="headerlink" title="链接与重定位"></a>链接与重定位</h1><h2 id="逻辑地址空间"><a href="#逻辑地址空间" class="headerlink" title="逻辑地址空间"></a>逻辑地址空间</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>如果没有引入抽象的逻辑地址空间,直接使用物理地址,那么,没有重定位操作势必破坏系统和其他应用的内存,如果实现重定位,其实现复杂(每次运行都需要重新编译进行重定位),浪费时间,所以需要<strong>新增一层在程序</strong>和实际物理地址之间,这一层就是<strong>逻辑地址空间</strong>,这样只需要建立逻辑地址到物理地址的映射即可,不需要每次都修改文件.</p><h3 id="辨别"><a href="#辨别" class="headerlink" title="辨别"></a>辨别</h3><ul><li>物理地址:</li><li><ul><li>内存中一系列存储信息的物理地址的集合</li></ul></li><li>逻辑地址</li><li><ul><li>对内存空间的抽象</li></ul></li><li><ul><li>是一个进程用来范文内存的一组地址</li></ul></li><li><ul><li>不同进程之间的地址空间相对独立,每个进程访问的地址是自己的逻辑地址,不会访问到其他进程的空间.<h3 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h3>程序的逻辑地址空间只是针对进程而言,实际操作系统需要访问物理地址,逻辑地址到实际物理地址的转化就是地址映射,由存储管理单元(MMU)完成.<h3 id="动态重定位"><a href="#动态重定位" class="headerlink" title="动态重定位"></a>动态重定位</h3>在装载程序时,直接将程序装入到分配的内存中,执行的时候,基址寄存器存放程序的首地址,界限寄存器存放程序的长度,这样每一次地址访问都经过基址寄存器的转换,访问到真正的内存.<h2 id="装入和链接"><a href="#装入和链接" class="headerlink" title="装入和链接"></a>装入和链接</h2>代码源文件先经过<strong>编译</strong>,变成机器码文件,再把几个程序之间<strong>链接</strong>,以使用依赖的库,然后再一起<strong>装入</strong>内存.<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3>链接分为静态链接和动态链接,分别如下</li></ul></li><li>静态链接:在编译阶段把静态库复制加入到可执行文件中,导致可执行文件较大.</li><li>动态链接:假装链接完毕,其实只是加入了描述信息,等到执行到这里的时候去访问相应动态库载入内存执行.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统_内存管理</title>
      <link href="/2022/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2022/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="原因和需求"><a href="#原因和需求" class="headerlink" title="原因和需求"></a>原因和需求</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul><li>软件对内存的需求很大,如果不加管理,会无限制使用内存</li><li>快速存储器成本太高,需要好好利用内存<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3></li><li>支持多程序和多用户</li><li>充分利用空间</li><li>给每一个程序足够大的逻辑运行空间</li><li>存储保护<h2 id="存储管理的功能"><a href="#存储管理的功能" class="headerlink" title="存储管理的功能"></a>存储管理的功能</h2></li><li><strong>存储的分配和回收</strong>:时存储管理的重点,重点时讨论算法和相应的数据结构.</li><li><strong>存储的共享和保护</strong>:可以理解成对地址空间的权限(读,写,运行).</li><li><strong>地址变换</strong>: 可执行文件生成时的链接计数,程序加载时的重定位技术,进程运行时硬件和软件的地址变换技术.</li><li><strong>存储的容量扩充</strong>:不是增加内存条的容量扩充,而是当需要更多内存的时候,内存的覆盖,交换,虚拟内存.</li></ul><h2 id="概念解析"><a href="#概念解析" class="headerlink" title="概念解析:"></a>概念解析:</h2><ul><li><strong>地址空间</strong>:源程序经过编译之后得到的目标地址,存在于它所限定的地址范围类,这个范围称为地址空间.简言之,地址空间就是<strong>逻辑地址</strong>的集合.</li><li><strong>存储空间</strong>:主存中一系列存储信息的物理单元的集合,这些单元的编号称为物理地址或绝对地址.简言之,存储空间就是<strong>物理地址</strong>的集合.</li></ul><p>简言之,地址空间就是<strong>进程认为</strong>自己使用的空间,是一个抽象空降,存储空间就是<strong>实际操作</strong>访问的物理空间,这二者就是CO中提到的<strong>虚拟内存技术</strong>.</p><ul><li><strong>内碎片</strong>:如果一个分区没有被完全占用,则剩下的空间被称为内碎片.该碎片在操作系统眼里已经被占用,无法整理.</li><li><strong>外碎片</strong>: 占用分区之间的空闲分区,这片分区如果小于载入程序则无法利用,被浪费.该碎片可以整理后清楚,是内存系统性能下降的主要原因.<br><img src="%E5%88%9A%E5%A5%BD%E5%88%A9%E7%94%A8.png" alt="刚好利用">  <img src="%E5%A4%96%E7%A2%8E%E7%89%87.png" alt="外碎片">  <img src="%E5%86%85%E7%A2%8E%E7%89%87.png" alt="内碎片">  </li></ul><h2 id="单道程序的内存管理"><a href="#单道程序的内存管理" class="headerlink" title="单道程序的内存管理"></a>单道程序的内存管理</h2><p>整个系统中出了操作系统之外只剩这一个程序,所以整个内存可以供他使用,其地址也可以固定.就像整个地区如果只有一个部落,那部落肯定找一个最好的地方发展下去.如果有多个部落互相抢占资源,那肯定存在部落被顶替掉的情况.</p><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><ul><li>在单道程序环境下,整个内存里只有两个程序,一个是用户程序,一个是操作系统.</li><li>操作系统占据的空间是固定的.</li><li>因此可以将用户程序加载到同一个地址,即用户程序永远可以从同一个地方开始运行.</li></ul><h3 id="静态地址翻译"><a href="#静态地址翻译" class="headerlink" title="静态地址翻译"></a>静态地址翻译</h3><p>因为程序的地址固定,所以可以在程序运行之前就计算出所有的物理地址.使用此方法,用户无需知道关于内存的知道,操作系统直接访问地址即可,而且因为没有其他程序,那么整个程序在这个地址就是安全的.</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>优点:运行简单,没有地址翻译,运行速度快</li><li>缺点:整个内存只给一个程序,造成资源浪费.而且如果程序必内存大无法加载,则无法运行.</li></ul><h2 id="多道程序的内存管理–分区"><a href="#多道程序的内存管理–分区" class="headerlink" title="多道程序的内存管理–分区"></a>多道程序的内存管理–分区</h2><h3 id="空间的分配"><a href="#空间的分配" class="headerlink" title="空间的分配"></a>空间的分配</h3><ul><li>把内存分成一些大小<strong>相等或者不等的</strong>分区,每个应用程序占用一个或者多个分区,操作系统占用一个分区.</li><li>适用于多道程序系统和分时系统,支持并发,但难以进行内存分区的共享.(每个程序共享整个内存,难以对某一些地址空间进行权限控制)<h3 id="固定式分区分配"><a href="#固定式分区分配" class="headerlink" title="固定式分区分配"></a>固定式分区分配</h3><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4></li><li>固定(静态)式分区分配:这个方法是<strong>程序适应分区</strong>,在系统初始化之后将内存划分成若干个<strong>任意大小</strong>的区域,然后将这些区域分配给进程.</li><li><ul><li>相同大小的分区:适用性差,只适用于多个相同程序的并发执行</li></ul></li><li><ul><li>分区大小不等:多个小分区,适量的中等分区,少量的大分区,根据程序大小,分配适当的分区.<h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4></li></ul></li><li>优点:算法实现简单,方案运行开销小</li><li>缺点:出现了内碎片,分区数目限制之后,最大载入程序数量也确定,限制了并发执行程序的数量.<h4 id="分配方式"><a href="#分配方式" class="headerlink" title="分配方式"></a>分配方式</h4></li><li>单一队列的分配方式:当加载程序是,选择一个闲置且足够大的分区加载.多个程序排在同一个队列.</li><li>多队列的分配方式:根据程序的大小分成不同队列,排在不同大小的分区后面.</li></ul><h3 id="可变式分区"><a href="#可变式分区" class="headerlink" title="可变式分区"></a>可变式分区</h3><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><ul><li>可变式分区分配:这个方法是<strong>分区适应程序</strong>,分区的边界可以更改.<h4 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h4></li><li>优点:没有了内碎片</li><li>缺点:有外碎片</li></ul><h3 id="闲置空间的管理"><a href="#闲置空间的管理" class="headerlink" title="闲置空间的管理"></a>闲置空间的管理</h3><h4 id="位图表示法"><a href="#位图表示法" class="headerlink" title="位图表示法"></a>位图表示法</h4><p>给每个分区赋予一个滋味,用来记录该分配单元是否闲置.</p><h4 id="链表表示法"><a href="#链表表示法" class="headerlink" title="链表表示法"></a>链表表示法</h4><p>将分配单元按照是否闲置链接起来.每一个结点分别记录该空间是否空闲,空间的起止地址以及指向下一个结点的指针.</p><h4 id="两种方法分析"><a href="#两种方法分析" class="headerlink" title="两种方法分析"></a>两种方法分析</h4><p><strong>位图表示法</strong></p><ul><li>空间成本固定,不依赖于内存中程序数量</li><li>时间成本低,只需要修改位图即可,一次改1bit</li><li>没有容错能力,如果存储单元出错,无法分辨该位置的1是被占用还是出错.</li></ul><p><strong>链表表示法</strong></p><ul><li>空间成本取决于程序数量</li><li>时间成本高,链表的查找是O(n)的复杂度</li><li>有一定容错能力,因为链表有被占空间和闲置空间的表项,可以互相验证.<h4 id="可变分区的管理"><a href="#可变分区的管理" class="headerlink" title="可变分区的管理"></a>可变分区的管理</h4>内存采用两张表,<strong>已分配分区表</strong>和为<strong>分配分区表</strong>.</li></ul><p>每张表的表项都可称为存储控制块<code>MCB(Memory Control Block)</code>,包括<code>AMCB</code>(Allocated MCB)和<code>FMCB</code>(Free MCB).</p><p>空闲分区控制块按某种次序构成FMCB链表接口,但分区被分配之后,其前后项指针无意义.</p><h3 id="分区分配操作"><a href="#分区分配操作" class="headerlink" title="分区分配操作"></a>分区分配操作</h3><h4 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h4><ul><li>设size是最小分区大小,不能再分割</li><li>如果$请求分区大小 \gt 分区大小$检索下一个表项</li><li>如果$请求分区大小+size \lt 分区大小$则将分区中按照相应大小划分一块,剩下的部分留在空间分区表中.</li><li>如果$请求分区大小+size \ge 分区大小$则将整个分区都分给程序.<h4 id="回收内存"><a href="#回收内存" class="headerlink" title="回收内存"></a>回收内存</h4></li><li>回收分区邻接空闲分区则将空闲分区和回收分区合并</li><li>回收分区不邻接空闲分区则在空闲分区表中新建表项放置回收分区</li></ul><h3 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h3><h4 id="基于顺序搜索的分配算法"><a href="#基于顺序搜索的分配算法" class="headerlink" title="基于顺序搜索的分配算法"></a>基于顺序搜索的分配算法</h4><p><strong>算法介绍</strong></p><ul><li><strong>首次适应算法</strong>:每个空白区按照地址顺序排成链表,从头找到尾,分配出第一个满足条件的分区</li><li><strong>下次适应算法</strong>:把空白区构成一个循环链表,每一次查询从上一次的位置出发,分配出第一个满足条件的分区</li><li><strong>最佳适应算法</strong>:遍历所有空白区,分配最佳的分区</li><li><strong>最坏适应算法</strong>:遍历所有空白区,分配最大的空白区</li></ul><p><strong>算法特点</strong></p><ul><li><strong>首次适应算法</strong>:低地址地址会被不断划分出去,之后的查找时间开销变大</li><li><strong>下次适应算法</strong>:是空间使用更加均匀</li><li><strong>最佳适应算法</strong>:分配出的空间是最佳的,但是会剩下很多特别小的碎片,而且时间开销大</li><li><strong>最坏适应算法</strong>:剩下比较大的碎片,不能满足之后的大程序,而且时间开销大</li></ul><p><strong>总结</strong><br>该类方法只适用于小系统,如果系统很大,则分区很多,每次的查找开销很大</p><h4 id="基于索引搜索的分配算法"><a href="#基于索引搜索的分配算法" class="headerlink" title="基于索引搜索的分配算法"></a>基于索引搜索的分配算法</h4><h5 id="快速适应算法"><a href="#快速适应算法" class="headerlink" title="快速适应算法"></a>快速适应算法</h5><p>快速适应算法:将空闲分区按照容量大小分类,并把常用大小的分区单独建立链表,并对多个链条设立管理索引链表.</p><ul><li>优点:查找效率高,根据长度分类,保证了内存分配结果的最优,不产生碎片</li><li>缺点:算法复杂,开销大,分配空间的时候以进程为单位,存在一定的浪费.<h5 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h5>在分配存储块时将一个大的存储块分裂成两个大小相等的小块，这两个小块就称为 <strong>“伙伴”</strong>,对于不同大小分区建立链表.<blockquote><p>伙伴系统规定分区的大小一定是2的k次幂,$n \le k \le m$,其中$2^n$是最小分区大小,$2^m$是最大分区大小,通常为整个内存<br>在系统运行中可能因为不断划分形成若干个不连续的空闲分区<br>内存管理模块保持有多个空闲块链表,空闲块大小为2的整数次幂</p></blockquote></li></ul><p><strong>内存分配</strong></p><ul><li>在程序启动的时候只有一个空闲块(整个内存)</li><li>当一个大小为n的进程申请内存的时候向上取2的整数次幂($2^n$)寻找空闲块,如果没有空闲块,则去$2^{n+1}$去寻找.</li><li>对于$2^{n+1}$大小的空闲分区,分出$2^n$用于分配,另一半加入管理$2^n$的链表中,这两个分区称为<strong>伙伴</strong></li><li>如果$2^{n+1}$大小的空闲分区不存在则依次类推</li></ul><p><strong>内存释放</strong><br>将被释放块与其伙伴合并成一个更大的空闲块,然后一直合并下去</p><h2 id="多道程序的内存管理–分页"><a href="#多道程序的内存管理–分页" class="headerlink" title="多道程序的内存管理–分页"></a>多道程序的内存管理–分页</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>分区的思路怎样都会导致碎片的出现,浪费空间,影响性能.如果把一个逻辑地址连续的程序分散存放到不连续的内存区域中,但保证正常运行,则级充分利用了空间,由可减少移动带来的开销.支持分页的硬件部件通常叫做MMU.</p><h3 id="纯分页系统"><a href="#纯分页系统" class="headerlink" title="纯分页系统"></a>纯分页系统</h3><ul><li>如果不具备页面交换功能,那么每次作业的时候必须<strong>将所有页面一次性装入到主存</strong>,如果空间不够,则必须等待.</li><li>优点:没有外碎片,每个内碎片也不超过页的大小</li><li>缺点:程序全部装入内存,空间开销大.<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3></li><li><strong>页</strong>: 在分页存储管理系统中把每个作业的地址空间分成一些大小相等的片,称之为<strong>页面或者页</strong>(<code>page</code>),从0开始编号,其大小通常是2的幂次方,常用大小为4KB.</li><li><strong>存储块</strong>: 在分页存储管理系统中,把主存的存储空间也分成了和页相同大小的片,这些片成为<strong>存储块</strong>,或称为<strong>页框</strong>,从0开始编号.</li><li><strong>页表</strong>: 装载进程空间中的页和内存空间中页框的映射的表,每一个进程都有一个.<h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><h4 id="一级页表的问题"><a href="#一级页表的问题" class="headerlink" title="一级页表的问题"></a>一级页表的问题</h4>如果内存很大,那么页表也会很大,占用内存多,实现复杂.<br>因此解决思路如下:</li><li>动态调入页表,只调入当前需用的部分页表项</li><li>多级页表<h4 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h4>将页表再进行分页,离散的将给个页表页面存放咋i不同物理块,然后再建立一张外部页表用来记录对应的物理块号,运行时调入一级页表,再动态调入页表,因为只调入所需页表,所以占用的空间少了.<h4 id="多级页表-1"><a href="#多级页表-1" class="headerlink" title="多级页表"></a>多级页表</h4>多级页表同理,每一级页表只指向下一个页表项所在地址,最后的页表指向实际的内存地址.但是页表级数增加,访存次数增加,降低效率.<h3 id="快表TLB"><a href="#快表TLB" class="headerlink" title="快表TLB"></a>快表TLB</h3>因为无论如何,页表至少需要访问两次内存,所以需要使用<code>Cache</code>装入部分常用页表项,这部分<code>Cache</code>叫做<strong>快表</strong>(<strong>TLB</strong>)<br>快表和Cache类似,地址转换原理和页表一样,就不赘述了.<h3 id="反置页表"><a href="#反置页表" class="headerlink" title="反置页表"></a>反置页表</h3>利用反置页表进行地址变换的步骤:</li><li>用<strong>进程标志符</strong>和<strong>页号</strong>去搜索反置页表</li><li>如果没有找到说明没有调入内存,产生中断.</li><li>如果检索到对应表项,则表项的序号i就是物理地址.</li></ul><p>反置页表之所以交反置页表,是因为普通页表是通过序号找内容,这是匹配内容找序号.</p><ul><li><strong>缺点</strong>: 因为反置页表通过物理地址排序,而虚拟地址不一定是连续,所以查询可能需要找遍整个页表,时间场</li><li><strong>优点</strong>: 页表存储空间大大减少</li></ul><h3 id="哈希页表"><a href="#哈希页表" class="headerlink" title="哈希页表"></a>哈希页表</h3><p>对于超过32位地址空间的常用方法是使用哈希页表,使用虚拟页号作为哈希是,哈希页表的每一条目都包裹一个链表,链表的每个结点哈希相同.每个元素包含三个域:</p><ul><li>虚拟页号,也就是hash 的key</li><li>映射的页框号</li><li>指向下一个元素的指针<br>因为可能存在<code>hash</code>冲突,所以要处理冲突.<h4 id="检索方法"><a href="#检索方法" class="headerlink" title="检索方法"></a>检索方法</h4></li><li>计算虚拟页号和进程标志符对应的<code>hashcode</code></li><li>域虚拟页号与链表中的每一个元素的第一个域比较</li><li>匹配则取出页框号</li><li>反之继续寻找</li></ul><h3 id="页的保护"><a href="#页的保护" class="headerlink" title="页的保护"></a>页的保护</h3><p>页式存储管理系统提供了两种方式:</p><ul><li>地址越界保护</li><li>在页表中设置保护位<h3 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h3></li></ul><p><strong>优点</strong></p><ul><li>不要求连续存储</li><li>解决外碎片</li></ul><p><strong>缺点</strong></p><ul><li>内碎片浪费</li><li>不适合大型应用</li></ul><h2 id="多道程序的内存管理–分段"><a href="#多道程序的内存管理–分段" class="headerlink" title="多道程序的内存管理–分段"></a>多道程序的内存管理–分段</h2><p><strong>方便编程</strong>:</p><ul><li>通常一个作业是由多个程序段和数据段组成(<code>.data</code>,<code>.bss</code>,<code>.text</code>),用户一般按照逻辑关系对作业分段,并能根据名字访问程序段和数据段</li></ul><p><strong>信息共享</strong>:</p><ul><li>共享是以信息的逻辑单位为基础.页是存储信息的物理单位,段是信息的逻辑单位.</li><li>页式管理中地址空间是一维的,主程序,子程序都顺序排列,共享共用子程序比较困难,一个共享过程可能需要几十个页面.(一个共享程序被多个进程共享,每个进程都有一个页表)</li></ul><p><strong>信息保护</strong></p><ul><li>页式管理中,一个页面可能装有两个不同的子程序段的指令代码,不能通过页面共享实现共享一个逻辑上完整的子程序或者数据块</li><li>段式管理中,可以以信息的逻辑单位进行保护</li></ul><p><strong>动态增长</strong></p><ul><li>实际应用中,某些段(数据段)会不断增长,分页能以实现</li></ul><p><strong>动态链接</strong></p><ul><li>动态链接在程序运行时才把主程序和要用到的目标程序链接起来</li></ul><h3 id="地址结构"><a href="#地址结构" class="headerlink" title="地址结构"></a>地址结构</h3><p><strong>段表</strong></p><ul><li>段表记录段与内存位置的对应关系</li><li>段表保存在内存中</li><li>段表的基址及长度由段表寄存器给出 </li><li><ul><li>$|段表基址|段表长度| \quad or \quad |STbase|STlen|  $</li></ul></li><li>访问一次物理内存需要方位两次内存(段表和内存)</li><li>逻辑地址由段和段内地址组成</li><li><ul><li>$|段号|段内地址| \quad or \quad |S_No|S_offset|  $<h3 id="地址变换机制"><a href="#地址变换机制" class="headerlink" title="地址变换机制"></a>地址变换机制</h3>根据逻辑地址的段号访问段表对应的项,如果段号比段表长度长就抛出异常.在段表内检索到相应项,将项的基址和段内地址拼接得到物理地址.</li></ul></li></ul><p><img src="%E6%AE%B5%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2.png" alt="段地址变换">  </p><h3 id="信息共享"><a href="#信息共享" class="headerlink" title="信息共享"></a>信息共享</h3><p><strong>可重入代码</strong></p><p>可重入代码称为<strong>纯代码</strong>,是允许多个进程访问的代码,该段代码只允许读,不允许写,以保证每个进程使用的代码完全相同.</p><h3 id="段页式存储结构"><a href="#段页式存储结构" class="headerlink" title="段页式存储结构"></a>段页式存储结构</h3><p>逻辑地址包含段号,页号和页内地址,先访问段表得到页表始址,再访问页表获得块号,和页内地址和块号拼接得到物理地址.<br><img src="%E6%AE%B5%E9%A1%B5%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2.png" alt="段页地址变换">  </p><h2 id="虚拟存储"><a href="#虚拟存储" class="headerlink" title="虚拟存储"></a>虚拟存储</h2><h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><ul><li><strong>时间局部性</strong>: 即一条指令的一次执行和下次执行,一条数据的一次访问和下次访问都集中在一个较短的时期内 </li><li><strong>空间局部性</strong>: 即当前指令和邻近的几条指令,当前访问的数据和邻近的数据都集中在一个较小的区域内</li></ul><p>根据上述局部性原理,我们就可以在装入程序的时候,不将全部读入到内存,只需要将当前需要执行的部分页或段读入到内存,就可开始执行.如果访问缺失再从外存调入.</p><h3 id="虚拟存储技术的特征"><a href="#虚拟存储技术的特征" class="headerlink" title="虚拟存储技术的特征"></a>虚拟存储技术的特征</h3><ul><li><strong>多次性</strong>:作业分成多次调入内存,因此在逻辑上,内存扩大了.</li><li><strong>对换性</strong>:允许在作业运行过程中进行换进换出,提高内存利用率(暂时用不到的数据换出内存,提高内存使用效率)</li><li><strong>离散型</strong>:物理内存分配的不连续,虚拟地址空间使用的不连续</li><li><strong>虚拟性</strong>:通过物理内存和快速外存相结合提供大范围的虚拟地址空间</li></ul><h3 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点</strong>:</p><ul><li>可在较小的内存中执行较大的程序</li><li>可在内存中容纳更多程序并发执行</li><li>不必影响编程时的程序结构</li><li>提供给用户的可用虚拟内存空间大于物理内存</li></ul><p><strong>缺点</strong>:</p><ul><li>虚拟内存实际上是外存的一部分,所以牺牲了CPU的速度</li><li>虚拟内存也不能无限制加大,32位的机器一次性能访问的地址最大也就4GB</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>虚拟存储技术就是将部分外存当作内存的中转站,将部分不常用的数据放进去,需要的时候直接拿出来,逻辑上内存就扩大了.使用覆盖的方法,将一个程序化为一个个相对独立的程序单位,再使用交换技术,保证常用的部分在内存中,不常用的覆盖就交换到外存里面.</p><h2 id="请求分页-段-系统"><a href="#请求分页-段-系统" class="headerlink" title="请求分页(段)系统"></a>请求分页(段)系统</h2><p>在分页(段)技术的基础上,增加了<strong>请求调页(段)功能</strong>,<strong>页面(段)置换功能</strong>所形成的页(段)式虚拟存储器系统.</p><p>它允许只装入若干页(段)就可运行程序,以后在硬件的支持下通过<strong>请求调页(段)功能</strong>和<strong>置换页(段)功能</strong>,陆续将要运行的页面(段)调入内存,同时把暂不运行的页面(段)交换到外存上,置换时以页(段)为单位.</p><h3 id="请求式分页系统"><a href="#请求式分页系统" class="headerlink" title="请求式分页系统"></a>请求式分页系统</h3><p>在运行作业之前,只需将当前需要的一部分页面装入内存,在需要其他页的时候,自动选择一些页交换到辅存去,再调入需要的页.</p><h3 id="页表项结构"><a href="#页表项结构" class="headerlink" title="页表项结构"></a>页表项结构</h3><p><strong>状态位</strong><br>用于指示该页是否已经进入内存,一般由操作系统来管理.如果对页表查询时,发现状态位为0,则发生缺页中断.</p><p><strong>修改位</strong><br>用于只是该页调入内存后是否被修改过,如果已经修改过,那么重新分配页框(物理内存)的时候,就必须将其写回辅存,如果没有修改过,丢弃即可.</p><p><strong>页框号</strong><br>指出该页对应的物理页框号</p><p><strong>访问字段</strong><br>当页面被访问过则置1,供后续页面置换算法再选择时作参考</p><p><strong>禁用高速缓存</strong><br>适用于内存映射I/O,如果禁用,则表示该地址对应I/O设备,CPU访问时循环等待外设的相应,而不是访问高速缓存.</p><p><strong>保护位</strong><br>指定所运行的访问,读,写,执行等,具体由设备自己决定.</p><h3 id="页面调入策略"><a href="#页面调入策略" class="headerlink" title="页面调入策略"></a>页面调入策略</h3><ul><li><strong>请求调页</strong>:只调入发生缺页异常时候的页面,实现简单,但不适合在初始化的时候使用,会发生多次异常,导致程序效率低下</li><li><strong>预调页</strong>:在发生缺页的时候,一次性调入该页和邻近的几个页,常在程序装入的时候使用</li></ul><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><h4 id="最佳算法-OPT-optimal"><a href="#最佳算法-OPT-optimal" class="headerlink" title="最佳算法 (OPT optimal)"></a><strong>最佳算法 (OPT optimal)</strong></h4><p>选择”未来不再使用”或者”在离当前最远位置上出现的”页面置换.<br>这只是一个<strong>理想</strong>情况,实际很难实现,但可以作业思想知道和评估依据.</p><h4 id="NRU-最近未使用页面置换算法"><a href="#NRU-最近未使用页面置换算法" class="headerlink" title="NRU 最近未使用页面置换算法"></a><strong>NRU 最近未使用页面置换算法</strong></h4><p>在最近的一个时钟周期内,淘汰最近没有被访问的页面.<br>根据修改位和访问字段来选择.</p><h4 id="FIFO-先进先出算法"><a href="#FIFO-先进先出算法" class="headerlink" title="FIFO 先进先出算法"></a><strong>FIFO 先进先出算法</strong></h4><p>总是选择最先装入内存的一页调出.<br>该算法通过链表实现,链表指针指向第一个进入的页.<br>该方法存在将常使用的页面丢掉的情况,产生<code>Bleady</code>现象</p><h4 id="二次机会页面置换算法"><a href="#二次机会页面置换算法" class="headerlink" title="二次机会页面置换算法"></a><strong>二次机会页面置换算法</strong></h4><p>对FIFO算法的改进,检查最老页面的R位,如果R为0则淘汰,反之则R复位,然后将这个页面放到链表的最后(相当于修改了FIFO中页的装入时间)</p><h4 id="时钟算法-CLOCK"><a href="#时钟算法-CLOCK" class="headerlink" title="时钟算法 CLOCK"></a><strong>时钟算法 CLOCK</strong></h4><p>该算法使用环形队列,就不需要将页放到链表末尾,直接指针向下走一位就行.</p><h4 id="页面缓冲算法-page-buffering"><a href="#页面缓冲算法-page-buffering" class="headerlink" title="页面缓冲算法 page buffering"></a><strong>页面缓冲算法 page buffering</strong></h4><p>对FIFO算法的发展,创立缓冲区缓冲被置换页面,有机会找回刚被置换的页面.</p><ul><li>对于被置换页表,根据其是否被修改,放入缓冲区中两个不同链表–<strong>空闲链表</strong>和<strong>已修改页面链表</strong>,如果被再次访问则放回内存.</li><li>当需要读入新的物理页面时,将新页面内容读入到空闲页面链表的第一项所指页面,然后将第一项删除</li><li>当已修改页面达到一定数目之后再将他们一起调入外存,,然后将他们归入空闲页面链表,减少I/O次数</li></ul><p>相当于空闲页链表就是缓冲区,记录最近的页面交换历史,当需要访问时先去缓冲区访问.</p><h4 id="最近最少使用算法-LRU"><a href="#最近最少使用算法-LRU" class="headerlink" title="最近最少使用算法 LRU"></a><strong>最近最少使用算法 LRU</strong></h4><p>当需要置换一页面时，选择在最近一段时间内最久不用的页面予以淘汰.<br>该算法思路最接近最佳算法,但实现困难.<br>实现如下:</p><ul><li>使用栈来维护信息,栈底是最久未使用的页面,如果页面使用则将其放置于栈顶.</li><li>全局保存一个自增计数器用来记录进程时间,每个页面配备一个计数器,当页面被访问,该页面的计数器被赋值成全局计数器的值,当淘汰页面的时候,淘汰最小的那个页面.</li></ul><h4 id="最不常用算法-NFU"><a href="#最不常用算法-NFU" class="headerlink" title="最不常用算法 NFU"></a><strong>最不常用算法 NFU</strong></h4><p>与LRU类似,页面记录自己被访问次数,淘汰次数最少的页面</p><h4 id="Aging算法"><a href="#Aging算法" class="headerlink" title="Aging算法"></a><strong>Aging算法</strong></h4><p>与NFU类似,但是计数器每个周期右移一位,最高位填入R位,使得最近的访问权重最大</p><h3 id="缺页异常处理"><a href="#缺页异常处理" class="headerlink" title="缺页异常处理"></a>缺页异常处理</h3><p><img src="%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.png" alt="缺页异常处理"><br>如果在访问页表的时候,该页没有装入内存,则抛出缺页异常,异常处理如下:</p><ul><li>和正常的异常处理一样,先保护重要信息于栈中,进入异常处理入口</li><li>找出虚拟地址对应的页地址</li><li>查找是否有空页框,如果有,则直接调入其中并更新页表.</li><li>如果没有,则使用相应算法置换出一个页框</li><li>恢复现场,线程重新执行</li></ul><h2 id="工作集与驻留集"><a href="#工作集与驻留集" class="headerlink" title="工作集与驻留集"></a>工作集与驻留集</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><strong>工作集</strong>: 近期使用过的页面集合</li><li><strong>驻留集</strong>: 每个进程调入到内存的页面集合.<h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3>进程再任一时间t,都存在一个集合,包含所有最近k次内存访问过的页面,这个集合称为<strong>工作集</strong>.</li></ul><p>根据时间局部性原理,如果能预测未来某段时间将要访问的也米娜,并提前调入内u了,那么就能提高效率.工作集就是依据进程过去一段时间内访问的页面调整常驻集大小.</p><p>根据局部性原理,我们知道,随着访问次数的增减,内存访问的局部性区域趋向稳定,如果局部性区域改变,工作集也能逐渐过渡到下一个稳定值.</p><p>该集合的建立可以建立一个二元函数$W(\Delta,t)$其中$\Delta$为时间窗口大小,函数值表示再时间$[t-\Delta,t]$内访问的页面集合,函数$W$关于$\Delta$只增不减,$|W(\Delta,t)|$指工作集大小即页面数目.</p><ul><li>监视每个进程的工作集</li><li>周期性地从一个进程的驻留集中移去那些不在它的工作集中的页</li><li>只有当一个进程的工作集在内存中时，才可以执行<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3>碰到缺页异常的时候,遍历整个页表,如果页表最近没有用过,则判断其是否在工作集内,如果在则去找下一个页面,不然就替换调.<h3 id="WSClock算法"><a href="#WSClock算法" class="headerlink" title="WSClock算法"></a>WSClock算法</h3><code>Clock</code>算法加上工作集算法,使用循环链表,就不需要遍历整个页表了.<br>工作流程:</li><li>发生缺页异常,检查当前指针指向的页面</li><li>如果最近使用过,则不淘汰,指针向下走</li><li>如果没有使用过,判断其是否在工作集,不在工作集,判断是否被修改过,没有修改过则直接替换,修改过则异步写入磁盘,然后寻找下一个没有改过的老页面.</li><li>如果一直没有找到老的干净页面,则说明都在工作集(有不在的话,因为异步写入,则其变成干净的老页面了),则随机替换一个.</li></ul><h3 id="页面置换策略"><a href="#页面置换策略" class="headerlink" title="页面置换策略"></a>页面置换策略</h3><h4 id="全局置换"><a href="#全局置换" class="headerlink" title="全局置换"></a>全局置换</h4><p>出些缺页异常且进程空闲物理块用完,测从内存中选择一块调出,该块可能属于其他进程</p><h4 id="局部置换"><a href="#局部置换" class="headerlink" title="局部置换"></a>局部置换</h4><p>出些缺页异常且进程空闲物理块用完,则从进程的物理块中选一块替换</p><h3 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h3><p>随着进程的并发数增加,处理器的利用率先上升后下降,这种现象称为抖动.因为并发数太多,每一个进程的驻留集太小,缺页率太高,频繁抛出缺页异常,导致整个线程陷入了I/O,cpu工作占用很低.</p><h4 id="抖动的预防和消除"><a href="#抖动的预防和消除" class="headerlink" title="抖动的预防和消除"></a>抖动的预防和消除</h4><ul><li>局部置换策略 (局部置换策略不会占用其他线程的空间)</li><li>引入工作集算法</li><li>预留部分页面</li><li>挂起若干线程</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统_启动</title>
      <link href="/2022/03/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%90%AF%E5%8A%A8/"/>
      <url>/2022/03/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>OS的启动是一个很矛盾的事情,OS启动需要把OS放入内存,把代码放入内存需要OS调度,这就是鸡生蛋蛋生鸡的故事().因此,OS的启动需要硬件层面的帮助,它叫BootLoader.它负责运行第一段软件代码.</p><h2 id="内存划分"><a href="#内存划分" class="headerlink" title="内存划分"></a>内存划分</h2><p>在32位MIPS中,一次性能访问的空间是4GB <del>(真小呀,怪不得现在都是64位,这打个游戏就爆内存了吧)</del>.从上到下分为:<br><img src="images/4f82685665a0d39f66b0bd02880b221cc4cd45bc7d8d2c4da4f3cb567a226b1a.png" alt="内存划分">  </p><ul><li><strong>kseg2</strong> 是mapped的内存空间,访问需要通过MMU模块转换.</li><li><strong>kseg1</strong> 既没有mapped,也没有cached,所以它能在cache和MMU都没有初始化的时候使用.只需要去掉高三位地址就能实现地址映射使用.</li><li><strong>kseg0</strong> 没有mapped,所以在初始化cache之后就能使用.只需要去掉最高位地址就能实现地址映射使用.</li><li><strong>kuseg</strong> 是用户能使用的空间.</li></ul><p>通过上面的分析我们知道,在刚开电的时候只有<code>kseg1</code>和<code>kseg0</code>能使用,另外两个都需要<code>MMU</code>和<code>cache</code>初始化之后才能用,但是等这俩初始化完,os早就能用了.</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><h3 id="硬件检测"><a href="#硬件检测" class="headerlink" title="硬件检测"></a>硬件检测</h3><p>这一步是计算机检测自己的硬件是否符合开机的要求,内存能用吗,<code>I/O</code>设备还好吗,<code>CPU</code>醒了没.这一步在<code>X86</code>体系使用的是<code>BIOS</code> <del>(应该都听说过,一个合格的垃圾佬肯定折腾过自己电脑的bios)</del> .这段代码存在<code>ROM</code>(Read Only Memory),它和<code>RAM</code>最大的区别就是断电之后不会消失(不是用的电容存信息),所以存放<code>bios</code>正合适.因为直接使用的<code>ROM</code>,所以更倾向于将其看成硬件结构,而不是软件,也常称作<code>bios</code>芯片.</p><h3 id="读取MBR"><a href="#读取MBR" class="headerlink" title="读取MBR"></a>读取MBR</h3><h4 id="MBR介绍"><a href="#MBR介绍" class="headerlink" title="MBR介绍"></a>MBR介绍</h4><p><code>MBR(Master Boot Record)</code>主引导目录,存放了预启动信息,分区表信息.这里存了操作系统的<code>bootloader</code>.<br>其446bytes存的是<code>BootLoader</code>,之后64bytes的分区表,之后是2bytes的魔数(bios检查这个来判断是否是一个分区的硬盘).<br>64bytes中每16bytes是一个分区的入口,所以一共有四个分区.也就是说一个系统最多四个入口.</p><h4 id="分区介绍"><a href="#分区介绍" class="headerlink" title="分区介绍"></a>分区介绍</h4><p>磁盘有三种分区,主磁盘分区,扩展磁盘分区,逻辑分区.</p><ul><li>一个系统最多四个主分区,最少一个主分区,主分区用于存储系统.只能有一个主分区处于active状态,其余为inactive,便于boot选择系统.</li><li>一个系统最多一个扩展磁盘分区,主分区和扩展分区之和最多不超过四个.</li><li>逻辑分区可以有若干个.逻辑分区可以认为是扩展分区的子集.<br>对于磁盘一般分出主分区存系统之后,剩余空间全部都是扩展分区,对于扩展分区一般分成多个逻辑分区.</li></ul><h3 id="Run-BootLoader"><a href="#Run-BootLoader" class="headerlink" title="Run BootLoader"></a>Run BootLoader</h3><p>那么读取了MBR之后,找到了<code>BootLoader</code>,接下来就应该<code>run</code>了.该段代码用于初始化硬件设备,建立内存空间的映射,为<code>os</code>做好准备.</p><h4 id="运行引导程序"><a href="#运行引导程序" class="headerlink" title="运行引导程序"></a>运行引导程序</h4><p><strong>首先</strong>读入主引导记录至<code>7C00H</code>处,运行主引导程序.其任务包括</p><ul><li>检查(<code>WORD</code>)<code>0x7dfe</code>是否等于<code>0xaa55</code></li><li>跳转到<code>0x7c00</code>运行<code>MBR</code>中程序</li><li>将自己复制到<code>0</code>x0600`处,继续执行</li><li>搜索主分区表中标志位<code>active</code>的分区</li><li>将活动分区的第一个扇区(<code>boot sector</code>)读入<code>0x7c00</code></li><li>检查<code>WORD</code>是否等于<code>0xaa55</code></li><li>运行该扇区的指令(<code>bootsect.s</code>),该函数的运行在下一个title中详解</li></ul><h3 id="加载内核"><a href="#加载内核" class="headerlink" title="加载内核"></a>加载内核</h3><p><strong>bootsect.s的工作流程如下:</strong></p><ul><li>首先将自身从原始启动区<code>0x7c00-0x7dff</code>移动到<code>0x90000-0x901ff</code></li><li>读引导扇区的后四个扇区到<code>0x90200</code>,调用引导阶段函数</li><li>设置一些参数,比如堆栈基址.磁盘参数表</li><li>加载内核映像.如果是大内核就加载到<code>0x100000</code>,否则加载到<code>0x10000</code></li><li>跳转到<code>Setup</code>的入口点</li></ul><p><strong>setup.s的工作:</strong></p><ul><li>初始化硬件设备</li><li>为内核程序的执行家里环境</li><li>如果内核镜像在0x10000处,则将其移动到0x1000.</li><li>跳转到<code>startup_32()</code>汇编程序</li></ul><p><strong>Head.s的工作(第一个start_32()函数)</strong></p><ul><li>初始化段寄存器和临时堆栈.</li><li>清除<code>efags</code>寄存器的所有位</li><li>将<code>_edata</code>和<code>_end</code>区间的所有内核未初始化区填充0</li><li>调用<code>decompress_kernal()</code>函数解压内核映像,并将其移动到<code>0x100000</code>处.</li><li>跳转到<code>0x100000</code>物理内存处执行.</li></ul><p><strong>Head.s的工作(第二个start_32()函数)</strong></p><ul><li>因为这是在<code>0x100000</code>地址的函数,所以相同的函数名没有什么问题(类似于c语言两个同名函数但是在不同工程里面),该函数用于为第一个Linux进程建立执行环境</li><li>初始化段寄存器的最终值</li><li>0填充内核的<code>bss</code>段</li><li>初始化<code>swapper_pg_dir</code>数组和<code>pg0</code>包含的临时内核页表</li><li>建立进程<code>0idle</code>进程的内核模式的堆栈.</li><li>……</li><li>跳转到<code>start_kernal</code>函数,这个函数是第一个C编制的函数.</li></ul><p><strong>Start_kernal()的工作</strong></p><ul><li>这个函数用于启动初始化函数初始化各种设备,完成<code>Linux</code>核心环境的建立</li><li><code>sched_init()</code>初始化调度器</li><li><code>build_all_zonelists</code>函数初始化内存区</li><li>调用<code>page_alloc_init()</code>和<code>mem_init()</code>初始化伙伴系统分配器</li><li>调用<code>trap_init()</code>和<code>init_IRQ()</code>对中断控制表IDT进行最后的初始化</li><li>…<br>至此Linux内核单减完成,基于Linux的程序可以正常运行了.</li></ul><h3 id="用户层init依据inittab文件设定运行等级"><a href="#用户层init依据inittab文件设定运行等级" class="headerlink" title="用户层init依据inittab文件设定运行等级"></a>用户层init依据inittab文件设定运行等级</h3><p><strong>Linux的运行等级划分:</strong></p><ul><li>0:关机</li><li>1:单用户模式</li><li>2:无网络支持的多用户模式</li><li>3:有网络支持的多用户模式</li><li>4:未使用的等级</li><li>5:有网络支持有X_Window支持的多用户模式</li><li>6:重启</li></ul><h3 id="执行rc-sysinit"><a href="#执行rc-sysinit" class="headerlink" title="执行rc.sysinit"></a>执行rc.sysinit</h3><p>该文件主要用于初始化一些软件层面的事情,比如<code>PATH</code>的配置,网络配置等.</p><h3 id="启动内核模块"><a href="#启动内核模块" class="headerlink" title="启动内核模块"></a>启动内核模块</h3><p>该步骤用于装载内核模块,<code>Linux</code>全面接手后续工作</p><h3 id="执行脚本程序"><a href="#执行脚本程序" class="headerlink" title="执行脚本程序"></a>执行脚本程序</h3><p>根据运行级别不同,系统执行从<code>rc0.d</code>到<code>rc6.d</code>中的相应脚本程序,完成初始化和启动服务.</p><h3 id="执行rc-local-可选"><a href="#执行rc-local-可选" class="headerlink" title="执行rc.local(可选)"></a>执行rc.local(可选)</h3><p>此处是用户自定义的模块,类似开机自启动项.</p><h3 id="执行login程序-进入登录状态"><a href="#执行login程序-进入登录状态" class="headerlink" title="执行login程序,进入登录状态"></a>执行login程序,进入登录状态</h3><p>进入这一步,计算机算完成了的开机工作,硬件层面的通电,到<code>MMU</code>,<code>Cache</code>的建立,时钟频率等的计算,内核装载并开始进行服务,接下来就等着用户输入密码,开始使用这台电脑大干一番了.</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这篇博客充满着很多我看不懂的词汇,一些函数名字,一些看不懂的名词,OS的学习和OS启动一样矛盾.学习现代OS,哪就不得不使用这些概念,但是学习这些概念,那就不得不到OS学习的后期.就好像游戏一个后期boss给你拉到前台溜了一圈,玩家觉得头疼.这些暂且写着存在着,等后期学明白了就应该会明白吧.</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax的爬取</title>
      <link href="/2022/03/13/Ajax%E7%9A%84%E7%88%AC%E5%8F%96/"/>
      <url>/2022/03/13/Ajax%E7%9A%84%E7%88%AC%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<h2 id="ajax介绍"><a href="#ajax介绍" class="headerlink" title="ajax介绍"></a>ajax介绍</h2><p><code>ajax</code>全成<code>Asynchronous JavaScript and XML</code>称为异步的<code>js</code>和<code>XML</code>,是一种异步加载信息的方法.在获取了原始<code>HTML</code>后,对于其中的数据是通过发送Ajax请求获取的,这样能减轻渲染网页的工作量.</p><h2 id="ajax基本原理"><a href="#ajax基本原理" class="headerlink" title="ajax基本原理"></a>ajax基本原理</h2><ul><li>新建<code>XMLHttpRequest</code>对象<code>xmlhttp</code></li><li>调用<code>onreadystatechange</code>属性,设置监听.</li><li>使用<code>open</code>和<code>send</code>方法发送请求</li><li><code>onreadystatechange</code>属性监听到请求之后使用方法进行解析.</li><li>在解析完内容之后,就可以开始渲染了,比如修改<code>HTML</code>中的内容.</li></ul><h2 id="爬取"><a href="#爬取" class="headerlink" title="爬取"></a>爬取</h2><p>在<code>F12</code>的模式下,发现<code>ajax</code>和其他请求类似,只不过请求的返回时<code>json</code>文件.</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OO_Unit1_表达式的展开</title>
      <link href="/2022/02/28/OO_Unit1_%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%B1%95%E5%BC%80/"/>
      <url>/2022/02/28/OO_Unit1_%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%B1%95%E5%BC%80/</url>
      
        <content type="html"><![CDATA[<h2 id="BNF描述"><a href="#BNF描述" class="headerlink" title="BNF描述"></a>BNF描述</h2><p>BNF描述中去除了所有的空白项便于解析<br>如下是三次作业总共的BNF图:<br>$$\begin{aligned}<br>表达式 &amp;\rightarrow[加减] 项| 表达式 加减项\\<br>项 &amp;\rightarrow [加减] 因子 | 项’*’因子\\<br>因子 &amp;\rightarrow​ 变量因子 | 常数因子 | 表达式因子\\<br>变量因子 &amp;\rightarrow 幂函数 | 三角函数 | 自定义函数调用 | 求和函数\\<br>常数因子 &amp;\rightarrow​ 带符号的整数\\<br>表达式因子 &amp;\rightarrow​ ‘(‘ 表达式 ‘)’ [指数]\\<br>幂函数 &amp;\rightarrow (函数自变量|’i’) [指数]\\<br>三角函数 &amp;\rightarrow ‘sin’’(‘因子’)’ [指数] | ‘cos’’(‘因子’)’ [指数]\\<br>指数 &amp;\rightarrow ‘**’[‘+’] 允许前导零的整数\\<br>带符号的整数 &amp;\rightarrow [加减] 允许前导零的整数\\<br>允许前导零的整数 &amp;\rightarrow (0|1|2|…|9){0|1|2|…|9}\\<br>加减 &amp;\rightarrow ‘+’ | ‘-‘<br>\end{aligned}$$</p><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>$$读入输入 \rightarrow 解析输入 \rightarrow 简化表达式 \rightarrow 输出表达式$$</p><h2 id="抽象结构"><a href="#抽象结构" class="headerlink" title="抽象结构"></a>抽象结构</h2><h3 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h3><p>从上面的<code>BNF</code>中,我们可以初步提取出下面的类:</p><ul><li>表达式类(是一个加法函数,由项类组成)</li><li>项类(是乘法函数,由表达式组成)</li><li>因子类</li></ul><p>其中因子类又包含:</p><ul><li>变量因子</li><li>表达式因子</li><li>常数因子</li></ul><p>我们发现因子又包含了表达式,表达式又由项组成,因此,我们可以将因子认为是所有类的最顶层模块,可能是接口,可能是父类.<br>再细看要求,题目要求<code>simpilify</code>这一个动作,<code>simplify</code>可以将其拆分为各个类将自己的组成成分化简,和类之间的合并.因此,对这一个行为进行抽象,<strong>因子就是所有类的接口</strong>.<br>另外,对表达式类和项类这两个特殊类进行观察,能发现这两者不仅要合并其他类,还要将自己类包含的项或者因子进行合并.因此我们将这两者抽象出来一个新的<strong>父类</strong>,该父类有一个<strong>属性用来保存该类的组成部分</strong>,还要有一个<strong>合并因子的函数用于合并因子</strong>,另外还要有一个判断是否符合合并要求的方法<strong>留给子类自己重写</strong>,让子类控制合并行为.</p><p>因此我们的基本的<code>UML</code>图如下(Factors指代除了表达式因子的因子们):<br><img src="%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84.png" alt="基础架构">  </p><p>但是,其中自定义函数和求和函数是第二次作业提出,这两个函数涉及到形参换成实参,并且函数之间相等的判断也特别复杂,因此我的思路是在<strong>解析阶段就完成形参实参替换</strong>,并把字符串替换结果交给第一次作业就已经实现的解析函数,将解析函数的返回值返回给上层函数,完成对函数的解析,因此这两个类不放入表达式化简过程,而是将其<strong>在解析阶段完成解析</strong>.</p><p>最终我们的<code>UML</code>图如下(只列出重要的函数):<br><img src="%E6%9C%80%E7%BB%88%E6%9E%B6%E6%9E%84.png" alt="最终架构">  </p><p><strong>函数解释</strong></p><ul><li><code>FuncParse</code>是解析输入的自定义函数定义的类,<code>parseDiyFunc</code>方法返回一个<code>DiyFunc</code>对象.</li><li><code>DiyFunc</code>和<code>SumFunction</code>的<code>transmission</code>方法是处理输入的自定义函数调用或者求和函数,返回替换之后的字符串.</li><li><code>Poly</code>的<code>margeAble</code>方法是一个抽象方法,留给<code>Expr</code>和<code>Term</code>类自己重写,自定义什么情况两者算同类相,需要合并.</li><li><code>Factor</code>的<code>merge</code>方法是实现接口的类和自己同类型相互合并的方法,该方法不修改对象本身,而是返回一个新的对象.</li></ul><p>对于第三次作业提出的嵌套函数,我也在保留原有架构的基础上,使用的是自下而上的递归实现字符串替换.</p><p>原有函数解析架构:</p><ul><li>读取函数定义,储存函数的形参,函数名和表达式</li><li>读取函数调用,获得实参</li><li>建立实参和形参之间的<code>hashtable</code></li><li>遍历表达式,将形参转换成实参</li></ul><p>自下而上的递归实现就是<br>在获得实参的时候,调用parseTerm函数去解析,最后将Term的String输出当作实参,这样不论是参数里面的嵌套调用还是求和函数求和因子里面的嵌套调用都能解决.</p><h3 id="细节实现"><a href="#细节实现" class="headerlink" title="细节实现"></a>细节实现</h3><h4 id="连续正负号"><a href="#连续正负号" class="headerlink" title="连续正负号"></a>连续正负号</h4><p>在本题中连续正负号是一个很大的问题,因此我虽然抽象Expr类为加法函数,但我parseExpr并不处理正负号,我把连续正负号当作连续正负1相乘,这样就是带符号整数,变成因子了,交给parseTerm来统一处理</p><h4 id="化简"><a href="#化简" class="headerlink" title="化简"></a>化简</h4><p>对于简单因子的简化没什么好说的,提一下Term类的合并同类项.</p><p>我使用的是Arraylist,没有使用<code>hashmap</code>,所以我合并因子的方法是先将每一个因子化简,其中常量特别提出来,放到第0个位置,这样除此化简之后,我的项结构如下:</p><p>$$C<em>f_1</em>f_2 \cdots *f_n$$</p><p>其中$C$是常量,如果化简后因子中有表达式因子,那么就需要开括号,不然直接就去把同类项相乘.</p><p>开括号创建函数<code>unfold</code>.该函数的实现是基于乘法分配律,既</p><p>$$(A+B)<em>(C+D) = A</em>C+A<em>D+B</em>C+B*D$$</p><p>我们可以看到实际就是表达式将自己的项依次拿出来,两个因子合并成为新的因子.<br>因此整个Term的化简流程如下:</p><h2 id="随机数据生成器"><a href="#随机数据生成器" class="headerlink" title="随机数据生成器"></a>随机数据生成器</h2><p>前两次作业我写了随机数据生成器和基于python和sympy的对拍工具,第三次作业因为嵌套的引入,使得数据生成时候解析成sympy能使用的格式时工作加大,于是放弃,只将自己的parse结果和最后的输出进行对拍,对化简进行单元测试.三次作业随机数据生成器都是基于递归下降,现在简单总结一下:</p><ul><li>第一次作业,也是最简单的作业,基于给的BNF还是很好写的,就不赘述了.</li><li>第二次作业,我原本时在第一次上进行迭代的,但是第二次作业引入了新的自定义函数,自定义函数生成的时候有很多对因子的限制,导致我不得不使用很多变量来限制生成数据时候的选择,比如函数生成时变量的改变,求和函数的求和因子不能时表达式因子等.</li><li>第三次作业,规则引入更多,而之前的数据生成器已经是300行的屎山代码了,因此我重构代码,引入了DiyFunc和SumFunc两个类来生成自己的数据,做到表达式,自定义函数和求和函数生成的低耦合,再重写__str__方法,直接输出即可.另外对于项的总数和因子总数等也可以定义为全局变量,可以很好的自己控制数据复杂度.<br>基本架构如下:(对于递归深度的控制并没有写入,但难度并不大,请读者自行思考)<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> random <span class="token keyword">import</span> randint<span class="token keyword">def</span> <span class="token function">getExpr</span><span class="token punctuation">(</span>numofTerm <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    ret <span class="token operator">=</span> <span class="token string">""</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>numofTerm <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        ret <span class="token operator">=</span> getAddorSub<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    ret <span class="token operator">+=</span> getTerm<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>numofTerm<span class="token operator">&lt;</span> maxTerm <span class="token keyword">and</span> randint<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">50</span><span class="token operator">+</span>numofTerm<span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        ret <span class="token operator">+=</span> getAddorSub<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        ret <span class="token operator">+=</span> getExpr<span class="token punctuation">(</span>numofTerm<span class="token operator">=</span>numofTerm<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> ret<span class="token keyword">def</span> <span class="token function">getTerm</span><span class="token punctuation">(</span>numoFactor <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    ret <span class="token operator">=</span> <span class="token string">""</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>numoFactor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        ret <span class="token operator">+=</span> getAddorSub<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    ret <span class="token operator">+=</span> getFactor<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>numoFactor<span class="token operator">&lt;</span> maxFactor <span class="token keyword">and</span> randint<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">50</span><span class="token operator">+</span>numoFactor<span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        ret <span class="token operator">+=</span> <span class="token string">"*"</span>        ret <span class="token operator">+=</span> getTerm<span class="token punctuation">(</span>numoFactor<span class="token operator">=</span>numoFactor<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> ret<span class="token keyword">def</span> <span class="token function">getFactor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    op <span class="token operator">=</span> randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>op <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment">##常数因子</span>        <span class="token keyword">return</span> <span class="token builtin">str</span><span class="token punctuation">(</span>randint<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">elif</span><span class="token punctuation">(</span>op <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment">##变量因子</span>        <span class="token keyword">return</span> getVar<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">elif</span><span class="token punctuation">(</span>op <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment">## 表达式因子</span>        ret <span class="token operator">=</span> <span class="token string">"("</span> <span class="token operator">+</span> getExpr<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">")"</span>        ret <span class="token operator">+=</span> getIndex<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>对于对拍,我使用的了subprocess(),这样就不需要额外生成文件也能获得程序输出,大概用法如下<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> subprocesssb <span class="token operator">=</span> subprocess<span class="token punctuation">.</span>Popen<span class="token punctuation">(</span>command<span class="token punctuation">,</span>stdout<span class="token operator">=</span>subprocess<span class="token punctuation">.</span>PIPE<span class="token punctuation">,</span>stdin<span class="token operator">=</span>subprocess<span class="token punctuation">.</span>PIPE<span class="token punctuation">)</span>sb<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token builtin">bytes</span><span class="token punctuation">(</span><span class="token string">"3\n"</span><span class="token punctuation">,</span>encoding <span class="token operator">=</span> <span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>sb<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token builtin">bytes</span><span class="token punctuation">(</span><span class="token string">"f(x,y,z)="</span><span class="token operator">+</span>F<span class="token punctuation">.</span>expr<span class="token operator">+</span><span class="token string">"\n"</span><span class="token punctuation">,</span>encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>sb<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token builtin">bytes</span><span class="token punctuation">(</span><span class="token string">"g(x,y,z)="</span><span class="token operator">+</span>G<span class="token punctuation">.</span>expr<span class="token operator">+</span><span class="token string">"\n"</span><span class="token punctuation">,</span>encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>sb<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token builtin">bytes</span><span class="token punctuation">(</span><span class="token string">"h(x,y,z)="</span><span class="token operator">+</span>H<span class="token punctuation">.</span>expr<span class="token operator">+</span><span class="token string">"\n"</span><span class="token punctuation">,</span>encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>sb<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token builtin">bytes</span><span class="token punctuation">(</span>ExprToJava<span class="token punctuation">,</span>encoding <span class="token operator">=</span> <span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sb<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>outText <span class="token operator">=</span> sb<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"Mode: Normal\r"</span><span class="token punctuation">,</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span> sb<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>最后正确性检验,sympy检验代码如下<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> sympify<span class="token punctuation">(</span>expr1 <span class="token operator">-</span> expr2<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"True"</span><span class="token punctuation">)</span><span class="token keyword">else</span> <span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Wrong Answer"</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Answer"</span> <span class="token operator">+</span> simplify<span class="token punctuation">(</span>expr1<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="debug总结"><a href="#debug总结" class="headerlink" title="debug总结"></a>debug总结</h2><h3 id="个人bug发现"><a href="#个人bug发现" class="headerlink" title="个人bug发现"></a>个人bug发现</h3>个人整个作业完成下来,最严重的两个bug分别是对象引用的问题和-1这个因子解析的问题,下面做分析</li><li><strong>类引用的问题</strong>:<code>java</code>对于对象是引用,所以如果两个变量实际是指向同一个对象,那么就会出现神奇的bug.比如(sin(x)**2+cos(x)*sin(x))**2,本来按照乘法分配律展开是<br>$$sin(x)*<em>2</em>sin(x)**2 + 2 * sin(x)*<em>2</em>cos(x)*sin(x)+cos(x)*sin(x)*cos(x)*sin(x)$$<br>式中$sin(x)**2$都指向的是同一个对象,所以第一个$sin(x)*<em>2</em>sin(x)**2$化简的时候,后面所有的$sin(x)**2$全部变成了$sin(x)**4$,对此我的方法是把所有因子变成不可变对象,<code>merge</code>方法得返回值不是原本得对象,而是重新<code>new</code>了一个,每一个因子都没有<code>set</code>方法,这样因子的状态就不会改变了.</li><li><strong>-1的解析</strong>:在我的架构中<code>-1</code>解析成了<code>-1*1</code>,也就是说输入的每一个带符号整数,在定义中是属于因子,到我的架构里面其实是一个项,但是在后续作业中我忘记了这一个区别,导致抛出了异常.<h3 id="互测bug发现"><a href="#互测bug发现" class="headerlink" title="互测bug发现"></a>互测bug发现</h3>在互测中发现了一些很有意思的bug,先列举几个很有意思的.</li><li><strong>过度优化导致牺牲正确性</strong>:后面作业互测中发现了有同学优化了<code>cos(x)**2+sin(x)**2 = 1</code>,这本来是一个很厉害的优化,但是在实际互测中发现有同学的优化是基于原有架构上的拆东墙补西墙,把原本架构的一些细节改变,但没有填补.比如第三次作业,三角函数中可以放表达式因子,那么在判断是否能优化的时候就要判断三角函数里面的因子是否相等,因此有人又修改了表达式因子的equals方法,但这又导致了在项合并同类项中表达式因子合并出现了bug.因此,我认为优化应该是基于能完成需求的基础上,不能为了优化而去优化.</li><li><strong>放弃优化导致牺牲时间复杂度</strong>:我也碰见了有的同学放弃了合并同类项,导致输出巨长,放一个比较复杂的数据,因为没有合并同类项,导致在开括号的时候项一级的因子越来越多,如果指数大一点就直接跑不出结果了.<h2 id="总体总结"><a href="#总体总结" class="headerlink" title="总体总结"></a>总体总结</h2><del>总结之前先来一张全家福</del><br><img src="%E7%B1%BB%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.png" alt="类的复杂度分析"><br>可见我的复杂度还行(),项和表达式因为组成复杂,优化有一点难度,至于parse,因为因子太多不得不塞很多函数进去,能做成这样还是比较满意的.<br>整个作业自我感觉除了第一次比较艰难,后面都挺轻松.可能是我第一次在架构上拓展性比较强,没有仅为了实现第一次的需求而去建立架构,而是留了很多可拓展的地方,<br>比如:</li><li>第一次作业我就已经能解决嵌套括号的问题</li><li>对于新增加的因子我也有了一套比较完整的实现模型</li><li>对于新增因子的合并我在项和表达式一级也解开了耦合,让这两个类能更好的自己控制合并同类项这一个行为.</li></ul><p>可见架构的可拓展性对于后续开发的重要性</p>]]></content>
      
      
      <categories>
          
          <category> 面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>马尔科夫链蒙特卡洛法学习笔记</title>
      <link href="/2022/02/17/%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E9%93%BE%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/02/17/%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E9%93%BE%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="马尔科夫链蒙特卡洛法"><a href="#马尔科夫链蒙特卡洛法" class="headerlink" title="马尔科夫链蒙特卡洛法"></a>马尔科夫链蒙特卡洛法</h1><h2 id="蒙特卡洛法"><a href="#蒙特卡洛法" class="headerlink" title="蒙特卡洛法"></a>蒙特卡洛法</h2><h3 id="抽样方法"><a href="#抽样方法" class="headerlink" title="抽样方法"></a>抽样方法</h3><p>蒙特卡洛法的抽样方法本质就是一个间接抽样方法,比如目标分布<code>p(x)</code>不可以直接抽样,但是<code>q(x)</code>容易抽样,那么可以设定$a(x) = \frac{p(x)}{q(x)}$为拒绝分布,堆<code>q(x)</code>的分布进行抽样,然后再以<code>a(x)</code>的概率接受这次抽样,<code>1-a(x)</code>的概率拒绝抽样,这么最后的结果就是分布<code>p(x)</code>.</p><p>也叫<strong>接受-拒绝抽样法</strong></p><h3 id="数学期望估计"><a href="#数学期望估计" class="headerlink" title="数学期望估计"></a>数学期望估计</h3><p>$$E_{p(x)}[f(x)] =\underset{n \rightarrow \infty }{\lim}  \frac{1}{n}\displaystyle \sum_{i=1}^n f(x_i)$$</p><p><code>p(x)</code>是概率密度函数,<code>f(x)</code>是定义在<em>X</em>上的函数,抽取n个样本$x_1,…,x_n$,计算出样本均值$\bar f_n =\frac{1}{n}\displaystyle \sum_{i=1}^n f(x_i)$</p><h3 id="积分计算"><a href="#积分计算" class="headerlink" title="积分计算"></a>积分计算</h3><p>用样本均值的计算代替积分运算.如果$h(x) = f(x)p(x)$,那么$\int_xh(x) d(x) = \int_xf(x)p(x) d(x) = E_{p(x)}[f(x)]$</p><h2 id="马尔科夫链"><a href="#马尔科夫链" class="headerlink" title="马尔科夫链"></a>马尔科夫链</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>满足下列性质的随机序列称为n阶马尔科夫链.<br>$$P(X_t|X_0,…,X_{t-1}) = P(X_t|X_{t-1}…X_{t-n})$$<br>其中n=1称为一阶马尔可夫</p><h3 id="离散状态马尔科夫链"><a href="#离散状态马尔科夫链" class="headerlink" title="离散状态马尔科夫链"></a>离散状态马尔科夫链</h3><p>离散状态马尔科夫链$X={X_0,…X_n}$,随机变量$X_t$定义在离散空间S中,转移概率分布可以由矩阵表示.<br>$$P = (p_{ij}) = P(X_t=i|X_{t-1} = j)$$<br>且$\displaystyle \sum p_{ij} = 1$<br>考虑马尔科夫链在时刻t的概率分布称为<strong>时刻t的状态分布</strong>,记作<br>$$\pi(t) = \begin{bmatrix}<br>    \pi_1(t)\<br>    \vdots\<br>    \pi_n(t)<br>\end{bmatrix}$$<br>其中$\pi_i(t) = P(X_t = i)$<br>如果在状态空间S上存在这样一个分布:<br>$$\pi = P\pi$$<br>则称$\pi$为马尔科夫链X的平稳分布,其意义是以平稳分布作为起始分布,那么之后任何一个时刻都是该平稳分布.</p><h3 id="连续状态的马尔科夫链"><a href="#连续状态的马尔科夫链" class="headerlink" title="连续状态的马尔科夫链"></a>连续状态的马尔科夫链</h3><p>连续状态马尔科夫链$X = {X_0,…,X_n}$随机变量$X_t$定义在连续空间S,转移概率分布由概率转移或转移核表示.<br>设S是连续空间,对任意$x \in S, A \subset S$,转移核P(x,A)表示$P(X_t \subset A | X_{t-1} = x )$定义为<br>$$P(x,A) = \int_A p(x,y)dy$$<br>同理,其也有平稳分布.<br>$$\pi(y) = \int p(x,y)\pi(x)dx$$</p><h3 id="马尔可夫链的性质"><a href="#马尔可夫链的性质" class="headerlink" title="马尔可夫链的性质"></a>马尔可夫链的性质</h3><h4 id="不可约"><a href="#不可约" class="headerlink" title="不可约"></a>不可约</h4><p>对于任意$i,j \in S$,存在t, $s.tP(X_t = i | X_{t-1} = j) \gt 0$</p><h4 id="非周期"><a href="#非周期" class="headerlink" title="非周期"></a>非周期</h4><p>对任意$i \in S$,如果时刻0从i出发,t时刻返回i状态的所有市场的最大公约数为1,则称其为<strong>非周期</strong>的,否则称其为<strong>周期</strong>的.</p><h4 id="正常返"><a href="#正常返" class="headerlink" title="正常返"></a>正常返</h4><p>对于任意$i,j \in S$,,定义概率$p_{ij}^t = P(X_t = i,X_s \ne i,s = 1,…,t-1|X_0 = j)$,若对所有状态i,j满足$\underset{t \rightarrow \infty}{lim}p_{ij}^t \gt 0$,则称马尔科夫链X是正常返的</p><h4 id="遍历性质"><a href="#遍历性质" class="headerlink" title="遍历性质"></a>遍历性质</h4><p>如果马尔可夫链X是不可约的,非周期的,正常返的,则该马尔科夫链由唯一平稳分布$\pi$,并且转移概率的极限分布是马尔科夫链的平稳分布.<br>$$\underset{t \rightarrow \infty }{lim}P(X_t = i |X_0 =j) = \pi_i$$<br>####　可逆马尔可夫链<br>如果对于马尔科夫链X的任意一个时刻皆有<br>$$P(X_t |X_{t-1} =j)\pi_j = P(X_{t-1} = j|X_t = i)\pi_i(细致平衡方程)$$<br>则称起为可逆的.</p><h2 id="马尔科夫链蒙特卡洛法-1"><a href="#马尔科夫链蒙特卡洛法-1" class="headerlink" title="马尔科夫链蒙特卡洛法"></a>马尔科夫链蒙特卡洛法</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>假设多元随机变量x,满足$x \in X$,其概率分布为p(x),f(x)是定义在$x \in X$上的函数,求概率分布p(x)的样本集合,以及函数f(x)的数学期望.<br>马尔科夫链蒙特卡洛法的基本思路是:</p><ul><li>定义一个满足遍历定理的马尔科夫链,使其平稳分布为抽样的目标分布</li><li>在该马尔科夫链上随机游走,由遍历性质可得在足够长时间之后,样本的分布趋近平稳分布,样本的函数均值接近函数的数学期望.</li></ul><p>算法的难点是找到这个马尔科夫链.</p><p>这个算法满足遍历定理,所以起始位置对结果没有影响.<br>对于最后的收敛,可以多次游走之后判断收敛值是否相同,或者多个点同时多次游走,判断是否相同.</p><h2 id="Metropois-Hastings算法"><a href="#Metropois-Hastings算法" class="headerlink" title="Metropois-Hastings算法"></a>Metropois-Hastings算法</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>该原理类似接受拒绝抽样法.<br>假设要抽样的概率分布为p(x),该算法采用转移核为$p(x,x^\prime)$的马尔科夫链:<br>$$p(x,x^\prime) = q(x,x^\prime)\alpha(x,x^\prime)$$<br>其中$q(x,x^\prime)$和$\alpha(x,x^\prime)$分别称为建议分布和接受分布.</p><p>建议分布$q(x,x^\prime)$是另一个马尔科夫链的转移核,并且其是不可约的,即其概率值恒不为0,同时,这个分布是一个容易抽样的分布.接受分布则是<br>$$\alpha(x,x^\prime) = \text min(1,\frac{p(x^\prime)q(x^\prime,x)}{p(x)q(x,x^\prime)})$$<br>若$p(x^\prime)q(x^\prime,x) \gt p(x)q(x,x^\prime)$,则<br>$$ \begin{aligned} p(x)p(x,x^\prime) &amp;= p(x)q(x,x^\prime)= q(x,x^\prime)p(x^\prime)\frac{p(x)q(x^\prime,x)}{p(x^\prime)q(x^\prime,x)}  \<br>    &amp;= p(x^\prime)q(x^\prime,x)\alpha(x^\prime,x)\<br>    &amp;= p(x^\prime)p(x^\prime,x)<br>\end{aligned}$$</p><p>若$p(x^\prime)q(x^\prime,x) \lt p(x)q(x,x^\prime)$,则<br>$$<br>\begin{aligned}<br>    p(x)p(x,x^\prime) &amp;= p(x)q(x,x^\prime)\frac{p(x^\prime)q(x^\prime,x)}{p(x)q(x,x^\prime)}\<br>    &amp;=p(x^\prime)q(x^\prime,x)\<br>    &amp;=p(x^\prime)q(x^\prime,x)\alpha((x^\prime,x)\<br>    &amp;=p(x^\prime)p(x^\prime,x)<br>\end{aligned}<br>$$<br>综上,$p(x,x^\prime)$是可逆的.</p><h3 id="建议分布"><a href="#建议分布" class="headerlink" title="建议分布"></a>建议分布</h3><p>建议分布的常用形式:</p><ul><li>第一种形式:建议分布是对称的,有$q(x,x^\prime) = q(x^\prime,x)$.</li><li><ul><li>特例之一是取条件概率分布$q(x,x^\prime) = p(x^\prime|x)$</li></ul></li><li><ul><li>特例之二是令$q(x,x^\prime) = q(|x-x^\prime|)$,称为随机游走的<code>Metropolis</code>算法</li></ul></li><li>第二种形式:独立抽样,假设$q(x,x^\prime)$与当前状态无关,建议分布按照$q(x^\prime)$独立抽样进行.</li></ul><h3 id="满条件分布"><a href="#满条件分布" class="headerlink" title="满条件分布"></a>满条件分布</h3><p>对于多元联合概率分布$p(x) = p(x_1,…,x_k)$,其中x为k维随机变量.如果条件概率分布$p(x_I|x_{-I})$中所有k个变量全部出现,其中$x_I = {x_i,i\in I},x_{-I} = {x_i,i\not\in I},I \subset K = {1,…,k}$,那么称这总条件概率分布维满条件分布.</p><p>它有一下性质:<br>$$p(x_I|x_{-I}) = \frac{p(x)}{\int p(x)dx_i} \propto p(x)$$<br>另有<br>$$\frac{p(x_I^\prime|x_{-I}^\prime)}{p(x_I|x_{-I})} = \frac{p(x^\prime)}{p(x)}$$<br>其意义是通过计算满条件概率的bi来计算联合概率的比,而前者更容易计算.</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>输入:抽样的目标分布的密度函数p(x),函数f(x)<br>输出:p(x)的随机抽样样本$x_{m+1},…,x_ {n}$,函数样本均值$f_{mn}$<br>参数:收敛步数m,迭代步数n.</p><ol><li>任意选择一个$x_0$作为起始状态.</li><li>对i=1,…,n进行循环执行</li></ol><ul><li>设状态$x_{i-1} = x$,按照建议分布$q(x,x^\prime)$随机抽样一个候选状态$x^\prime$</li><li>计算接受概率$\alpha(x,x^\prime)$</li><li>从区间[0,1]中按照均匀分布随机抽取一个数,若$u \leq \alpha(x,x^\prime)$则接受,反之则拒绝</li></ul><ol start="3"><li>得到样本集合$x_{m+1},…,x_{n}$</li></ol><h3 id="单分量的M-H算法"><a href="#单分量的M-H算法" class="headerlink" title="单分量的M-H算法"></a>单分量的M-H算法</h3><p>对于多元变量分布的抽样是困难的,所以对多元变量的每一变量的条件分布一次分别进行抽样,从而实现对整个多元变量的一次抽样,这就是但分量<code>M-H</code>算法.</p><p>假设马尔科夫链的状态有k维随机变量表示<br>$$x = (x_1,…,x_k)^T$$<br>其中$x_j$表示变量x的第j个分量,$x^i$表示在时刻i的状态.</p><p>为了生成容量为n的样本集合${x^1,…,x^n}$,单分量<code>M-H</code>算法由下面的k步迭代实现一次迭代.</p><p>设在第(i-1)次迭代结束时分量$x_j$的取值时$x_j^{i-1}$,在第i次迭代的第j步,对分量$x_j$更加<code>M-H</code>算法更新,得到其新的取值$x_j^i$.</p><ul><li>由建议分布$q(x_j^{i-1},x_j^i|x_{-j}^i)$抽样产生分量的候选值$x_j^i$,这里的$x_{-j}^i$表示第i次迭代的第(j-1)步后的$x_i$出去$x_j^{i-1}$的所有值,即<br>$$x_{-j}^i = (x_1^i,…,x_{j-1}^i,x_{j+1}^{i-1},…,x_k^{i-1})$$</li><li>根据接受概率$\alpha(x_j^{i-1},x_j^{i}|x_{-j}^i) = \text min(1,\frac{p(x_j^i|x_{-j}^i)q(x_j^i,x_j^{i-1}|x_{-j}^i)}{p(x_j^{i-1}|x_{-j}^i)q(x_j^{i-1},x_j^{i}|x_{-j}^i)})$ 抽样决定是否接受</li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 数理知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聚类方法学习</title>
      <link href="/2022/02/13/%E8%81%9A%E7%B1%BB%E6%96%B9%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/02/13/%E8%81%9A%E7%B1%BB%E6%96%B9%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="聚类方法"><a href="#聚类方法" class="headerlink" title="聚类方法"></a>聚类方法</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>聚类和分类的区别就是分类是提供了分类结果的,我们的目标是根据结果推原因,也就是执果索因,聚类我们是没有分类结果的,模型需要通过评价方法来判断那些是一类,那些不是一类,也就是执因索果</p><h3 id="相似度或距离"><a href="#相似度或距离" class="headerlink" title="相似度或距离"></a>相似度或距离</h3><p>距离是判断样本间相似度的重要依据,以下是主要几种相似度的判断方式.</p><h4 id="闵氏距离"><a href="#闵氏距离" class="headerlink" title="闵氏距离"></a>闵氏距离</h4><p>具体见<a href="https://the-tarnished.github.io/2022/01/29/%E5%A4%9A%E5%85%83%E5%88%86%E6%9E%90/">多元分析</a></p><h4 id="马氏距离"><a href="#马氏距离" class="headerlink" title="马氏距离"></a>马氏距离</h4><p>$$d_{ij} = [(x_i-x_j)^TS^{-1}(x_i-x_j)]^{\frac{1}{2}}$$<br>当<code>S</code>是单位矩阵的时候,马氏距离就是欧氏距离,可见马氏距离是欧氏距离的推广.</p><h4 id="相关系数"><a href="#相关系数" class="headerlink" title="相关系数"></a>相关系数</h4><p>$$r_{ij} = \frac{\displaystyle \sum_{k=1}^m(x_{ki}-\bar x_i)(x_{kj}-\bar x_j)}{[\displaystyle \sum_{k=1}^m(x_{ki}-\bar x_i)^2\displaystyle \sum_{k=1}^m(x_{kj}-\bar x_j)^2]^{\frac{1}{2}}}$$<br>其中<br>$$\bar x_i = \frac{1}{m}\displaystyle \sum_{k=1}^mx_{ki},\qquad\bar x_j = \frac{1}{m}\displaystyle \sum_{k=1}^mx_{kj}$$</p><h4 id="夹角余弦"><a href="#夹角余弦" class="headerlink" title="夹角余弦"></a>夹角余弦</h4><p>夹角余弦越接近1,表示相似度越高,反之,相似度越低.<br>$$s_{ij} = \frac{\displaystyle \sum_{k=1}^m x_{ki}x_{kj}}{\displaystyle \sum_{k=1}^m x_{ki}^2\displaystyle \sum_{k=1}^m x_{kj}^2}$$</p><h3 id="类或簇"><a href="#类或簇" class="headerlink" title="类或簇"></a>类或簇</h3><p>可以理解为样本的子集,子集内部的元素之间的距离小于外部元素和内部元素之间的距离.</p><h2 id="层次聚类"><a href="#层次聚类" class="headerlink" title="层次聚类"></a>层次聚类</h2><p>层次聚类需要三个因素:</p><ul><li>距离或者相似度度量选择</li><li>合并的规则(类和类之间的合并度量)</li><li>停止条件(合并的停止条件,一般都是类的总数达到了目标要求)</li></ul><h2 id="k均值聚类-k-means算法"><a href="#k均值聚类-k-means算法" class="headerlink" title="k均值聚类(k-means算法)"></a>k均值聚类(k-means算法)</h2><p>定义样本预期所属类的中心之间的距离总和为损失函数,即<br>$$W(C) = \displaystyle \sum_{l = 1}^k \displaystyle \sum_{C(i)=l} ||x_i - \bar x_l||^2$$</p><h3 id="具体算法"><a href="#具体算法" class="headerlink" title="具体算法"></a>具体算法</h3><p>可见scipy学习笔记中cluster类内的解释.</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 数理知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Logistic回归和最大熵模型</title>
      <link href="/2022/02/12/Logistic%E5%9B%9E%E5%BD%92%E5%92%8C%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/02/12/Logistic%E5%9B%9E%E5%BD%92%E5%92%8C%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Logistic回归"><a href="#Logistic回归" class="headerlink" title="Logistic回归"></a>Logistic回归</h1><p>虽然这个名字叫做<code>logistic</code>回归,但我感觉更像一种分布算法?<del>(这是否也算一种ntr)</del>,其分布函数的基本结构是<code>sigmoid</code>函数.<br>$$f(x) = \frac{1}{1+e^x}$$</p><h2 id="logistic分布"><a href="#logistic分布" class="headerlink" title="logistic分布"></a>logistic分布</h2><p>分布函数:<br>$$F(x) = P(X \leq x) = \frac{1}{1+e^{\frac{-(x-\mu)}{\gamma}}} $$<br>概率密度函数:<br>$$f(x) = F^{\prime}(x) = \frac{e^{\frac{-(x-\mu)}{\gamma}}}{\gamma(1+e^{\frac{-(x-\mu)}{\gamma}})^2} $$<br>其中$\mu$与$\gamma$分别为位置参数(理解成F(x)的中心对称点),形状参数(在中心对称点的变化速度描述).<br><img src="logistic.png" alt="图 1">  </p><h2 id="二项logistic回归模型"><a href="#二项logistic回归模型" class="headerlink" title="二项logistic回归模型"></a>二项logistic回归模型</h2><p>虽然名字是回归模型,但其实本质是分类模型,由条件概率分布P(Y|X)表示.Y取值1或0.<br>$$<br>\begin{aligned}<br>    P(Y=1|x) = \frac{exp({\omega}x+b)}{1+exp({\omega}x+b)}\\<br>    P(Y=0|x) = \frac{1}{1+exp({\omega}x+b)}<br>\end{aligned}<br>$$<br>令$\omega = (\omega^{(1)},…,\omega^{(n)},b)^T$,$x=(x^{(1)},..,x^{(n)},1)$,则上式变为<br>$$<br>\begin{aligned}<br>    P(Y=1|x) = \frac{exp({\omega}x)}{1+exp({\omega}x)}\\<br>    P(Y=0|x) = \frac{1}{1+exp({\omega}x)}<br>\end{aligned}<br>$$<br>所以<br>$$ln(\frac{P(Y=1|x)}{P(Y=0|x)}) = {\omega}x$$<br>也就是说,在二项logistic回归模型下,输出<code>Y=1</code>的几率(<strong>事件发生的概率比上事件不发生的概率</strong>)是输入<code>x</code>的线性函数</p><h2 id="模型的参数估计"><a href="#模型的参数估计" class="headerlink" title="模型的参数估计"></a>模型的参数估计</h2><p>使用极大似然估计法进行模型估计.<br>设:<br>$$P(Y=1|x) = \pi(x),P(Y=0|x) = 1-\pi(x)$$<br>似然函数是<br>$$\Pi(\pi(x))^{y_i}(1-\pi(x))^{1-y_i}$$<br><strong>(我觉得上式很巧妙,因为不知道y_i的值,我们就不知道使用那个概率,但是通过幂的控制实现了选择)</strong></p><p>对数似然函数是:<br>$$L(\omega)=\Sigma[y_i(\omega*x_i)-log(1+exp({\omega}*x)i))]$$</p><h2 id="多项logistic回归"><a href="#多项logistic回归" class="headerlink" title="多项logistic回归"></a>多项logistic回归</h2><p>二项<code>logistic</code>回归告诉了我们Y=1的概率是Y=0的概率的${\omega}x$倍,如果是多项的话,每一个都是另一个的$P(Y=k|x) = \omega_i倍$,$Y \in {1,…,K}$那么,其分布函数为:<br>$$\begin{aligned}<br>    P(Y=k|x) = \frac{exp(\omega_kx)}{1+\displaystyle \sum_{k=1}^{K-1}exp(\omega_kx)}\qquad k=1,…,K-1\\<br>    P(Y=K|x) = \frac{1}{1+\displaystyle \sum_{k=1}^{K-1}exp(\omega_kx)}<br>\end{aligned}$$</p><h1 id="最大熵模型"><a href="#最大熵模型" class="headerlink" title="最大熵模型"></a>最大熵模型</h1><p>最大熵模型感觉是一个从信息学推出的原理,但它本质和最大似然估计法很像,都是求最大可能.</p><h2 id="最大熵原理"><a href="#最大熵原理" class="headerlink" title="最大熵原理"></a>最大熵原理</h2><p>假设离散随机变量X的概率分布是P(X),则其熵是:<br>$$H(P) = -{\Sigma}P(X)logP(X)$$<br>直观来说,最大熵原理就是在满足已有限制条件之下,未知的部分都是<code>等可能的</code>.</p><h2 id="最大熵模型的定义"><a href="#最大熵模型的定义" class="headerlink" title="最大熵模型的定义"></a>最大熵模型的定义</h2><p>假设分类模型是一个条件概率分布<code>P(Y|X)</code>,给定训练集$T={(x_1,y_1),…,(x_N,y_N)}$.<br>对于P(X,Y)的经验分布和其边缘分布的经验分布,使用 $\hat{P}(X,Y),\hat{P}(X)$表示<br>$$\begin{aligned}<br>    \hat{P}(X=x_i,Y=y_i) &amp;= \frac{v(X=x_i,Y=y_i)}{N}\\<br>    \hat{P}(X=x_i) &amp;= \frac{v(X=x_i)}{N}<br>\end{aligned}$$<br>v表示频数,N是总的训练样本容量</p><p>使用特征函数f(x,y)描述输入x和输出y的关系,<br>$$f(x,y) = \begin{cases}<br>1,x和y满足某一个事实\<br>0,x和y不满足某一个事实<br>\end{cases}$$<br>那么,关于经验分布的期望值$E_{\hat{P}}(f) = \Sigma{\hat P(x,y)f(x,y)}$</p><p>对于模型$P(X|Y)$与经验分布$\hat P(X)$的期望值$E_P(f) = \Sigma{\hat P(x)P(y|x)f(x,y)}$</p><p>$E_P(f) = E_{\hat{P}}(f)$ </p><p>那么<strong>最大熵模型</strong>的定义为:<br>假设满足所有约束条件的模型集合为:<br>$$C = {P \in \mathcal P|E_p(f_i) = E_{\hat P}(f_i),i=1,…,n}$$<br>定义在条件概率分布$P(Y|X)$上的条件熵为:<br>$$H(P) = -\Sigma \hat P(x)P(y|x)lnP(y|x)$$<br>则模型集合C中条件熵最大的模型称为最大熵模型</p><h2 id="最大熵模型的学习"><a href="#最大熵模型的学习" class="headerlink" title="最大熵模型的学习"></a>最大熵模型的学习</h2><p>最大熵模型的学习可以形式化为约束最优化问题<br>约束条件:<br>$$\begin{aligned}<br>    E_p(f_i) &amp;= E_{\hat P}(f_i),i=1,…,n\\<br>    \Sigma P(y|x) &amp;= 1<br>\end{aligned}$$<br>函数:<br>$$\underset{P\in C}{min}\quad-H(P) = \Sigma \hat P(x)P(y|x)lnP(y|x)$$<br>引入拉格朗日乘子$\omega = {\omega_0,…,\omega_n}$,定义拉格朗日函数$L(P,\omega)$<br>$$\begin{aligned}<br>    L(P,\omega) &amp;= -H(P) + \omega_0(1-\Sigma P(y|x))+\displaystyle \sum_{i=1}^n{\omega_i(E_p(f_i) - E_{\hat P}(f_i))}<br>\end{aligned}$$<br>解得:<br>$$\begin{aligned}<br>    P_\omega(y|x) = \frac{exp(\displaystyle \sum_{i=1}^n\omega_if_i(x,y))}{Z_\omega(x)}\\<br>    Z_\omega(x) = \displaystyle \sum_{y}exp(\displaystyle \sum_{i=1}^n\omega_if_i(x,y))<br>\end{aligned}<br>$$<br>求得$P_\omega(y|x)$之后,反带入L(P,\omega),求得关于$\omega$的极大化问题(求偏导).</p><h1 id="模型学习的最优化算法"><a href="#模型学习的最优化算法" class="headerlink" title="模型学习的最优化算法"></a>模型学习的最优化算法</h1><h2 id="迭代尺度法"><a href="#迭代尺度法" class="headerlink" title="迭代尺度法"></a>迭代尺度法</h2><p>类似于梯度下降法,我们想从一个$\omega$出发,找到最优的$\omega$,我们每一次寻找的步长为$\delta$,直到步长都为0,说明我们找到了最优的$\omega$.</p><p>那么,步长怎么找?我们需要找到每一个$\omega$增加一个步长的时候,改变值的下界,这个下界是$\delta$的函数,下界的极值点就是我们需要求的$\delta$.</p><p>在我的理解,寻找下界是为了一步尽量走得更远(下界越大,这一步迈的更远),减少迭代次数.</p><p>算法:</p><ul><li>对所有$i \in {1,…,n},取初值\omega_i = 0$</li><li>对每一个$i \in {1,…,n}$</li><li><ul><li>令$\delta_i$是方程</li></ul></li></ul><p>$$ \displaystyle \sum_{(x,y)}\hat P(x)P(y|x)f_i(x,y)exp(\delta_if^{*}(x,y)) = E_{\hat P}(f_i) $$</p><p>的解,$f^{*}(x,y) = \displaystyle \sum _{i=1}^nf_i(x,y)$</p><ul><li><ul><li>更新$\omega_i = \omega_i + \delta_i$ </li></ul></li><li>如果不是所有的$\delta_i = 0$,则重复第二步<h2 id="拟牛顿法"><a href="#拟牛顿法" class="headerlink" title="拟牛顿法"></a>拟牛顿法</h2>对于最大熵模型而言:<br>$$\begin{aligned}<br>  P_\omega(y|x) = \frac{exp(\displaystyle \sum_{i=1}^n\omega_if_i(x,y))}{Z_\omega(x)}\\<br>  Z_\omega(x) = \displaystyle \sum_{y}exp(\displaystyle \sum_{i=1}^n\omega_if_i(x,y))<br>\end{aligned}$$<br>目标函数:<br>$$f(\omega) = \displaystyle \sum_{x}\hat P(x)ln\displaystyle \sum_yexp(\displaystyle \sum_{i=1}^n\omega_if_i(x,y))-\displaystyle \sum_{x,y}\hat P(x,y)\displaystyle \sum_{i=1}^n\omega_if_i(x,y)$$<br>梯度:<br>$$g(\omega) = (\frac{\partial{f(\omega)}}{\partial\omega_1},…,\frac{\partial{f(\omega)}}{\partial\omega_n})^T$$<br>其中:<br>$$\frac{\partial{f(\omega)}}{\partial\omega_i} = \displaystyle \sum_{x,y}\hat P(x)P_\omega(y|x)f_i(x|y)-E_{\hat P}(f_i)$$<br>算法:</li><li>选定初始的$\omega^{(0)}$,取$B_0$为正定对称矩阵,直接为单位阵即可,置$k=0$</li><li>计算$g_k = g(\omega^{k})$,若$||g_k|| \lt \epsilon(精度要求),则停止计算,否则进入下一步$</li><li>由$B_kp_k = -g_k 求出p_k$ </li><li>求$\lambda_k使得$ $f(\omega^{(k)}+\lambda_kp_k)最小(求导即可)$</li><li>令$\omega^{(k+1)}= \omega^{(k)}+\lambda_kp_k$</li><li>计算$g_{k+1} = g(\omega^{k+1})$,若$||g_{k+1}|| \lt \epsilon(精度要求),则停止计算,否则进入下一步$</li><li>计算 $B_{k+1} = B_{k} + \frac{y_ky_k^T}{y_k^T\delta_k}-\frac{B_k\delta_k\delta_k^TB_k}{\delta_k^TB_k\delta_k}$<br>其中,$y_k = g_{k+1}-g_{k},\delta_k = \omega^{k+1}-\omega^{k}$</li><li>置$k = k+1$,转到第三步</li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 数理知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k近邻法学习笔记</title>
      <link href="/2022/02/11/k%E8%BF%91%E9%82%BB%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/02/11/k%E8%BF%91%E9%82%BB%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="k近邻法"><a href="#k近邻法" class="headerlink" title="k近邻法"></a>k近邻法</h1><h2 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h2><p>K近邻算法<code>(KNN,k-nearest,neighbor)</code>给定训练集,对于新输入的实例找到离它最近的<code>k</code>个点,然后根据多数表决原则判断新的实例的类别.</p><p>距离的度量有不同的方法,总结起来就是闵氏距离<a href="https://the-tarnished.github.io/2022/01/29/%E5%A4%9A%E5%85%83%E5%88%86%E6%9E%90/">(可见多元分析中的介绍)</a>.</p><p>为了精确分类,k的取值有讲究,太小会导致整体模型复杂,容易发生过拟合(噪声的影响会突出),如果太多,则会导致误差变大,一般通过交叉验证来取最优的k值.</p><h2 id="kd树"><a href="#kd树" class="headerlink" title="kd树"></a>kd树</h2><p>对于多个点,如果暴力枚举会导致复杂度太高,kd树能有效降低算法复杂度(特别是点的个数远大于维数的时候).</p><h3 id="kd树的构造"><a href="#kd树的构造" class="headerlink" title="kd树的构造"></a>kd树的构造</h3><ul><li>选择某一个维度$x^{(1)}$为起点构造根节点,以T中所有实例在$x^{(1)}$维度的中位数为切分点,将其分成两个子区域.</li><li>对于每一个子区域,对于深度为j的节点,取维度$x^{(l)}(l = j(mod)k+1,k是维度)$为根节点,该区域中所有实例中中位数为切分点,分成两个区域.</li><li>如果子区域为空则停止切分.</li></ul><h3 id="kd树的查找"><a href="#kd树的查找" class="headerlink" title="kd树的查找"></a>kd树的查找</h3><p>类似平衡二叉树,左子树是小于切分点的点,右子树是大于切分点的点.</p><h3 id="kd树的搜索"><a href="#kd树的搜索" class="headerlink" title="kd树的搜索"></a>kd树的搜索</h3><p>对于新输入点寻找最近邻</p><ul><li>按照查找的逻辑向下递归到叶节点,令<code>当前最近点</code>为该节点</li><li>递归向上回退,对于每一个结点做下列判断</li><li><ul><li>如果该结点比<code>当前最近点</code>离新输入点更近,则该点为<code>当前最近点</code></li></ul></li><li><ul><li>若该结点的子节点为<code>当前最近点</code>,检查该结点的另一个子区域是否与<code>以目标点为半径,当前最近点与目标点长度为半径的超球体相交</code>,如果相交则检查另一个子区域是否有更近的点.</li></ul></li><li>退回到根节点,算法结束.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 数理知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>感知机模型</title>
      <link href="/2022/02/10/%E6%84%9F%E7%9F%A5%E6%9C%BA%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/02/10/%E6%84%9F%E7%9F%A5%E6%9C%BA%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h1><h2 id="模型介绍"><a href="#模型介绍" class="headerlink" title="模型介绍"></a>模型介绍</h2><p>感知机简单来说就是找到一个平面,将数据分成两类.因为这是一个分类的模型,所以这一定是一个监督模型.这个模型的输入是实例的特征向量,输出的是+1和-1作为内边的判断.</p><h2 id="模型函数"><a href="#模型函数" class="headerlink" title="模型函数"></a>模型函数</h2><p>$$f(x) = sign(\omega{x}+b)$$<br>任何一点到此超平面的距离$\propto\omega{x_i}+b$</p><p>对于误分类的数据 $-y_i(\omega{x_i}+b) \geq 0(y_i对于距离的绝对大小没有影响)$</p><p>所以对于所有误分类点到超平面的总距离$\propto{\underset{x_i\in{M}}\Sigma{-y_i(\omega{x_i}+b)}}$<br>所以损失函数定义为<br>$$L(\omega,b) = {\underset{x_i\in{M}}\Sigma{-y_i(\omega{x_i}+b)}}$$</p><h2 id="感知机学习算法"><a href="#感知机学习算法" class="headerlink" title="感知机学习算法"></a>感知机学习算法</h2><p>感知机模型是误差驱动的模型,当损失函数极小化的时候,则可认为拟合完成.采取梯度下降算法进行损失函数极小化(梯度下降算法容易陷入极小化陷阱,所以不一定能求得最小值).</p><p>梯度向量是$(-{\Sigma}y_ix_i,-{\Sigma}y_i) = (\nabla_{\omega}L(\omega,b),\nabla_{b}L(\omega,b))$,步长是$\eta$</p><h3 id="原始形式"><a href="#原始形式" class="headerlink" title="原始形式"></a>原始形式</h3><ul><li>选取初始的$\omega_0,b_0$</li><li>在训练集中选取数据$(x_i,y_i)$</li><li>如果$-y_i(\omega{x_i}+b) \geq 0$<br>$$\begin{aligned}<br>  \omega \leftarrow \omega + \eta{y_ix_i}\\<br>  b \leftarrow b + \eta{y_i}<br>\end{aligned}$$</li><li>循环第二步,直到没有误分类点</li></ul><h3 id="对偶形式"><a href="#对偶形式" class="headerlink" title="对偶形式"></a>对偶形式</h3><p>$$\begin{aligned}<br>\omega \leftarrow \omega + \eta{y_ix_i}\\<br>  b \leftarrow b + \eta{y_i}<br>\end{aligned}$$<br>不难看出最后的<br>$$\begin{aligned}<br>\qquad\omega &amp;= \Sigma\alpha_iy_ix_i+\omega_0\\<br>  b &amp;= \Sigma\alpha_iy_i+b_0\\<br>  \alpha_i &amp;= n_i\eta(n是该点由于误分进行更新的次数)<br>\end{aligned}$$<br>令$\omega_0 = 0,b_0 = 0$<br>算法:</p><ul><li>$\alpha \rightarrow 0,b \rightarrow 00$</li><li>读取数据($x_i,y_i$)</li><li>如果$y_i(\Sigma{\alpha_j}y_jx_jx_i + b) \leq 0$<br>$$\begin{aligned}<br>\alpha_i = \alpha_i + \eta \\<br>b = b + {\eta}y_i<br>\end{aligned}$$</li><li>重复第二步直至没有误分类数据</li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 数理知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python与MySql存储</title>
      <link href="/2022/02/08/MySql%E5%AD%98%E5%82%A8/"/>
      <url>/2022/02/08/MySql%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 爬虫学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python与CSV文件存储</title>
      <link href="/2022/02/08/CSV%E6%96%87%E4%BB%B6/"/>
      <url>/2022/02/08/CSV%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h2><p>csv文件的写入需要通过writer类构造一个对象进行写入,该类构造方法需要一个file对象,另外可以通过delimiter参数自定义分隔符</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> csv<span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'data.csv'</span><span class="token punctuation">,</span><span class="token string">'w'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> csvfile<span class="token punctuation">:</span>    writer <span class="token operator">=</span> csv<span class="token punctuation">.</span>writer<span class="token punctuation">(</span>csvfile<span class="token punctuation">,</span>delimiter<span class="token operator">=</span>`<span class="token operator">|</span>`<span class="token punctuation">)</span>    writer<span class="token punctuation">.</span>writerow<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">## 写入列表的头</span>    writer<span class="token punctuation">.</span>writerow<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">## 写入列表数据</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外也可以通过writerows方法一次写入多条数据.</p><p>如果要写入中文数据,记得修改open的<code>encoding</code>参数</p><p>如果要写入字典的话,需要通过DicWriter类构造一个对象进行写入,该类构造方法需要一个file对象,还需要一个fieldnames参数,这个参数是字典的key值.<br>实例代码:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> csvfieldnames <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">,</span><span class="token string">'grade'</span><span class="token punctuation">]</span><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'data.csv'</span><span class="token punctuation">,</span><span class="token string">'w'</span><span class="token punctuation">,</span>encodeing<span class="token operator">=</span><span class="token string">'utf8'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> csvfile<span class="token punctuation">:</span>    writer <span class="token operator">=</span> csv<span class="token punctuation">.</span>DicWriter<span class="token punctuation">(</span>csvfile<span class="token punctuation">,</span>fieldnames <span class="token operator">=</span> fieldnames<span class="token punctuation">)</span>    writer<span class="token punctuation">.</span>writecow<span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token string">'name'</span><span class="token punctuation">:</span><span class="token string">'韩梅梅'</span><span class="token punctuation">,</span><span class="token string">'grade'</span><span class="token punctuation">:</span><span class="token string">'114514'</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外,也可以使用pandas库的DataFrame对象的to_csv方法将数据写入CSV文件中.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> pandasdata <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">&#123;</span><span class="token string">'name'</span><span class="token punctuation">:</span><span class="token string">'韩梅梅'</span><span class="token punctuation">,</span><span class="token string">'grade'</span><span class="token punctuation">:</span><span class="token string">'114'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span><span class="token string">'name'</span><span class="token punctuation">:</span><span class="token string">'李雷'</span><span class="token punctuation">,</span><span class="token string">'grade'</span><span class="token punctuation">:</span><span class="token string">'514'</span><span class="token punctuation">&#125;</span><span class="token punctuation">]</span>df <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>data<span class="token punctuation">)</span>df<span class="token punctuation">.</span>to_csv<span class="token punctuation">(</span><span class="token string">'data.csv'</span><span class="token punctuation">,</span>index <span class="token operator">=</span> <span class="token boolean">False</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><p>读取文件需要通过reader构造一个reader对象.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> csv<span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'data.csv'</span><span class="token punctuation">,</span><span class="token string">'r'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token builtin">file</span><span class="token punctuation">:</span>    reader <span class="token operator">=</span> csv<span class="token punctuation">.</span>reader<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> row <span class="token keyword">in</span> reader<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外也可以通过pandas库的read_csv方法读取</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> pandasdf <span class="token operator">=</span> pandas<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>df<span class="token punctuation">)</span><span class="token comment">##本质是一个DataFrame对象,类似矩阵</span><span class="token builtin">list</span> <span class="token operator">=</span> df<span class="token punctuation">.</span>values<span class="token punctuation">.</span>to_list<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token comment">##输出的是一个列表</span><span class="token keyword">for</span> index<span class="token punctuation">,</span>row <span class="token keyword">in</span> df<span class="token punctuation">.</span>iterrows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment">##进行遍历</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>row<span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 爬虫学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> CSV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sklearn库学习笔记</title>
      <link href="/2022/02/04/sklearn%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/02/04/sklearn%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="sklearn"><a href="#sklearn" class="headerlink" title="sklearn"></a>sklearn</h1><p><a href="https://www.sklearncn.cn/">官方文档</a></p><h1 id="有监督学习和无监督学习"><a href="#有监督学习和无监督学习" class="headerlink" title="有监督学习和无监督学习"></a>有监督学习和无监督学习</h1><p>什么是有监督学习?什么是无监督学习?顾名思义,就是有无监督.那么,这个监督是什么?我个人理解,监督,也就是答案.我们对数据进行分析,归类,得出自己的结果,监督就是分析结果的标准答案.那么有无监督学习的区别就是是否有这样一个答案.</p><p>有监督学习就是有这个”答案”,我们的目标是对这个答案进行解释,为什么这些数据一类,那些数据一类.得到结果之后,输入新的数据,看自己是否分类合理.</p><p>无监督学习就是没有这个”答案’,我们的目标是构建自己的理论进行分类.</p><p>所以,这两个方向的侧重点不同,有监督学习的侧重点是分类,既解释”答案”,无监督学习的重点是聚类,既通过数据,把样本之间分门别类.</p><p>因为有监督学习的重点是解释,所以,解释结果是不透明的,我们无法解释为什么是这样分类,我们只是为了满足给的”答案”.相反,无监督学习不是透明的,我们可以说出我们聚类的方法,这几个样本是一类是因为他们某些数据相似度高.</p><p>那么,这份”答案”来自于哪里?大多是不言而喻的,比如物种(著名的Iris数据集),这些是一个种,那些是一个种,我们的目的是解释为什么这些是一类.有些是可以人工进行分类,因为他们数据差得太远.</p><p>但是有”答案”就一定选择有监督学习嘛?不一定,如果数据之间不是独立分布的,也即存在隐藏的因子(因子分析),那么,使用无监督更好.如果数据特别多,维数很高,人工难以分类,那么无监督也更好.</p><p>综上,对于两者的选择,肯定是选择有监督学习更好,因为学习速率更快,但是有监督学习的条件苛刻,必须有”答案”,同时,数据之间不能有潜在联系(既不相互独立).</p><h1 id="有监督学习算法"><a href="#有监督学习算法" class="headerlink" title="有监督学习算法"></a>有监督学习算法</h1><h2 id="广义线性模型"><a href="#广义线性模型" class="headerlink" title="广义线性模型"></a>广义线性模型</h2><h3 id="普通最小二乘法"><a href="#普通最小二乘法" class="headerlink" title="普通最小二乘法"></a>普通最小二乘法</h3><p>普通最小二乘法拟合有一个稀疏的线性模型,使得数据集实际观测数据和预测数据(估计值)之间的残差平方和最小<br>$$\underset{w}{min} {|| X w - y||_2}^2$$</p><p>实现中,调用<code>linear_model</code>中的<code>LinearRegression</code>方法建立估计器,所有估计器都有两个方法<code>fit(x,y)</code>和<code>predict(x)</code>,一个用于模型建立,一个用于预测.<br>模型系数存在<code>coef_</code>成员中</p><p>示例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> sklearn <span class="token keyword">import</span> linear_modelreg <span class="token operator">=</span> linear_model<span class="token punctuation">.</span>LinearRegression<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">##建立估计器</span>reg<span class="token punctuation">.</span>fit <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">## 模型建立</span>LinearRegression<span class="token punctuation">(</span>copy_X<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> fit_intercept<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> n_jobs<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> normalize<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span>coef_<span class="token punctuation">)</span><span class="token comment">##array([ 0.5,  0.5])</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="岭回归"><a href="#岭回归" class="headerlink" title="岭回归"></a>岭回归</h3><p><code>Ridge</code>回归通过对系数的大小施加惩罚来解决<strong>普通最小二乘法</strong>的一些问题,比如每个维度的数据点少,使得噪声影响大。 岭系数最小化的是带罚项的残差平方和.</p><p>$$\underset{w}{min} {|| X w - y||_2}^2 + \alpha {||w||_2}^2$$</p><p>示例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> sklearn <span class="token keyword">import</span> linear_modelreg <span class="token operator">=</span> linear_model<span class="token punctuation">.</span>Ridge <span class="token punctuation">(</span>alpha <span class="token operator">=</span> <span class="token number">.5</span><span class="token punctuation">)</span>reg<span class="token punctuation">.</span>fit <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">.1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>Ridge<span class="token punctuation">(</span>alpha<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">,</span> copy_X<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> fit_intercept<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> max_iter<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> normalize<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> random_state<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> solver<span class="token operator">=</span><span class="token string">'auto'</span><span class="token punctuation">,</span> tol<span class="token operator">=</span><span class="token number">0.001</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span>coef_<span class="token punctuation">)</span><span class="token comment">##array([ 0.34545455,  0.34545455])</span><span class="token keyword">print</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span>intercept_<span class="token punctuation">)</span><span class="token comment">#0.13636...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外还有带有交叉验证的岭回归,通过<code>RidgeCV</code>建立带有$\alpha$参数的岭回归,指定cv的属性,能触发(GridSearchCV)交叉验证,例如cv=10,触发十折交叉验证.</p><h3 id="Lasso"><a href="#Lasso" class="headerlink" title="Lasso"></a>Lasso</h3><p><code>Lasso</code>是拟合稀疏系数的线性模型。 它在一些情况下是有用的，因为它倾向于使用具有较少参数值的情况，有效地减少给定解决方案所依赖变量的数量。</p><p> 其最小化的目标函数是:<br>$$\underset{w}{min} { \frac{1}{2n_{samples}} ||X w - y||_2 ^ 2 + \alpha ||w||_1}$$<br>$Lasso$类的实现使用了<code>coordinate descent</code>（坐标下降算法）来拟合系数。</p><p>示例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> sklearn <span class="token keyword">import</span> linear_modelreg <span class="token operator">=</span> linear_model<span class="token punctuation">.</span>Lasso<span class="token punctuation">(</span>alpha <span class="token operator">=</span> <span class="token number">0.1</span><span class="token punctuation">)</span>reg<span class="token punctuation">.</span>fit<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span>predict<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#array([ 0.8])</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>同样,<code>lasso</code>也有交叉验证,分别为<code>LassoCV</code>和<code>LassoLarsCV</code>,<code>LassoLarsCV</code>使用最小角回归算法计算alpha值,更加有优势,在面对样本数量比特征数量少很多的时候,其速率一般更快.在面对具有许多线性回归的高位数据集的时候,<code>LassoCV</code>更有优势.</p><h3 id="多任务Lasso"><a href="#多任务Lasso" class="headerlink" title="多任务Lasso"></a>多任务Lasso</h3><p>多任务Lasso的Y是一个二维数组,横轴为样本,竖轴为属性.其使用<code>MultiTaskLasso</code>建立估计器.类的实现使用了坐标下降作为拟合系数的算法。</p><h2 id="支持向量机-SVMs"><a href="#支持向量机-SVMs" class="headerlink" title="支持向量机(SVMs)"></a>支持向量机(SVMs)</h2><p>支持向量机主要用于监督学习算法:分类,回归和异常检测</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><code>SVC</code>, <code>NuSVC</code> 和 <code>LinearSVC</code> 能在数据集中实现多元分类.</p><h3 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h3><p>支持向量回归有三种不同的实现形式: <code>SVR</code>, <code>NuSVR</code> 和 <code>LinearSVR</code>.其在高维,大数据下的表现优于最小二乘法.如果是稀疏矩阵,建议使用<code>scipy</code>中的<code>CSR</code>矩阵格式.</p><h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><p>SGDClassifier 类实现了一个简单的随机梯度下降学习例程,这个估计器使用的时候需要保证数据充分打乱(梯度下降算法容易陷入局部最小值).<code>coef_</code>成员储存了参数,<code>intercept_</code>存储了截距.可以自己选择损失函数,通过loss参数选择.</p><ul><li><code>loss=&quot;hinge&quot;</code>: (soft-margin) linear Support Vector Machine （（软-间隔）线性支持向量机），</li><li><code>loss=&quot;modified_huber&quot;</code>: smoothed hinge loss （平滑的 hinge 损失），</li><li><code>loss=&quot;log&quot;</code>: logistic regression （logistic 回归），</li></ul><h3 id="回归-1"><a href="#回归-1" class="headerlink" title="回归"></a>回归</h3><p><code>SGDRegressor</code>类实现了一个简单的随机梯度下降学习例程，它支持用不同的损失函数和惩罚来拟合线性回归模型。 SGDRegressor 非常适用于有大量训练样本的回归问题，对于其他问题，使用 <code>Ridge</code> ，<code>Lasso</code> 是更好的选择 。</p><p>具体的损失函数可以通过 loss 参数设置。 SGDRegressor 支持以下的损失函数:</p><ul><li><code>loss=&quot;squared_loss&quot;</code>: Ordinary least squares（普通最小二乘法）</li><li><code>loss=&quot;huber&quot;</code>: Huber loss for robust regression（Huber回归)</li><li><code>loss=&quot;epsilon_insensitive&quot;</code>: linear Support Vector Regression（线性支持向量回归）</li></ul><h2 id="最近邻"><a href="#最近邻" class="headerlink" title="最近邻"></a>最近邻</h2><p>最近邻算法是将所有点中最相似的点合并为一个类,称为一个新的点,再继续合并,直到只剩下所需要的簇的数目.其中最相似这个概念不一定是距离最短,因为对于类中包含多个点,他们的距离计算需要事先规定,可能是<code>single link</code>最近两点为类间距,也可能是<code>complete link</code>最远两点为类间距.</p><h3 id="无监督最近邻"><a href="#无监督最近邻" class="headerlink" title="无监督最近邻"></a>无监督最近邻</h3><p>算法接口为<code>NearestNeighbors</code></p><ul><li><code>algorithm</code>参数选择算法,建议选择<code>auto</code>,程序自动选择最优算法</li><li><code>n_neighbors</code>参数用于控制<code>kneighbors</code>查询的邻居数.</li></ul><p>该类可以通过kneighbors查询邻居索引和距离.<br><code>distances, indices = nbrs.kneighbors(X)</code></p><h3 id="最近邻分类"><a href="#最近邻分类" class="headerlink" title="最近邻分类"></a>最近邻分类</h3><p>最近邻分类是由每个点的最近邻的简单多数投票中计算得到,也就是说一个查询点的数据类型是由它最近邻点中最具代表性的数据类型来决定.</p><p><code>scikit-learn</code>提供了两种最近邻分类器.</p><ul><li><code>RadiusNeighborsClassifier</code> 是一个通过访问给定半径类的邻居实现投票的类.可以通过修改<code>weights</code>参数来决定距离对投票权重的影响.</li><li><code>KNeighborsClassifier</code> knn算法进行投票,修改<code>n-neighbots</code>参数控制访问的最近邻居数进行投票.</li></ul><h3 id="最近邻回归"><a href="#最近邻回归" class="headerlink" title="最近邻回归"></a>最近邻回归</h3><p><code>sklearn</code>提供了两种不同的最近邻回归:<code>KNeighborsRegressor</code>和<code>RadiusNeighborsRegressor</code>.</p><p><code>KNeighborsRegressor</code>和<code>KneighborsClassifier</code>类似,通过每个查询点的k个最近邻实现.</p><p><code>RadiusNeighborsRegressor</code>和<code>RadiusNeighborsClassifier</code>类似,通过每个查询点的固定半径r内的邻点数量实现.</p><p>此外,可以通过设置<code>weights</code>参数来控制每个邻点的权重.<code>weights = uniform</code>则表示权重相同,<code>weights = distance</code>则表示和距离成反比,此外还可以自定义距离函数来自定义权重.</p><h3 id="领域成分分析"><a href="#领域成分分析" class="headerlink" title="领域成分分析"></a>领域成分分析</h3><p>领域成分分析(NeighborhoodComponentsAnalysis,NCA)是距离度量学习算法,目的是提高最近邻分类相对于标准欧氏距离的准确性.</p><h4 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h4><p>NCA分类需要和最近邻分类的<code>KNeighborsClassifier</code>相结合.示例:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>neighbors <span class="token keyword">import</span> NeighborhoodComponentsAnalysis<span class="token punctuation">,</span>KNeighborsClassifier<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>datrasets <span class="token keyword">import</span> load_iris<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> train_test_split<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>pipeline <span class="token keyword">import</span> Pipelinex_train<span class="token punctuation">,</span>x_test<span class="token punctuation">,</span>y_train<span class="token punctuation">,</span>y_test <span class="token operator">=</span> train_test_split<span class="token punctuation">(</span>load_iris<span class="token punctuation">(</span>return_X_y <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">,</span>stratify<span class="token operator">=</span>y<span class="token punctuation">,</span>text_size<span class="token operator">=</span><span class="token number">0.7</span><span class="token punctuation">,</span>random_state<span class="token operator">=</span><span class="token number">42</span><span class="token punctuation">)</span>nca <span class="token operator">=</span> NeighborhoodComponentsAnalysis<span class="token punctuation">(</span>random_state <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">)</span>knn <span class="token operator">=</span> KNeighborsClassifier<span class="token punctuation">(</span>n_neighbors <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">)</span>pipe <span class="token operator">=</span> Pipeline<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'nca'</span><span class="token punctuation">,</span>nca<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'knn'</span><span class="token punctuation">,</span>knn<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>pipe<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>x_train<span class="token punctuation">,</span>ytrain<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h4><p><code>NCA</code>可用于监督降维.可使用参数<code>n_components</code>设置所需的维数</p><h2 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h2><p>朴素贝叶斯算法是基于贝叶斯定理发展的.</p><p>设有样本数据集D = {$x_1,…,x_n$},对应的类是 Y = {$y_1,…,y_n$}.由贝叶斯理论易得:<br>$$P(Y|X) = \frac{P(Y)\Pi_{i=1}^dP(x_i|Y)}{\Pi_{i=1}^dP(x_i)}$$<br>这个计算式逻辑简单,算法稳定,健壮性强,但是如果样本数据之间不相互独立,则效果不行.</p><h3 id="高斯朴素贝叶斯"><a href="#高斯朴素贝叶斯" class="headerlink" title="高斯朴素贝叶斯"></a>高斯朴素贝叶斯</h3><p>如果特征的可能性服从正态(高斯)分布<br>P($x_i$|y) = $\frac{1}{\sqrt{2\pi \sigma^2}}exp(-\frac{(x_i-u_y)^2}{2\sigma_y^2})$</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> sklearn <span class="token keyword">import</span> datasetsiris <span class="token operator">=</span> datasets<span class="token punctuation">.</span>load_iris<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>naive_bayes <span class="token keyword">import</span> GaussianNBgnb <span class="token operator">=</span> GaussianNB<span class="token punctuation">(</span><span class="token punctuation">)</span>y_pred <span class="token operator">=</span> gnb<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>iris<span class="token punctuation">.</span>data<span class="token punctuation">,</span> iris<span class="token punctuation">.</span>target<span class="token punctuation">)</span><span class="token punctuation">.</span>predict<span class="token punctuation">(</span>iris<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Number of mislabeled points out of a total %d points : %d"</span><span class="token operator">%</span> <span class="token punctuation">(</span>iris<span class="token punctuation">.</span>data<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">(</span>iris<span class="token punctuation">.</span>target <span class="token operator">!=</span> y_pred<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="多项分布朴素贝叶斯"><a href="#多项分布朴素贝叶斯" class="headerlink" title="多项分布朴素贝叶斯"></a>多项分布朴素贝叶斯</h3><p><code>MultinomiaNB</code>实现了服从多项分布数据的朴素贝叶斯算法.该算法常用于文本分类(此领域中文本常以词向量表示).分布参数由每类y的$\theta_y = (\theta_{y_1},…,\theta_{y_n})$,n式词汇量大小,$\theta_{y_i}$是样本中属于类y中特征i概念P($x_i|y$).<br>参数$\theta_y$使用平滑过的最大似然估计法来估计,即相对频率计数:<br>$$\hat\theta_{y_i} = \frac{N_{y_i}+\alpha}{N_{y}+\alpha{n}}$$<br>$N_{y_i}$是训练集T中特征i在类y中出现次数,$N_y$是类y中出现所有特征的次数总和.</p><p>$\alpha \geq 0$是为了防止出现0概率输出,$\alpha = 1$叫做拉普拉斯平滑,小于1叫做Lidstone平滑方法.</p><h3 id="补充朴素贝叶斯"><a href="#补充朴素贝叶斯" class="headerlink" title="补充朴素贝叶斯"></a>补充朴素贝叶斯</h3><p>ComplementNB实现了补充朴素贝叶斯(CNB)算法。CNB是标准多项式朴素贝叶斯(MNB)算法的一种改进，特别适用于不平衡数据集。具体来说，CNB使用来自每个类的补数的统计数据来计算模型的权重。CNB的发明者的研究表明，CNB的参数估计比MNB的参数估计更稳定。此外，CNB在文本分类任务上通常比MNB表现得更好(通常有相当大的优势)。</p><p>$$<br>\begin{aligned}<br>    \begin{aligned}\hat{\theta}<em>{ci} = \frac{\alpha_i + \sum</em>{j:y_j \neq c} d_{ij}}{\alpha + \sum_{j:y_j \neq c} \sum_{k} d_{kj}}<br>    \\w_{ci} = \log \hat{\theta}<em>{ci}<br>    \\w</em>{ci} = \frac{w_{ci}}{\sum_{j} |w_{cj}|}<br>    \end{aligned}<br>\end{aligned}<br>$$</p><h3 id="伯努利朴素贝叶斯分布"><a href="#伯努利朴素贝叶斯分布" class="headerlink" title="伯努利朴素贝叶斯分布"></a>伯努利朴素贝叶斯分布</h3><p><code>BernoulliNB </code>实现了用于多重伯努利分布数据的朴素贝叶斯训练和分类算法，即有多个特征，但每个特征 都假设是一个二元 (<code>Bernoulli</code>, <code>boolean</code>) 变量。 因此，这类算法要求样本以二元值特征向量表示；如果样本含有其他类型的数据， 一个 <code>BernoulliNB</code> 实例会将其二值化(取决于 <code>binarize</code> 参数)。</p><p>伯努利朴素贝叶斯的决策规则基于:<br>$$P(x_i \mid y) = P(i \mid y) x_i + (1 - P(i \mid y)) (1 - x_i)$$</p><h3 id="基于外存的朴素贝叶斯模型拟合"><a href="#基于外存的朴素贝叶斯模型拟合" class="headerlink" title="基于外存的朴素贝叶斯模型拟合"></a>基于外存的朴素贝叶斯模型拟合</h3><p>为了解决整个训练集不能导入内存的大规模分类问题,贝叶斯估计器实现了<code>partial_fit</code>方法,可以动态的增加数据,使用方法和其他分类器一样.</p><p>和fit方法不同,首次调用<code>partial_fit</code>方法需要传递一个所有期望的类标签的列表.</p><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>parsel库的使用</title>
      <link href="/2022/02/03/parsel%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/02/03/parsel%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="parsel"><a href="#parsel" class="headerlink" title="parsel"></a>parsel</h1><p><code>parsel</code>的<code>API</code>和<code>Scrapy</code>选择器的<code>API</code>高度相似,因为<code>Scrapy</code>选择器的是二次封装了<code>parsel</code>,类似于<code>request</code>和<code>urllib</code>.</p><p><code>parsel</code>可以解析<code>XML</code>和<code>HTML</code>,支持<code>Xpath</code>和<code>CSS</code>选择器对内容的提取,同时融合了正则表达式,可以说是前面几个工具的综合.</p><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">html <span class="token operator">=</span> <span class="token triple-quoted-string string">'''&lt;div id='container'>    &lt;li class='list'>first&lt;/li>    &lt;li>&lt;a href = 'item2'>second&lt;/a>&lt;/li>    &lt;li>&lt;a href = 'item3'>&lt;span>third&lt;/span>&lt;/a>&lt;/li>    &lt;li>&lt;a href = 'item4'>fourth&lt;/a>&lt;/li>    &lt;li>&lt;a href = 'item5'>fifth&lt;/a>&lt;/li>&lt;/div>'''</span><span class="token keyword">from</span> parsel <span class="token keyword">import</span> Selectorselector <span class="token operator">=</span> Selector<span class="token punctuation">(</span>text <span class="token operator">=</span> html<span class="token punctuation">)</span>  <span class="token comment">##调用Selector类构造一个Selector对象</span>css1 <span class="token operator">=</span> selector<span class="token punctuation">.</span>css<span class="token punctuation">(</span><span class="token string">'#container'</span><span class="token punctuation">)</span>  <span class="token comment">##传入css选择器</span>css2 <span class="token operator">=</span> selector<span class="token punctuation">.</span>css<span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span>  <span class="token comment">##传入css选择器,这个返回的是一个可迭代对象</span>xml1 <span class="token operator">=</span> selector<span class="token punctuation">.</span>xpath<span class="token punctuation">(</span><span class="token string">'//li[contains(@class,"list")]'</span><span class="token punctuation">)</span>xml2 <span class="token operator">=</span> selector<span class="token punctuation">.</span>xpath<span class="token punctuation">(</span><span class="token string">'//li/a[@href="item2"]'</span><span class="token punctuation">)</span><span class="token keyword">for</span> item <span class="token keyword">in</span> css1<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>xpath<span class="token punctuation">(</span><span class="token string">".//text()"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">##遍历获取文本内容</span>result_href <span class="token operator">=</span> xml2<span class="token punctuation">.</span>css<span class="token punctuation">(</span><span class="token string">'a::attr(href)'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">## css获取属性</span><span class="token keyword">print</span><span class="token punctuation">(</span>result_href<span class="token punctuation">)</span>result_href <span class="token operator">=</span> xml2<span class="token punctuation">.</span>xpath<span class="token punctuation">(</span><span class="token string">'//a/@href'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">##xpath获取属性</span><span class="token keyword">print</span><span class="token punctuation">(</span>result_href<span class="token punctuation">)</span><span class="token comment">## 正则的使用</span>re <span class="token operator">=</span> selector<span class="token punctuation">.</span>re<span class="token punctuation">(</span><span class="token string">'&lt;li>&lt;a.*?>.*?&lt;/a>&lt;/li>'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">)</span>re <span class="token operator">=</span> selector<span class="token punctuation">.</span>re_first<span class="token punctuation">(</span><span class="token string">'&lt;li>&lt;a.*?>.*?&lt;/a>&lt;/li>'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">)</span> <span class="token comment">##返回第一个匹配字符串</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 爬虫学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> parsel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pyquery的使用</title>
      <link href="/2022/02/03/pyquery%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/02/03/pyquery%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Pyquery"><a href="#Pyquery" class="headerlink" title="Pyquery"></a>Pyquery</h1><p>Pyquery是一个类似css选择器的东西,在解析HTML文本的时候需要先将其初始化为PyQuery对象.</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="字符串初始化"><a href="#字符串初始化" class="headerlink" title="字符串初始化"></a>字符串初始化</h3><p>直接将HTML的内容当作初始化参数.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pyquery <span class="token keyword">import</span> PyQuery <span class="token keyword">as</span> pqhtml <span class="token operator">=</span> <span class="token triple-quoted-string string">'''&lt;div>    &lt;li>first&lt;/li>    &lt;li>&lt;a href = 'item2'>second&lt;/a>&lt;/li>    &lt;li>&lt;a href = 'item3'>&lt;span>third&lt;/span>&lt;/a>&lt;/li>    &lt;li>&lt;a href = 'item4'>fourth&lt;/a>&lt;/li>    &lt;li>&lt;a href = 'item5'>fifth&lt;/a>&lt;/li>&lt;/div>'''</span>doc <span class="token operator">=</span> pq<span class="token punctuation">(</span>html<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>doc<span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">##输出所有li节点</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="URL初始化"><a href="#URL初始化" class="headerlink" title="URL初始化"></a>URL初始化</h3><p>还可以把一个网址的URL直接给PyQuery实例化,PyQuery对象就会请求这个URL,得到HTML内容进行初始化,效果与字符串初始化类似.</p><h3 id="文件初始化"><a href="#文件初始化" class="headerlink" title="文件初始化"></a>文件初始化</h3><p>还可以选择本地的文件进行初始化,参数指定为filename即可</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pyquery <span class="token keyword">import</span> PyQuery <span class="token keyword">as</span> pqdoc <span class="token operator">=</span> pq<span class="token punctuation">(</span>filename<span class="token operator">=</span>path<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>doc<span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">##输出所有li节点</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="基本CSS选择器"><a href="#基本CSS选择器" class="headerlink" title="基本CSS选择器"></a>基本CSS选择器</h2><p>首先,在CSS选择器中,<code>.</code>表示class属性,<code>#</code>表示id属性.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pyquery <span class="token keyword">import</span> PyQuery <span class="token keyword">as</span> pqhtml <span class="token operator">=</span> <span class="token triple-quoted-string string">'''&lt;div id='container'>    &lt;li>first&lt;/li>    &lt;li>&lt;a href = 'item2'>second&lt;/a>&lt;/li>    &lt;li>&lt;a href = 'item3'>&lt;span>third&lt;/span>&lt;/a>&lt;/li>    &lt;li>&lt;a href = 'item4'>fourth&lt;/a>&lt;/li>    &lt;li>&lt;a href = 'item5'>fifth&lt;/a>&lt;/li>&lt;/div>'''</span>doc <span class="token operator">=</span> pq<span class="token punctuation">(</span>html<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>doc<span class="token punctuation">(</span><span class="token string">'#container .item3 span'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">##先选取id为container的节点,再选取内部节点里面class为item1的节点内部为span的节点 既 &lt;span>third&lt;/span>,其类型也是PyQuery类</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h2><h3 id="子节点"><a href="#子节点" class="headerlink" title="子节点"></a>子节点</h3><p>find方法返回所有符合要求的子孙节点(子和孙),children方法返回所有满足要求的子节点.</p><h3 id="父节点"><a href="#父节点" class="headerlink" title="父节点"></a>父节点</h3><p>使用parent方法获取某个节点的父节点</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pyquery <span class="token keyword">import</span> PyQuery <span class="token keyword">as</span> pqhtml <span class="token operator">=</span> <span class="token triple-quoted-string string">'''&lt;div id='container'>    &lt;li class='list'>first&lt;/li>    &lt;li>&lt;a href = 'item2'>second&lt;/a>&lt;/li>    &lt;li>&lt;a href = 'item3'>&lt;span>third&lt;/span>&lt;/a>&lt;/li>    &lt;li>&lt;a href = 'item4'>fourth&lt;/a>&lt;/li>    &lt;li>&lt;a href = 'item5'>fifth&lt;/a>&lt;/li>&lt;/div>'''</span>doc <span class="token operator">=</span> pq<span class="token punctuation">(</span>html<span class="token punctuation">)</span><span class="token builtin">list</span> <span class="token operator">=</span> doc<span class="token punctuation">(</span><span class="token string">'.list'</span><span class="token punctuation">)</span>pa <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">.</span>parent<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>pa<span class="token punctuation">)</span><span class="token triple-quoted-string string">"""&lt;div id='container'>    &lt;li class='list'>first&lt;/li>&lt;/div>"""</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用parents方法获取某个节点的所有祖先节点,可以传CSS选择器来筛选祖先节点.</p><h3 id="兄弟节点"><a href="#兄弟节点" class="headerlink" title="兄弟节点"></a>兄弟节点</h3><p>使用siblings方法获取某个节点的兄弟节点,可以传CSS选择器来筛选兄弟节点.</p><h2 id="节点遍历"><a href="#节点遍历" class="headerlink" title="节点遍历"></a>节点遍历</h2><h3 id="内容获取"><a href="#内容获取" class="headerlink" title="内容获取"></a>内容获取</h3><p>对于单个节点的PyQuery对象,可以直接输出,如果是多个节点的PyQuery对象,则需要使用items方法将其转换成生成器,再使用for来输出.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pyquery <span class="token keyword">import</span> PyQuery <span class="token keyword">as</span> pqhtml <span class="token operator">=</span> <span class="token triple-quoted-string string">'''&lt;div id='container'>    &lt;li class='list'>first&lt;/li>    &lt;li>&lt;a href = 'item2'>second&lt;/a>&lt;/li>    &lt;li>&lt;a href = 'item3'>&lt;span>third&lt;/span>&lt;/a>&lt;/li>    &lt;li>&lt;a href = 'item4'>fourth&lt;/a>&lt;/li>    &lt;li>&lt;a href = 'item5'>fifth&lt;/a>&lt;/li>&lt;/div>'''</span>doc <span class="token operator">=</span> pq<span class="token punctuation">(</span>html<span class="token punctuation">)</span><span class="token builtin">list</span> <span class="token operator">=</span> doc<span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span>lis <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> each <span class="token keyword">in</span> lis<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>lis<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="属性获取"><a href="#属性获取" class="headerlink" title="属性获取"></a>属性获取</h3><p>使用attr方法获取属性,如果是多个节点的话默认返回第一个节点的属性,所以需要前面的items方法.</p><h3 id="获取文本"><a href="#获取文本" class="headerlink" title="获取文本"></a>获取文本</h3><p>使用text方法获取节点内部的文本(相当于拆掉了外面的标签)</p><h2 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h2><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">removeClass/addClass</td><td align="left">修改class属性</td></tr><tr><td align="left">attr</td><td align="left">增添属性种类及其内容(需要两个参数,一个是属性名,一个是属性值)</td></tr><tr><td align="left">text</td><td align="left">修改文本(同attr)</td></tr><tr><td align="left">html</td><td align="left">直接修改html文件(同attr)</td></tr><tr><td align="left">remove</td><td align="left">移除节点</td></tr></tbody></table><h2 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h2><p>伪类选择器的语法格式:</p><pre class="line-numbers language-none"><code class="language-none">css选择器:选择性质<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如</p><pre class="line-numbers language-none"><code class="language-none">li:first-child   第一个li子节点li:last-child    最后一个li子节点li:nth-child(2)  第二个li子节点li:nth-child(2n) 偶数个子节点li:contains(second) 包含second文本的子节点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 爬虫学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pyquery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xpath的使用</title>
      <link href="/2022/02/02/Xpath%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/02/02/Xpath%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Xpath"><a href="#Xpath" class="headerlink" title="Xpath"></a>Xpath</h1><h2 id="常用规则"><a href="#常用规则" class="headerlink" title="常用规则"></a>常用规则</h2><table><thead><tr><th align="left">符号</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">nodename</td><td align="left">选取此节点的所有结点</td></tr><tr><td align="left">/</td><td align="left">选取当前结点的子节点</td></tr><tr><td align="left">//</td><td align="left">选取当前结点的子孙(子和孙)结点</td></tr><tr><td align="left">.</td><td align="left">选取当前节点</td></tr><tr><td align="left">..</td><td align="left">选取当前节点的父节点</td></tr><tr><td align="left">/*</td><td align="left">选取所有结点</td></tr><tr><td align="left">@</td><td align="left">选取属性</td></tr></tbody></table><p>在使用的时候,常以<code>//</code>开头的Xpath规则来选择所有结点,后续再添加符号就行筛选.</p><p>在Xpath处理的时候先需要进行对文本进行处理,示例如下</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> lxml <span class="token keyword">import</span> etreehtml <span class="token operator">=</span> etree<span class="token punctuation">.</span>parse<span class="token punctuation">(</span>text<span class="token punctuation">,</span>etree<span class="token punctuation">.</span>HTMLParser<span class="token punctuation">)</span> <span class="token comment">## text指的是html格式的文本</span>result <span class="token operator">=</span> html<span class="token punctuation">.</span>xpath<span class="token punctuation">(</span>pattern<span class="token punctuation">)</span> <span class="token comment">##pattern值得是xpath pattern,选择的路径</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="属性匹配"><a href="#属性匹配" class="headerlink" title="属性匹配"></a>属性匹配</h3><p><code>[@+属性]</code>,例如需要查找<code>class = &#39;item1&#39;</code>的结点,直接使用</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;[@class&#x3D;&#39;item1&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="属性获取"><a href="#属性获取" class="headerlink" title="属性获取"></a>属性获取</h3><p>如果是要获取属性的话,直接<code>@/属性标签就行</code>,例如需要获得<code>a</code>标签的<code>href</code>属性,如下</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;a&#x2F;@href<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="属性多值匹配"><a href="#属性多值匹配" class="headerlink" title="属性多值匹配"></a>属性多值匹配</h3><p>面对有多个属性值的结点,如<code>&lt;a class = &#39;item1 item2&#39;&gt;</code>,如果使用<code>//a[@class=&#39;item1&#39;]</code>就匹配不到这个文本.</p><p>可以使用<code>contains</code>方法,改成<code>//a[contains(class,&#39;item1&#39;)]</code>,那么就能匹配到该文本.</p><h3 id="多属性匹配"><a href="#多属性匹配" class="headerlink" title="多属性匹配"></a>多属性匹配</h3><p>如果我们想要获取的结点要满足多个属性,如既要<code>class=&#39;item1&#39;</code>,而且<code>href=&#39;item2.html&#39;</code>,那么就要使用多属性匹配,示例如下:</p><pre class="line-numbers language-none"><code class="language-none">&#96;&#x2F;&#x2F;a[@class&#x3D;&#39;item1&#39; and @href&#x3D;&#39;item2.htm&#39;]&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面是XPath运算符及其解释</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">示例</th><th align="left">返回值</th></tr></thead><tbody><tr><td align="left">or</td><td align="left">或</td><td align="left">class=’item1’ or class=’item2’</td><td align="left">至少满足一个的结点</td></tr><tr><td align="left">and</td><td align="left">且</td><td align="left">class=’item1’ and class=’item2’</td><td align="left">都满足的结点</td></tr><tr><td align="left">|</td><td align="left">计算两个节点集</td><td align="left">class=’item1’ | class=’item2’</td><td align="left">返回所有拥有class=’item1’ 和 class=’item2’的节点集</td></tr></tbody></table><h2 id="按序选择"><a href="#按序选择" class="headerlink" title="按序选择"></a>按序选择</h2><p>当同时匹配多个节点的时候,如果想要第某一个节点,使用中括号里面加入索引方法(数字代表第几个,last表示最后一个,可以加入布尔表达式,比如position()&lt;4,就是返回第一个,第二个,第三个节点&gt;)就能做到按序选择</p><h2 id="节点轴选择"><a href="#节点轴选择" class="headerlink" title="节点轴选择"></a>节点轴选择</h2><p>节点轴关键字::修饰关键字</p><p>这就是一个节点轴选择的格式</p><table><thead><tr><th align="left">关键字</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">ancestor</td><td align="left">获取所有祖先节点</td></tr><tr><td align="left">attribute</td><td align="left">获取节点所有属性值</td></tr><tr><td align="left">child</td><td align="left">获取所有直接子节点</td></tr><tr><td align="left">descendant</td><td align="left">获取所有子孙节点</td></tr><tr><td align="left">following</td><td align="left">获取当且节点之后的所有节点</td></tr><tr><td align="left">following-sibling</td><td align="left">获取当前节点的所有同级节点</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 爬虫学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Xpath </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多元分析</title>
      <link href="/2022/01/29/%E5%A4%9A%E5%85%83%E5%88%86%E6%9E%90/"/>
      <url>/2022/01/29/%E5%A4%9A%E5%85%83%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="多元分析"><a href="#多元分析" class="headerlink" title="多元分析"></a>多元分析</h1><h2 id="聚类分析"><a href="#聚类分析" class="headerlink" title="聚类分析"></a>聚类分析</h2><p>聚类分析是对多个样本或者变量进行定量<strong>分类</strong>的一种方法.对样本进行分类叫做<strong>Q型聚类分析</strong>,对变量进行分类叫做<strong>R型聚类分析</strong>.</p><p>Q型聚类分析主要针对样本,是综合利用多个变量信息进行分类.R型聚类分析是分析的变量之间的亲疏关系.</p><h3 id="Q型聚类分析"><a href="#Q型聚类分析" class="headerlink" title="Q型聚类分析"></a>Q型聚类分析</h3><p>对一群待分类的样本有n个变量描述,所以每一个样本可以堪称$R^n$空间中的一个点,每个样本之间的亲疏关系可以通过样本点间距离进行度量.</p><p>在聚类分析中,对于定量变量,最常用的就是<strong>闵氏距离</strong>，即<br>$$d_q(x,y)=[∑_{k=1}^n∣x_k−y_k∣^q]^{\frac1q},q&gt;0$$<br>以下是当q取特定值时的距离:</p><ul><li>绝对值距离:$d_1(x,y) = [∑_{k=1}^n∣x_k−y_k∣]$</li><li>欧几里得距离: $d_2(x,y)=[∑_{k=1}^n∣x_k−y_k∣^2]^{\frac12}$</li><li>切比雪夫距离: $d_{\infty}(x,y) = max|x_k-y_k|$<br>为了克服闵氏距离对于量纲的一致性要求的缺点,可以使用马氏距离:<br>$$d(x,y)=\sqrt{(x-y)^T\Sigma^T(x-y)}$$<br>其中$\Sigma$时Z的协方差矩阵.</li></ul><p>类的相似度度量有如下方法:</p><ul><li>最短距离:顾名思义</li><li>最长距离:顾名思义</li><li>重心:重心之间的距离</li><li>类平均:$D(G_1,G_2)=\frac1{n_1n_2}∑_{x_i∈G_1}∑_{x_j∈G_2}d(x_i,x_j)$,n1,n2为点的个数</li><li>离差平方和</li></ul><p>对于这一类聚类分析,代码思路</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> scipy<span class="token punctuation">.</span>cluster<span class="token punctuation">.</span>hierarchy <span class="token keyword">import</span> linkage<span class="token keyword">from</span> scipy<span class="token punctuation">.</span>spatial<span class="token punctuation">.</span>distance <span class="token keyword">import</span> pdist<span class="token punctuation">,</span>squareformy <span class="token operator">=</span> pdist<span class="token punctuation">(</span>a<span class="token punctuation">,</span>method <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">)</span> <span class="token comment">##a是各个点坐标,method选择距离计算方法</span>yc <span class="token operator">=</span> squareform<span class="token punctuation">(</span>y<span class="token punctuation">)</span>       <span class="token comment">##将距离转换为距离对称方阵</span>z <span class="token operator">=</span> linkage<span class="token punctuation">(</span>y<span class="token punctuation">,</span>method <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">)</span> <span class="token comment">##y是各点距离,method参数选择,返回聚类</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="R型聚类分析"><a href="#R型聚类分析" class="headerlink" title="R型聚类分析"></a>R型聚类分析</h3><p>对于R型聚类分析的变量相似性度量,有两种相似性度量:</p><ul><li>相关系数:用两变量$x_j$与$x_k$的样本相关系数作为他们的相似性度量</li><li>夹角余弦:用两变量$x_j$与$x_k$的样本夹角余弦作为他们的相似性度量</li></ul><p>对于R型聚类分析的类与类的相似性度量,与Q型类似,对于实际分析的时候,先用R型聚类法从所有变量中选取几个有代表性的变量(剔除相关性较强的变量),再对选取变量进行Q型聚类分析.</p><h3 id="动态聚类法"><a href="#动态聚类法" class="headerlink" title="动态聚类法"></a>动态聚类法</h3><p>K-mean算法,见<a href="../Scipy%E5%AD%A6%E4%B9%A0">Scipy学习</a></p><h2 id="主成分分析"><a href="#主成分分析" class="headerlink" title="主成分分析"></a>主成分分析</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>主成分分析将许多相关性很高的变量转化成彼此相互独立或不相关的变量，并用以解释资料的综合性指标。<br>设$X_1,…,X_p$表示p个随机变量,$x_1,…,x_p$表示样本观测值,若能找到$c_1,…,c_p,并且\Sigma_{i=1}^pc_i^2 = 1$使得$D(\Sigma_{i=1}^p(c_iX_i))$最大,由于方差反应的是数据差异程度,也就表明我们找到了这p个变量的最不相关的因素,这个解是p维空间的一个单位向量,代表一个主成分方向.</p><p>为了代表原来的p个向量,需要求多个主成分方向,并且这几个主成分方向向量正交/协方差为0.可以理解为主成分方向是原来p个变量的线性组合,通过找矩阵秩的方式降低了变量个数.之后,再通过选择特征值大的特征向量来笼统代表p个向量(特征值大说明这个因素对整体的贡献高,特征值小的变量对整体贡献值小)</p><h3 id="特征值因子筛选"><a href="#特征值因子筛选" class="headerlink" title="特征值因子筛选"></a>特征值因子筛选</h3><p>设有p个指标变量$x_1,…,x_p$,在第i此的取值为$a_{i1},…,a_{ip}$,其矩阵形式为<br>$$<br>A = \begin{bmatrix}<br>a_{11}&amp;\ldots&amp;a_{1p}\\<br>\vdots&amp;\ddots&amp;\vdots\\<br>a_{n1}&amp;\ldots&amp;a_{np}\\<br>\end{bmatrix}<br>$$<br>称A为设计阵,$A^TA$为方阵,取前面的特征值使所取特征值所占比重超过85%，每个特征值所对应的特征向量即为一个主成分方向。</p><h3 id="主成分回归分析"><a href="#主成分回归分析" class="headerlink" title="主成分回归分析"></a>主成分回归分析</h3><p>首先需要对样本值中心标准化,设i次观测的样本j的值为$a_{ij}$,中心标准化之后的值为$a_{ij}^{‘}$</p><p>$$a_{ij}^{‘} = \frac{a_{ij} - u_j}{S_j}$$<br>$u_j$为样本j的均值,$S_j$为样本j的方差,令$A = {a_ij}$,则$(A^TA)X = X^T\Sigma$</p><p>在等到样本矩阵之后,如果样本数据数量级差距很大,则计算相关系数矩阵,反之,则计算协方差矩阵.</p><p>之后,根据计算出来的关系矩阵计算特征值(特征值是白化数据的方差,因为中心标准化之后,方差为1,特征值是拉伸倍数)和特征向量(是白化数据的旋转变换矩阵).选取较大特征值对应的特征向量(相当于降维,降低离散点的影响)组成,求出转移矩阵P,和原始数据X相乘得到新的数据Y. Y=PX. </p><h2 id="因子分析"><a href="#因子分析" class="headerlink" title="因子分析"></a>因子分析</h2><p>因子分析通过研究众多变量之间的内部依赖关系，探求观测数据中的基本结构，用少数几个假想变量来表示其基本数据结构。这几个假想变量能够反映原来众多变量的主要信息，原始的变量时可观测的显在变量，而假想变量是不可观测的潜在变量，称为因子。</p><p>因子分析和主成分分析类似,都是降维方式.</p><p>在开始分析之前需要进行KMO检验(大于0.7)和bartlett球形度检验(小于0.05),</p><h3 id="因子分析模型"><a href="#因子分析模型" class="headerlink" title="因子分析模型"></a>因子分析模型</h3><p>设P个变量$X_i$可以表示为<br>$$X_i = u_i + a_{i1}F_1 + … + a_{im}F_m + \epsilon_i, m \leq p(降维所以一定m不能比p大)$$<br>或矩阵表示<br>$$X_i - u_i = \Lambda F + \epsilon$$<br>F为公共因子,$\Lambda$为载荷因子,$\epsilon$为特殊因子,且<br>$$E(F) = 0, E(\epsilon) = 0,Cov(F) = I_m,D(\epsilon) = Cov(\epsilon) = diag(\sigma_1^2,…,\sigma_p^2)$$<br>$$Cov(X-u) = \Lambda{Cov(F)}\Lambda^T+Cov(\epsilon)= \Lambda\Lambda^T + diag(\sigma_1^2,…,\sigma_p^2)$$</p><h3 id="因子载荷矩阵估计方法"><a href="#因子载荷矩阵估计方法" class="headerlink" title="因子载荷矩阵估计方法"></a>因子载荷矩阵估计方法</h3><p>设$\lambda_1 \geq \lambda_2…\geq \lambda_p$为样本系数矩阵R特征值,$\eta_1,…,\eta_p$为对应的特征向量,取较大的m个特征值以及其特征向量组成因子载荷矩阵$\Lambda$,<br>$$\Lambda = [\sqrt{\lambda_1}\eta_1,…,\sqrt{\lambda_m}\eta_m]$$<br>(有点类似主成分分析)<br>特殊因子的方差用$R-\Lambda\Lambda^T$的对角元来估计,为<br>$$\sigma^2_i = 1 - \Sigma_{(j = 1)}^m{a_{ij}^2}$$</p><h3 id="因子旋转"><a href="#因子旋转" class="headerlink" title="因子旋转"></a>因子旋转</h3><p>建立因子分析模型的重要目的是为了知道每个公共因子的含义.因为载荷因子矩阵不唯一,为使后期分析工作方便,需要对载荷因子矩阵进行旋转,使得载荷因子矩阵的各个因子之间方差最大,类似主成分分析法找主成分方向.</p><p>从简化因子载荷矩阵的每一列出发，使和每个因子有关的载荷的平方的方差最大。当只有少数几个变量在某个因子上有较高的载荷时，对因子的解释最简单。方差最大的直观意义是希望通过因子旋转后，使每个因子上的载荷尽量拉开距离，一部分载荷趋于 ±1，另一部分趋于0。(这一部分可以直接交给第三方库去做)</p><h3 id="因子得分"><a href="#因子得分" class="headerlink" title="因子得分"></a>因子得分</h3><p>因子得分也就是公共因子的估计也很必要.因子得分则需要把公共因子表示为原变量的线性组合，因子得分函数：<br>$F_j=c_j+b_{j1}X_1+⋯+b_{jp}X_p ,j=1,2,⋯,m$<br>若将原始数据中心标准化,则<br>$\hat{F} = X_0R^{-1}\Lambda$</p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数理知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>灰色系统理论及其应用</title>
      <link href="/2022/01/28/%E7%81%B0%E8%89%B2%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
      <url>/2022/01/28/%E7%81%B0%E8%89%B2%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="灰色系统介绍"><a href="#灰色系统介绍" class="headerlink" title="灰色系统介绍"></a>灰色系统介绍</h2><p>灰色系统本质就是系统内部信息部分已知而部分信息未知的系统.如果所有信息都已知,如力和加速度的关系,那么这就是白色系统,反之则成为黑色系统.</p><p>灰色系统提出了一个和回归分析不同的分析方法-关联度分析方法,即根据因素之间发展态势的相似或相异程度来衡量因素间的关联程度.</p><h2 id="关联分析"><a href="#关联分析" class="headerlink" title="关联分析"></a>关联分析</h2><h3 id="关联系数的定义"><a href="#关联系数的定义" class="headerlink" title="关联系数的定义"></a>关联系数的定义</h3><p>$选取参考数列x_0 = {x_0(k)|k = 1,2,…,n}其中k表示时刻.假设有m个比较数列x_i={x_i(k)|k = 1,2,…,n}(i=1,2,…,m)$</p><p>$则称\xi_{i}(k) = \frac{\min_{s}min_{t}\left|x_{0}(t), - x_{s}(t)\right|,+\rho , \max_{s}max_{t} \left | x_{0}(t), - x_{s}(t) \right | }{\left | x_{0}(k), - x_{i}(k) \right | , + \rho , \max_{s}max_{t} \left | x_{0}(t), - x_{s}(t) \right | } \cdots \left ( 1 \right )$</p><p>$为比较数列x_{i} 对参考数列x_{0} 在k时刻的关联系数，  其中 \rho \in \left [ 0, 1 \right ] 为分辨系数；$</p><p>称（1）式中$\min_{s}min_{t}\left|x_{0}(t), - x_{s}(t)\right|,\max_{s}max_{t}\left|x_{0}(t), - x_{s}(t) \right|$分别为两级最小差，两级最大差。</p><h3 id="关联度的定义"><a href="#关联度的定义" class="headerlink" title="关联度的定义"></a>关联度的定义</h3><p>称<br>$$r_i =\frac{1}{n}\Sigma\xi_i(k)$$<br>为数列$x_i$对参考数列$x_0$的关联度.</p><p>易得关联度是各个时刻的关联系数集中的一个平均值</p><h2 id="优势分析"><a href="#优势分析" class="headerlink" title="优势分析"></a>优势分析</h2><p>假设有m个参考数列,记为$y_1,y_2,…,y_m$.有l个比较数列,记为$x_1,…,x_l$.显然每一个参考数列对l个比较数列都有l个关联度.令$r_{ij}$表示比较数列$x_j$对$y_i$的关联度,可构造关联度矩阵$R=(r_{ij})_{m*l}$若某一列元素大于其他列元素的时候称此列对应的比较数列(子因素)为优势子因素;若某一行元素大于其他行元素,则称此行对应的参考数列(母元素)为优势母元素.</p><h2 id="生成数"><a href="#生成数" class="headerlink" title="生成数"></a>生成数</h2><h3 id="累加生成"><a href="#累加生成" class="headerlink" title="累加生成"></a>累加生成</h3><p>把数列 x 各时刻数据依次累加的过程叫做<strong>累加过程</strong>，记作 <strong>AGO</strong>，累加所得的新数列，叫做<strong>累加生成数列</strong>。具体地，设原始数列为<br>$$x^{(0)} = (x^{(0)}(1),…,x^{(0)}(n)),累加生成数列记为x^{(1)} = (x^{(1)}(1),…,x^{(1)}(n)),且x^{(0)}与x^{(1)}满足 $$<br>$$x^{(1)}(k) = \Sigma^k_{i=\alpha}x^{(0)}(i),k = \alpha,…,n$$<br>$$其中\alpha\leq n为正整数.上述累加过程当1&lt;\alpha \leq k时称为去首累加成,当\alpha = 1时称为一般累加成.$$<br>$$当\alpha = 1时, 式子x^{(1)}中的上标(1)表示一次累加生成,记作1-AGO.再做一次累加生成可得二次累加生成,所以易得$$<br>$$x^{(r)}(k) = \Sigma^k_{i=1}x^{(r-1)}(i),k = 1,…,n$$</p><p>一般的,对于实际情况为非负的数列,累加生成可以使得生成数列为递增数列,对于有负数的数列可以使用移轴的方式再累加生成.</p><h3 id="累减生成"><a href="#累减生成" class="headerlink" title="累减生成"></a>累减生成</h3><p>对累加生成的还原就是累减生成<br>$$x^{(r-1)}(k) = x^{(r)}(k)-x^{(r)}(k-1),k = 1,…,n$$</p><h3 id="均值生成"><a href="#均值生成" class="headerlink" title="均值生成"></a>均值生成</h3><h4 id="邻值生成数"><a href="#邻值生成数" class="headerlink" title="邻值生成数"></a>邻值生成数</h4><p>设原始数列为$x^{(0)} = (x^{(0)}(1),…,x^{(0)}(n))$,则称$x^{(0)}(k-1)$与$x^{(0)}(k1)$为数列$x^{(0)}$的一对邻值,$x^{(0)}(k-1)$称为前值,$x^{(0)}(k1)$称为后值.</p><p>对数常数$\alpha \in [0,1]$,则称<br>$$z^(0)(k) = \alpha x^{(0)}(k)+(1-\alpha) x^{(0)}(k-1)$$<br>为由数列$x^{(0)}$的邻值在生成系数$\alpha$下的邻值生成数.</p><h4 id="等权邻值生成数"><a href="#等权邻值生成数" class="headerlink" title="等权邻值生成数"></a>等权邻值生成数</h4><p>当$\alpha=0.5$时,$z^(0)(k)$称为等权邻值生成数</p><h4 id="非邻值生成数"><a href="#非邻值生成数" class="headerlink" title="非邻值生成数"></a>非邻值生成数</h4><p>类似的,可定义非邻值生成数:<br>$$z^(0)(k) = \alpha x^{(0)}(k+1)+(1-\alpha) x^{(0)}(k-1)$$</p><h2 id="灰色模型"><a href="#灰色模型" class="headerlink" title="灰色模型"></a>灰色模型</h2><h3 id="GM-1-1-模型的定义"><a href="#GM-1-1-模型的定义" class="headerlink" title="GM(1,1)模型的定义"></a>GM(1,1)模型的定义</h3><p><strong>灰导数</strong><br>$$x^{(0)} = (x^{(0)}(1),…,x^{(0)}(n)),x^{(0)}的AGO生成数列为x^{(1)} = (x^{(1)}(1),…,x^{(1)}(n)),其中x^{(1)}(k) = \Sigma^k_{i=1}x^{(0)}(i)$$<br>$则定义x^{(1)}的灰导数为$<br>$$d(k) = x^{(0)}(k) =x^{(1)}(k) -x^{(1)}(k-1)$$<br><strong>GM(1,1)的灰微分方程模型</strong><br>$$令x^{(1)}为数列x^{(1)}的紧邻均值数列,即z^(1)(k) = 0.5 x^{(1)}(k)+0.5 x^{(1)}(k-1),于是定义GM(1,1)的灰微分方程模型为$$</p><p>$$d(k)+az^{(1)}(k) = b$$</p><p>其中$x^{(0)}(k)$称为灰导数,a称为发展系数,$z^{(1)}(k)$称为白化背景值,b称为灰作用量.</p><h3 id="参数向量估计"><a href="#参数向量估计" class="headerlink" title="参数向量估计"></a>参数向量估计</h3><p>将k=2,3,…,n带入灰微分方程<br>$$\begin{cases}<br>d(2)+az^{(1)}(2) = x^{(0)}(2)+az^{(1)}(2) = b\\<br>d(3)+az^{(1)}(3) = x^{(0)}(3)+az^{(1)}(3) = b\\<br>…….\\<br>d(n)+az^{(1)}(n) = x^{(0)}(n)+az^{(1)}(n) = b\\<br>\end{cases}<br>$$</p><p>$$令Y=(x^{(0)}(2),x^{(0)}(3),…,x^{(0)}(n))^T,u=(a,b)^T,<br>B =\begin{bmatrix}<br>-z^{(1)}(2)&amp;1\\<br>-z^{(1)}(3)&amp;1\\<br>{\vdots}&amp;{\vdots}\\<br>-z^{(1)}(n)&amp;1\\<br>\end{bmatrix}<br>$$<br>称Y为数据向量,B为数据矩阵,u为参数向量,GM(1,1)模型可以表示为Y = Bu</p><p>由最小二乘法可以求得<br>$$\hat{u} = (\hat{a},\hat{b})^T = (B^TB)^{-1}B^TY$$</p><h3 id="GM-1-1-白化型"><a href="#GM-1-1-白化型" class="headerlink" title="GM(1,1)白化型"></a>GM(1,1)白化型</h3><p>对于GM(1,1)的灰微分方程,如果将k视为连续变量t,则数列$x^{(0)}$可视作t的函数,记为 $x^{(0)} = $x^{(0)}$(t)$ ,则 $x^{(1)}$ 是 $x^{(0)}$ 的积分,于是可得白微分方程为<br>$$\frac{dx^{(1)}}{dt}+ax^{(1)} = b$$</p><h3 id="GM-1-N-模型定义"><a href="#GM-1-N-模型定义" class="headerlink" title="GM(1,N)模型定义"></a>GM(1,N)模型定义</h3><p><code>GM(1,1)</code>即表示模型是 1 阶的，且只含 1 个变量的灰色模型。而<code>GM(1, N)</code> 即表示模型是 1 阶的，包含有 N 个变量的灰色模型。<br>设系统由N个行为因子,其原始数列为$x_i^{(0)} = (x_i^{(0)}(1),…,x_i^{(0)}(n)),i=1,…,N$</p><p>其一阶累加生成数列为$x_i^{(1)} = (x_i^{(1)}(1),…,x_i^{(1)}(n)),i=1,…,N,x_i^{(1)}(k)=\Sigma ^k_{j=1}x_i^{(0)}(j)$</p><p>取$x_i^{(1)}$的均值数列为$z_i^{(1)}(k) = 0.5x_i^{(1)}(k)+0.5x_i^{(1)}(k-1)$</p><p>则均值数列$z_i^{(1)} = (z_i^{(1)}(1),…,z_i^{(1)}(n))$</p><p>于是可得GM(1,N)的灰微分方程为<br>$$x_i^{(0)}(k) + az_i^{(1)} = \Sigma^N_{(j\neq{i})}b_jx_j^{(1)}(k)$$<br>其中$x_i^{(0)}(k)$为灰导数,$z_i^{(1)}$为背景值,a,$b_j$为参数.</p><p>引入向量矩阵符号,令i=1得<br>$$Y = [x_1^{(0)}(1),..,x_1^{(0)}(n)]^T,u=[a,b_2,…,b_N]^T$$<br>$$B = \begin{bmatrix}<br>-z_1^{(1)}(2) &amp;x_2^{(1)}(2) &amp;{\cdots} &amp;x_N^{(1)}(2)\\<br>{\vdots}&amp;{\vdots}&amp;{\vdots}&amp;{\vdots}\\<br>-z_1^{(1)}(n) &amp;x_2^{(1)}(n) &amp;{\cdots} &amp;x_N^{(1)}(n)\\<br>\end{bmatrix}$$<br>则GM(1,N)的灰微分方程为<br>$$Y=Bu$$</p><h3 id="GM-1-N-模型的参数估计"><a href="#GM-1-N-模型的参数估计" class="headerlink" title="GM(1,N)模型的参数估计"></a>GM(1,N)模型的参数估计</h3><p>如果$(B^TB)^{-1}$存在,则$\hat{u} = (B^TB)^{-1}B^TY$</p><p>如果$(B^TB)^{-1}$不存在,比如n-1 &lt;br N,那么$\hat{u}$不能通过上式确定,但注意到$\hat{u}$是对各子因素对主因素影响大小的反映,所以通过引入加权矩阵 $W = diag(w_1,…,w_N)$,对各因素进行调节,对于未来发展减弱趋势的因素赋予较大权值,对于未来发展增强趋势的因素赋予较小权值,则<br>$$\hat{u} = W^{-1}B^T(B^{-1}B^T)^{-1}Y$$</p><h3 id="GM-1-N-白化型"><a href="#GM-1-N-白化型" class="headerlink" title="GM(1,N)白化型"></a>GM(1,N)白化型</h3><p>$$\frac{dx_1^{(1)}}{dt} + ax_1^{(1)}(t) = \Sigma^N_{(j\neq{1})}b_jx_j^{(1)}(k)$$</p><h2 id="Verhulst模型"><a href="#Verhulst模型" class="headerlink" title="Verhulst模型"></a>Verhulst模型</h2><p>GM(1,1)模型适用于具有较强指数规律的序列，只能描述单调的变化过程。故对于非单调的摆动发展序列或具有饱和状态的 S 形序列， Verhulst 模型，GM(2,1),DGM(2,1)模型等更适用。</p><p>Verhulst 模型主要用来描述具有饱和状态的过程， 即 S 形过程，常用于人口预测、生物生长、繁殖预测及产品经济寿命预测等。</p><h3 id="Verhulst模型简介"><a href="#Verhulst模型简介" class="headerlink" title="Verhulst模型简介"></a>Verhulst模型简介</h3><p>设$x^{(0)}$为原始数据序列<br>$$x^{(0)} = (x^{(0)}(1),…,x^{(0)}(n))$$<br>其一阶累加生成序列为<br>$$x^{(1)} = (x^{(1)}(1),…,x^{(1)}(n))$$<br>$z^{(1)}$为$x^{(1)}$的紧邻均值生成序列<br>$$z^{(1)} = (z^{(1)}(1),…,z^{(1)}(n))$$<br>则称<br>$$x^{(0)} + az^{(1)} = b(z^{(1)})^2$$<br>为Verhulst灰色模型,a和b为参数.<br>其解为<br>$$\hat{x}^{(1)}(k+1) = \frac{ax^{(1)}(1)}{bx^{(1)}(1)+(a-bx^{(1)}(1))e^{ak}}$$<br>可通过累减还原为$\hat{x}^{(0)}$ </p><p>称<br>$$\frac{dx^{(1)}}{dt}+ax^{(1)} = b(x^{(1)})^2$$<br>为Verhulst白化方程,a和b为参数.<br>其解为<br>$$x^{(1)}(t) = \frac{ax^{(1)}(1)}{bx^{(1)}(1)+(a-bx^{(1)}(1))e^{ak}}$$<br>$$B = \begin{bmatrix}<br>-z^{(1)}(2)&amp;(z^{(1)}(2))^2\\<br>(\vdots)&amp;(\vdots)\\<br>-z^{(1)}(n)&amp;(z^{(1)}(n))^2\\<br>\end{bmatrix},<br>Y = \begin{bmatrix}<br>x^{(0)}(2)\\<br>\vdots\\<br>x^{(0)}(n)\\<br>\end{bmatrix}$$<br>参数估计值为<br>$$\hat\alpha = (B^TB)^{(-1)}B^TY$$</p><h3 id="模型检验"><a href="#模型检验" class="headerlink" title="模型检验"></a>模型检验</h3><ul><li>残差合格检验</li><li>关联度合格检验</li><li>均方差比合格检验</li><li>小误差概率合格检验</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数理知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Geatpy学习</title>
      <link href="/2022/01/22/Geatpy%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/01/22/Geatpy%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="geatpy"><a href="#geatpy" class="headerlink" title="geatpy"></a>geatpy</h1><p>address:<a href="http://geatpy.com/index.php/home/">http://geatpy.com/index.php/home/</a></p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数学建模 </tag>
            
            <tag> Geatpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matplotlib学习</title>
      <link href="/2022/01/22/Matplotlib%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/01/22/Matplotlib%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h1><p>address:<a href="https://www.matplotlib.org.cn/tutorials/#%E5%BA%8F%E8%A8%80">https://www.matplotlib.org.cn/tutorials/#%E5%BA%8F%E8%A8%80</a></p><h2 id="基本绘图"><a href="#基本绘图" class="headerlink" title="基本绘图"></a>基本绘图</h2><p>提供一对相同长度的数组,然后使用plot()绘制曲线.</p><p>如果想绘制特别的曲线,有以下修饰</p><table><thead><tr><th align="left">颜色</th><th align="left">描述</th><th align="left">标记</th><th align="left">描述</th><th align="left">线条</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">‘b’</td><td align="left">蓝色</td><td align="left">‘.’</td><td align="left">点标记</td><td align="left">‘-‘</td><td align="left">实线</td></tr><tr><td align="left">‘g’</td><td align="left">绿色</td><td align="left">‘o’</td><td align="left">圆圈标记</td><td align="left">‘–’</td><td align="left">虚线</td></tr><tr><td align="left">‘r’</td><td align="left">红色</td><td align="left">‘x’</td><td align="left">x标记</td><td align="left">‘-.’</td><td align="left">点划线</td></tr><tr><td align="left">‘c’</td><td align="left">青色</td><td align="left">‘D’</td><td align="left">钻石标记</td><td align="left">‘:’</td><td align="left">虚线</td></tr><tr><td align="left">‘m’</td><td align="left">品红色</td><td align="left">‘H’</td><td align="left">六角标记</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">‘y’</td><td align="left">黄色</td><td align="left">‘s’</td><td align="left">正方形标记</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">‘k’</td><td align="left">黑色</td><td align="left">‘+’</td><td align="left">加号标记</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">‘w’</td><td align="left">白色</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><p>如果想在同一幅图里面绘制多条曲线,只需使用多条plot指令即可.如果您想清除图像，直接在程序末尾调用 clf() 方法即可。</p><h2 id="figure对象"><a href="#figure对象" class="headerlink" title="figure对象"></a>figure对象</h2><p>通过面向对象的思想,将图形封装为图形对象,就能更好的处理控制多个画布.Matplotlib 提供了<code>matplotlib.figure</code>图形类模块，它包含了创建图形对象的方法。通过调用 pyplot 模块中 figure() 函数来实例化 figure 对象。</p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">figsize</td><td align="left">指定画布的大小，(宽度,高度)，单位为英寸。</td></tr><tr><td align="left">dpi</td><td align="left">指定绘图对象的分辨率，即每英寸多少个像素，默认值为80。</td></tr><tr><td align="left">facecolor</td><td align="left">背景颜色。</td></tr><tr><td align="left">dgecolor</td><td align="left">边框颜色。</td></tr><tr><td align="left">frameon</td><td align="left">是否显示边框。</td></tr></tbody></table><p>创建画布的步骤如下;</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> plot <span class="token keyword">as</span> pltfig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">## 实例化figure对象</span>ax<span class="token operator">=</span>fig<span class="token punctuation">.</span>add_axes<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">## 添加axes域到画布,这样ax就是我们的画布了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>add_axes() 的参数值是一个序列，序列中的 4 个数字分别对应图形的左侧，底部，宽度，和高度，且每个数字必须介于 0 到 1 之间。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ax<span class="token punctuation">.</span>set_title<span class="token punctuation">(</span><span class="token string">"sine wave"</span><span class="token punctuation">)</span> <span class="token comment">##设置标题</span>ax<span class="token punctuation">.</span>set_xlabel<span class="token punctuation">(</span><span class="token string">'angle'</span><span class="token punctuation">)</span> <span class="token comment">##设置x轴标签</span>ax<span class="token punctuation">.</span>set_ylabel<span class="token punctuation">(</span><span class="token string">'sine'</span><span class="token punctuation">)</span> <span class="token comment">##设置y轴标签</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="axes类使用详解"><a href="#axes类使用详解" class="headerlink" title="axes类使用详解"></a>axes类使用详解</h2><p>Matplotlib 定义了一个 axes 类（轴域类），该类的对象被称为 axes 对象（即轴域对象），它指定了一个有数值范围限制的绘图区域。在一个给定的画布（figure）中可以包含多个 axes 对象，但是同一个 axes 对象只能在一个画布中使用。</p><p>也就是说一个figure里面能有多个axes对象,每个对象是一幅图,但是一个axes对象只能隶属一个figure画布.</p><p>通过调用 add_axes() 方法能够将 axes 对象添加到画布中，该方法用来生成一个 axes 轴域对象，对象的位置由参数rect决定。</p><p>rect 是位置参数，接受一个由 4 个元素组成的浮点数列表，形如 [left, bottom, width, height] ，它表示添加到画布中的矩形区域的左下角坐标(x, y)，以及宽度和高度。(每个参数都是相对于画布的分数,是相对距离)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ax<span class="token operator">=</span>fig<span class="token punctuation">.</span>add_axes<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0.1</span><span class="token punctuation">,</span><span class="token number">0.1</span><span class="token punctuation">,</span><span class="token number">0.8</span><span class="token punctuation">,</span><span class="token number">0.8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">##表示从画布10%开始画,高与宽是画布的80%</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="legend-绘制图例"><a href="#legend-绘制图例" class="headerlink" title="legend()绘制图例"></a>legend()绘制图例</h3><p>axes 类的 legend() 方法负责绘制画布中的图例，它需要三个参数</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ax<span class="token punctuation">.</span>legend<span class="token punctuation">(</span>handles<span class="token punctuation">,</span> labels<span class="token punctuation">,</span> loc<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>handles:是一个序列,包含了所有线的实例</li><li>labels:指定标签名称,也可以在plot的时候,直接命名label</li><li>loc:指定图例位置<blockquote><table><thead><tr><th align="left">位置</th><th align="left">字符串表示</th><th align="left">整数数字表示</th></tr></thead><tbody><tr><td align="left">自适应</td><td align="left">Best</td><td align="left">0</td></tr><tr><td align="left">右上方</td><td align="left">upper right</td><td align="left">1</td></tr><tr><td align="left">左上方</td><td align="left">upper left</td><td align="left">2</td></tr><tr><td align="left">左下</td><td align="left">lower left</td><td align="left">3</td></tr><tr><td align="left">右下</td><td align="left">lower right</td><td align="left">4</td></tr><tr><td align="left">右侧</td><td align="left">right</td><td align="left">5</td></tr><tr><td align="left">居中靠左</td><td align="left">center left</td><td align="left">6</td></tr><tr><td align="left">居中靠右</td><td align="left">center right</td><td align="left">7</td></tr><tr><td align="left">底部居中</td><td align="left">lower center</td><td align="left">8</td></tr><tr><td align="left">上部居中</td><td align="left">upper center</td><td align="left">9</td></tr><tr><td align="left">中部</td><td align="left">center</td><td align="left">10</td></tr></tbody></table></blockquote></li></ul><h3 id="axes-plot-方法"><a href="#axes-plot-方法" class="headerlink" title="axes.plot()方法"></a>axes.plot()方法</h3><p>这是axes的基本方法,将一个数组和另一个数组汇成线,其修饰符和plot方法类似</p><table><thead><tr><th align="left">颜色</th><th align="left">描述</th><th align="left">标记</th><th align="left">描述</th><th align="left">线条</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">‘b’</td><td align="left">蓝色</td><td align="left">‘.’</td><td align="left">点标记</td><td align="left">‘-‘</td><td align="left">实线</td></tr><tr><td align="left">‘g’</td><td align="left">绿色</td><td align="left">‘o’</td><td align="left">圆圈标记</td><td align="left">‘–’</td><td align="left">虚线</td></tr><tr><td align="left">‘r’</td><td align="left">红色</td><td align="left">‘x’</td><td align="left">x标记</td><td align="left">‘-.’</td><td align="left">点划线</td></tr><tr><td align="left">‘c’</td><td align="left">青色</td><td align="left">‘D’</td><td align="left">钻石标记</td><td align="left">‘:’</td><td align="left">虚线</td></tr><tr><td align="left">‘m’</td><td align="left">品红色</td><td align="left">‘H’</td><td align="left">六角标记</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">‘y’</td><td align="left">黄色</td><td align="left">‘s’</td><td align="left">正方形标记</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">‘k’</td><td align="left">黑色</td><td align="left">‘+’</td><td align="left">加号标记</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">‘w’</td><td align="left">白色</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><h3 id="axes-grid-设置网格格式"><a href="#axes-grid-设置网格格式" class="headerlink" title="axes.grid()设置网格格式"></a>axes.grid()设置网格格式</h3><p>rid() 方法可以开启或者关闭画布中的网格（即是否显示网格）以及网格的主/次刻度。除此之外，grid() 函数还可以设置网格的颜色、线型以及线宽等属性。网格在默认状态下是关闭的，通过调用上述函数，网格会被自动开启，如果只是想开启不带任何样式的网格，可以通过 grid(True) 来实现。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">grid<span class="token punctuation">(</span>color<span class="token punctuation">,</span> ls<span class="token punctuation">,</span> lw<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>color:网格线的颜色</li><li>ls:网格线的样式</li><li>lw:网格线的宽度<h3 id="设置坐标轴格式"><a href="#设置坐标轴格式" class="headerlink" title="设置坐标轴格式"></a>设置坐标轴格式</h3>有时候不同的函数关系,x和y的刻度不应该相同,所以需要通过scale属性设置.</li></ul><p>轴是连接刻度的线，也就是绘图区域的边界，在绘图区域（axes 对象）的顶部、底部、左侧和右侧都有一个边界线（轴）。通过指定轴的颜色和宽度，从而对进行显示格式设置，比如将所有轴的颜色设置为 None，那么它们都会成为隐藏状态，或者也可以给轴添加相应的颜色。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> pltfig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token punctuation">)</span>ax <span class="token operator">=</span> fig<span class="token punctuation">.</span>add_axes<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#为左侧轴，底部轴添加颜色</span>ax<span class="token punctuation">.</span>spines<span class="token punctuation">[</span><span class="token string">'bottom'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_color<span class="token punctuation">(</span><span class="token string">'blue'</span><span class="token punctuation">)</span>ax<span class="token punctuation">.</span>spines<span class="token punctuation">[</span><span class="token string">'left'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_color<span class="token punctuation">(</span><span class="token string">'red'</span><span class="token punctuation">)</span>ax<span class="token punctuation">.</span>spines<span class="token punctuation">[</span><span class="token string">'left'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_linewidth<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment">#将侧轴、顶部轴设置为None</span>ax<span class="token punctuation">.</span>spines<span class="token punctuation">[</span><span class="token string">'right'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_color<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">)</span>ax<span class="token punctuation">.</span>spines<span class="token punctuation">[</span><span class="token string">'top'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_color<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">)</span>ax<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="设置坐标轴范围"><a href="#设置坐标轴范围" class="headerlink" title="设置坐标轴范围"></a>设置坐标轴范围</h3><p>Matplotlib 可以根据自变量与因变量的取值范围，自动设置 x 轴与 y 轴的数值大小。当然，您也可以用自定义的方式，通过 set_xlim() 和 set_ylim() 对 x、y 轴的数值范围进行设置。当对 3D 图像进行设置的时，会增加一个 z 轴，此时使用 set_zlim() 可以对 z 轴进行设置。</p><p>示例如下:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> npy<span class="token comment">##生成画布</span>fig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token punctuation">)</span>ax1 <span class="token operator">=</span> fig<span class="token punctuation">.</span>add_axes<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0.5</span><span class="token punctuation">,</span><span class="token number">0.5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">##自变量生成</span>x <span class="token operator">=</span> npy<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">*</span>npy<span class="token punctuation">.</span>pi<span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token comment">##绘图区域生成</span>ax1<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span>npy<span class="token punctuation">.</span>cos<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">'r--'</span><span class="token punctuation">,</span>label<span class="token operator">=</span><span class="token string">'cos'</span><span class="token punctuation">)</span>ax1<span class="token punctuation">.</span>legend<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">##设置y轴取值范围</span>ax1<span class="token punctuation">.</span>set_ylim<span class="token punctuation">(</span><span class="token operator">-</span>npy<span class="token punctuation">.</span>pi<span class="token punctuation">,</span>npy<span class="token punctuation">.</span>pi<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="设置刻度和刻度标签"><a href="#设置刻度和刻度标签" class="headerlink" title="设置刻度和刻度标签"></a>设置刻度和刻度标签</h3><p>如果需要将刻度设置为“英文数字形式”或者“大写阿拉伯数字”，自带的刻度就需要自己重新设置。</p><p>xticks() 和 yticks() 函数接受一个列表对象作为参数，列表中的元素表示对应数轴上要显示的刻度。如:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ax<span class="token punctuation">.</span>set_xticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以分别通过 set_xticklabels() 和 set_yticklabels() 函数设置与刻度线相对应的刻度标签。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> npy<span class="token comment">##生成画布对象</span>fig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#添加绘图区域</span>ax <span class="token operator">=</span> fig<span class="token punctuation">.</span>add_axes<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token number">0.8</span><span class="token punctuation">,</span> <span class="token number">0.8</span><span class="token punctuation">]</span><span class="token punctuation">)</span>y <span class="token operator">=</span> npy<span class="token punctuation">.</span>cos<span class="token punctuation">(</span>x<span class="token punctuation">)</span>ax<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token comment">#设置x轴标签</span>ax<span class="token punctuation">.</span>set_xlabel<span class="token punctuation">(</span>‘angle’<span class="token punctuation">)</span>ax<span class="token punctuation">.</span>set_title<span class="token punctuation">(</span><span class="token string">'sin'</span><span class="token punctuation">)</span>ax<span class="token punctuation">.</span>set_xticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#设置x轴刻度标签</span>ax<span class="token punctuation">.</span>set_xticklabels<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'zero'</span><span class="token punctuation">,</span><span class="token string">'two'</span><span class="token punctuation">,</span><span class="token string">'four'</span><span class="token punctuation">,</span><span class="token string">'six'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#设置y轴刻度</span>ax<span class="token punctuation">.</span>set_yticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="subplot-函数"><a href="#subplot-函数" class="headerlink" title="subplot()函数"></a>subplot()函数</h2><p>matplotlib.pyplot模块提供了一个 subplot() 函数，它可以均等地划分画布，该函数的参数格式如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span>nrows<span class="token punctuation">,</span> ncols<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>subplot如果出现了图像重叠,那么之前的那幅图就会被消除,但是,如果使用figure对象的add_subplot方法就不会被消除,而是两幅图重叠一起.</p><p>通过给figure画布创建多个axes对象也能做到subplot的效果.</p><h2 id="subplots-函数"><a href="#subplots-函数" class="headerlink" title="subplots()函数"></a>subplots()函数</h2><p>subplots() 函数和 subplot() 函数类似。其不同之处在于，subplots() 既创建了一个包含子图区域的画布，又创建了一个 figure 图形对象，而 subplot() 只是创建一个包含子图区域的画布。<br>格式如下</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">fig <span class="token punctuation">,</span> ax <span class="token operator">=</span> plt<span class="token punctuation">.</span>subplots<span class="token punctuation">(</span>nrows<span class="token punctuation">,</span> ncols<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>实例:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> pltfig<span class="token punctuation">,</span>a <span class="token operator">=</span>  plt<span class="token punctuation">.</span>subplots<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">import</span> numpy <span class="token keyword">as</span> npx <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token comment">#绘制平方函数</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span>x<span class="token operator">*</span>x<span class="token punctuation">)</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_title<span class="token punctuation">(</span><span class="token string">'square'</span><span class="token punctuation">)</span><span class="token comment">#绘制平方根图像</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span>np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_title<span class="token punctuation">(</span><span class="token string">'square root'</span><span class="token punctuation">)</span><span class="token comment">#绘制指数函数</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span>np<span class="token punctuation">.</span>exp<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_title<span class="token punctuation">(</span><span class="token string">'exp'</span><span class="token punctuation">)</span><span class="token comment">#绘制对数函数</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span>np<span class="token punctuation">.</span>log10<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_title<span class="token punctuation">(</span><span class="token string">'log'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="subplot2grid-函数"><a href="#subplot2grid-函数" class="headerlink" title="subplot2grid()函数"></a>subplot2grid()函数</h2><p> subplot2grid()能够在画布的特定位置创建 axes 对象（即绘图区域）。不仅如此，它还可以使用不同数量的行、列来创建跨度不同的绘图区域。与 subplot() 和 subplots() 函数不同，subplot2gird() 函数以非等分的形式对画布进行切分，并按照绘图区域的大小来展示最终绘图结果。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">plt<span class="token punctuation">.</span>subplot2grid<span class="token punctuation">(</span>shape<span class="token punctuation">,</span> location<span class="token punctuation">,</span> rowspan<span class="token punctuation">,</span> colspan<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>shape：把该参数值规定的网格区域作为绘图区域；</li><li>location：在给定的位置绘制图形，初始位置 (0,0) 表示第1行第1列；</li><li>rowsapan/colspan：这两个参数用来设置让子区跨越几行几列。<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment">#使用 colspan指定列，使用rowspan指定行</span>a1 <span class="token operator">=</span> plt<span class="token punctuation">.</span>subplot2grid<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>colspan <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span>a2 <span class="token operator">=</span> plt<span class="token punctuation">.</span>subplot2grid<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> rowspan <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span>a3 <span class="token operator">=</span> plt<span class="token punctuation">.</span>subplot2grid<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>rowspan <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> colspan <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span>x <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span>a2<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span> x<span class="token operator">*</span>x<span class="token punctuation">)</span>a2<span class="token punctuation">.</span>set_title<span class="token punctuation">(</span><span class="token string">'square'</span><span class="token punctuation">)</span>a1<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span> np<span class="token punctuation">.</span>exp<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>a1<span class="token punctuation">.</span>set_title<span class="token punctuation">(</span><span class="token string">'exp'</span><span class="token punctuation">)</span>a3<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span> np<span class="token punctuation">.</span>log<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>a3<span class="token punctuation">.</span>set_title<span class="token punctuation">(</span><span class="token string">'log'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>tight_layout<span class="token punctuation">(</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="双轴图"><a href="#双轴图" class="headerlink" title="双轴图"></a>双轴图</h2><p>在需要两个x轴或者两个y轴的情况下,可以使用Matplotlib提供的twinx()和twiny()函数,实现双轴功能.<br>绘制指数函数和对数函数的示例如下:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> npy<span class="token comment">## 布置画布</span>fig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token punctuation">)</span>ax1 <span class="token operator">=</span> fig<span class="token punctuation">.</span>add_axes<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">## 准备自变量x</span>x <span class="token operator">=</span> npy<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token comment">## 绘制指数函数</span>ax1<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span>npy<span class="token punctuation">.</span>exp<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">'r'</span><span class="token punctuation">,</span>label<span class="token operator">=</span><span class="token string">'exp'</span><span class="token punctuation">)</span>ax1<span class="token punctuation">.</span>set_ylabel<span class="token punctuation">(</span><span class="token string">'exp'</span><span class="token punctuation">)</span>ax1<span class="token punctuation">.</span>legend<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">## 绘制对数函数</span>ax2 <span class="token operator">=</span> ax1<span class="token punctuation">.</span>twiny<span class="token punctuation">(</span><span class="token punctuation">)</span>ax2<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">[</span>x<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>npy<span class="token punctuation">.</span>log<span class="token punctuation">(</span>x<span class="token punctuation">[</span>x<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">'b--'</span><span class="token punctuation">,</span>label<span class="token operator">=</span><span class="token string">'log'</span><span class="token punctuation">)</span>ax2<span class="token punctuation">.</span>set_ylabel<span class="token punctuation">(</span><span class="token string">'log'</span><span class="token punctuation">)</span>ax2<span class="token punctuation">.</span>legend<span class="token punctuation">(</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h2><p>Matplotlib 提供了bar()函数来绘制柱状图。当它与 axes 对象一起使用时，其语法格式如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ax<span class="token punctuation">.</span>bar<span class="token punctuation">(</span>x<span class="token punctuation">,</span> height<span class="token punctuation">,</span> width<span class="token punctuation">,</span> bottom<span class="token punctuation">,</span> align<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>x:标量,代表x坐标</li><li>height:标量序列,表示柱状图高度</li><li>width:可选参数,表示柱状图宽度</li><li>bottom:表示柱状图开始堆叠的起始值</li><li>align:有两个可选项 {“center”,”edge”}，默认为 ‘center’，该参数决定 x 值位于柱状图的位置。</li></ul><h2 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h2><p>语法格式:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">hist<span class="token punctuation">(</span>x<span class="token punctuation">,</span>bins<span class="token punctuation">,</span><span class="token builtin">range</span><span class="token punctuation">,</span>density<span class="token punctuation">,</span>histtype<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>x:数组或者数组序列</li><li>bins:可选参数,整数或者序列，表示每一个间隔的边缘（起点和终点）默认会生成10个间隔。</li><li>range:指定全局间隔的下限与上限值 (min,max)，元组类型，默认值为 None。</li><li>density:如果为 True，返回概率密度直方图；默认为 False，返回相应区间元素的个数的直方图。</li><li>histtype:要绘制的直方图类型，默认值为“bar”，可选值有 barstacked(堆叠条形图)、step(未填充的阶梯图)、stepfilled(已填充的阶梯图)。</li></ul><h2 id="饼状图"><a href="#饼状图" class="headerlink" title="饼状图"></a>饼状图</h2><p>Matplotlib 提供了一个 pie() 函数，该函数可以生成数组中数据的饼状图。您可使用 x/sum(x) 来计算各个扇形区域占饼图总和的百分比。pie() 函数的参数说明如下：</p><pre class="line-numbers language-none"><code class="language-none">pie(x,labels,color,autopct)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>x:数组</li><li>labels:字符串序列,给每一个扇形区域备注一个名字</li><li>color:为每个扇形区域设置颜色,默认按照颜色周期填充</li><li>autopct:     格式化字符串”fmt%pct”，使用百分比的格式设置每个扇形<br>区的标签，并将其放置在扇形区内。</li></ul><h2 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h2><p>matplotlib里面没有绘制折线图的函数,但是可以通过调用text()的方法在图像上绘制注释文本的方法,示例如下:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment">#准备绘制数据</span>x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Mon"</span><span class="token punctuation">,</span> <span class="token string">"Tues"</span><span class="token punctuation">,</span> <span class="token string">"Wed"</span><span class="token punctuation">,</span> <span class="token string">"Thur"</span><span class="token punctuation">,</span> <span class="token string">"Fri"</span><span class="token punctuation">,</span><span class="token string">"Sat"</span><span class="token punctuation">,</span><span class="token string">"Sun"</span><span class="token punctuation">]</span>y <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">,</span> <span class="token number">55</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">]</span><span class="token comment"># "g" 表示红色，marksize用来设置'D'菱形的大小</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> <span class="token string">"g"</span><span class="token punctuation">,</span> marker<span class="token operator">=</span><span class="token string">'D'</span><span class="token punctuation">,</span> markersize<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">"周活"</span><span class="token punctuation">)</span><span class="token comment">#绘制坐标轴标签</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">"登录时间"</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">"用户活跃度"</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">"C语言中文网活跃度"</span><span class="token punctuation">)</span><span class="token comment">#显示图例</span>plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span>loc<span class="token operator">=</span><span class="token string">"lower right"</span><span class="token punctuation">)</span><span class="token comment">#调用 text()在图像上绘制注释文本</span><span class="token comment">#x1、y1表示文本所处坐标位置，ha参数控制水平对齐方式, va控制垂直对齐方式，str(y1)表示要绘制的文本</span><span class="token keyword">for</span> x1<span class="token punctuation">,</span> y1 <span class="token keyword">in</span> <span class="token builtin">zip</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>    plt<span class="token punctuation">.</span>text<span class="token punctuation">(</span>x1<span class="token punctuation">,</span> y1<span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">(</span>y1<span class="token punctuation">)</span><span class="token punctuation">,</span> ha<span class="token operator">=</span><span class="token string">'center'</span><span class="token punctuation">,</span> va<span class="token operator">=</span><span class="token string">'bottom'</span><span class="token punctuation">,</span> fontsize<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token comment">#保存图片</span>plt<span class="token punctuation">.</span>savefig<span class="token punctuation">(</span><span class="token string">"1.jpg"</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h2><p>散点图的语法规范:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">scatter<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> color<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>x:自变量</li><li>y:因变量</li><li>color:点的颜色</li></ul><h2 id="等高线图"><a href="#等高线图" class="headerlink" title="等高线图"></a>等高线图</h2><p>如果您想要查看因变量 Z 与自变量 X、Y 之间的函数图像变化（即 Z=f(X,Y)），那么采用等高线图最为直观。</p><p><code>numpy</code>里面有函数<code>meshgrid</code>构建网格点矩阵.</p><p>在matplotlob API里面提供了绘制等高线（<code>contour</code>）与填充等高线（ <code>contourf</code>）的函数。这两个函数都需要三个参数，分别是 X、Y 与 Z。</p><p>示例:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> npy<span class="token comment">## 构建500*500的网格</span>x <span class="token operator">=</span> npy<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">500</span><span class="token punctuation">)</span>y <span class="token operator">=</span> npy<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">500</span><span class="token punctuation">)</span>X<span class="token punctuation">,</span>Y <span class="token operator">=</span> npy<span class="token punctuation">.</span>meshgrid<span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token comment">## 构建画布</span>fig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token punctuation">)</span>ax1 <span class="token operator">=</span> fig<span class="token punctuation">.</span>add_axes<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">## 构建函数</span>Z <span class="token operator">=</span> npy<span class="token punctuation">.</span>log<span class="token punctuation">(</span>X<span class="token operator">**</span><span class="token number">2</span><span class="token operator">+</span>Y<span class="token operator">**</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token comment">## 构建等高线</span>cp <span class="token operator">=</span> ax1<span class="token punctuation">.</span>contourf<span class="token punctuation">(</span>X<span class="token punctuation">,</span>Y<span class="token punctuation">,</span>Z<span class="token punctuation">)</span>fig<span class="token punctuation">.</span>colorbar<span class="token punctuation">(</span>cp<span class="token punctuation">)</span> <span class="token comment">##添加颜色柱</span>ax1<span class="token punctuation">.</span>set_title<span class="token punctuation">(</span><span class="token string">'Test'</span><span class="token punctuation">)</span>ax1<span class="token punctuation">.</span>set_ylabel<span class="token punctuation">(</span><span class="token string">'Y'</span><span class="token punctuation">)</span>ax1<span class="token punctuation">.</span>set_xlabel<span class="token punctuation">(</span><span class="token string">'X'</span><span class="token punctuation">)</span><span class="token comment">## 画等高线</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3D绘图"><a href="#3D绘图" class="headerlink" title="3D绘图"></a>3D绘图</h2><p>通过调用<code>matplotlib</code>的绘图工具包<code>mpl_toolkits.mplot3d</code>的一些接口可以实现绘制3D图形.</p><h3 id="基础绘图"><a href="#基础绘图" class="headerlink" title="基础绘图"></a>基础绘图</h3><p>首先需要创建一个<code>3D</code>绘图区域,<code>pyplot.axes()</code>这个<code>axes</code>对象构造方法提供了一个参数<code>projection</code>,将其参数值设置为<code>3d</code>.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> mpl_toolkits <span class="token keyword">import</span> mplot3d <span class="token keyword">as</span> m3d<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> npyax1 <span class="token operator">=</span> plt<span class="token punctuation">.</span>axes<span class="token punctuation">(</span>projection<span class="token operator">=</span><span class="token string">'3d'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后构建<code>3D</code>图像</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#从x,y,z轴开始构建</span>x <span class="token operator">=</span> npy<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">)</span>y <span class="token operator">=</span> npy<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">)</span>z <span class="token operator">=</span> npy<span class="token punctuation">.</span>exp<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">+</span>npy<span class="token punctuation">.</span>hstack<span class="token punctuation">(</span><span class="token punctuation">(</span>npy<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>npy<span class="token punctuation">.</span>log<span class="token punctuation">(</span>y<span class="token punctuation">[</span>y<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>最后调用<code>plot3D()</code>方法构建<code>3d</code>图形</p><pre class="line-numbers language-none"><code class="language-none">ax1.plot3D(x,y,z,&#39;b&#39;)ax1.set_title(&#39;The first 3D&#39;)plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3D散点图"><a href="#3D散点图" class="headerlink" title="3D散点图"></a>3D散点图</h3><p><code>ax.scatter3D()</code>函数可以绘制 3D 散点图</p><h3 id="3D等高线图"><a href="#3D等高线图" class="headerlink" title="3D等高线图"></a>3D等高线图</h3><p><code>ax.contour3D()</code>可以用来创建三维等高线图</p><h3 id="3D线框图"><a href="#3D线框图" class="headerlink" title="3D线框图"></a>3D线框图</h3><p><code>plot_wireframe()</code>能够绘制 3D 线框图。</p><h3 id="3D曲线图"><a href="#3D曲线图" class="headerlink" title="3D曲线图"></a>3D曲线图</h3><p><code>plot_surface()</code>函数可以绘制 3D 曲面图</p><h2 id="Matplotlib绘制文本"><a href="#Matplotlib绘制文本" class="headerlink" title="Matplotlib绘制文本"></a>Matplotlib绘制文本</h2><p><code>Matplotlib</code>通过下列函数绘制出相应内容</p><table><thead><tr><th align="left">函数</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">text</td><td align="left">在绘图区域的任意位置添加文本。</td></tr><tr><td align="left">annotate</td><td align="left">在绘图区域的任意位置添加带有可选箭头的注释。</td></tr><tr><td align="left">xlabel</td><td align="left">在绘图区域的 x 轴上添加标签。</td></tr><tr><td align="left">ylabel</td><td align="left">在绘图区域的 y 轴上添加标签。</td></tr><tr><td align="left">title</td><td align="left">为绘图区域添加标题。</td></tr><tr><td align="left">figtext</td><td align="left">在画布的任意位置添加文本。</td></tr><tr><td align="left">suptitle</td><td align="left">为画布中添加标题。</td></tr></tbody></table><h2 id="Matplotlib数学表达式"><a href="#Matplotlib数学表达式" class="headerlink" title="Matplotlib数学表达式"></a>Matplotlib数学表达式</h2><p>Matplotlib 中的文本字符串都可以使用 Text Markup（一种文本标记语言）显现出来，Text Markup类似Mathjax.</p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数学建模 </tag>
            
            <tag> Matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scipy学习</title>
      <link href="/2022/01/22/Scipy%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/01/22/Scipy%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Scipy"><a href="#Scipy" class="headerlink" title="Scipy"></a>Scipy</h1><p>address:<a href="https://scipy.github.io/devdocs/tutorial/index.html">https://scipy.github.io/devdocs/tutorial/index.html</a></p><h2 id="Scipy内置模块"><a href="#Scipy内置模块" class="headerlink" title="Scipy内置模块"></a>Scipy内置模块</h2><table><thead><tr><th align="left">模块名</th><th align="left">功能</th><th align="left">参考文档</th></tr></thead><tbody><tr><td align="left">scipy.constants</td><td align="left">数学常量</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/constants.html">constants API</a></td></tr><tr><td align="left">scipy.cluster</td><td align="left">向量量化</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/cluster.html#module-scipy.cluster">cluster API</a></td></tr><tr><td align="left">scipy.fftpack</td><td align="left">快速傅里叶变换</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/fftpack.html#module-scipy.fftpack">fft API</a></td></tr><tr><td align="left">scipy.integrate</td><td align="left">积分</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/integrate.html#module-scipy.integrate">integrate API</a></td></tr><tr><td align="left">scipy.interpolate</td><td align="left">插值</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/interpolate.html#module-scipy.interpolate">interpolate API</a></td></tr><tr><td align="left">scipy.io</td><td align="left">数据输入输出</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/io.html#module-scipy.io">io API</a></td></tr><tr><td align="left">scipy.linalg</td><td align="left">线性代数</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/linalg.html#module-scipy.linalg">linalg API</a></td></tr><tr><td align="left">scipy.ndimage</td><td align="left">N 维图像</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/ndimage.html#module-scipy.ndimage">ndimage API</a></td></tr><tr><td align="left">scipy.odr</td><td align="left">正交距离回归</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/odr.html#module-scipy.odr">odr API</a></td></tr><tr><td align="left">scipy.optimize</td><td align="left">优化算法</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/optimize.html#module-scipy.optimize">optimize API</a></td></tr><tr><td align="left">scipy.signal</td><td align="left">信号处理</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/signal.html#module-scipy.signal">signal API</a></td></tr><tr><td align="left">scipy.sparse</td><td align="left">稀疏矩阵</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/sparse.html#module-scipy.sparse">sparse API</a></td></tr><tr><td align="left">scipy.spatial</td><td align="left">空间数据结构和算法</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/spatial.html#module-scipy.spatial">spatial API</a></td></tr><tr><td align="left">scipy.special</td><td align="left">特殊数学函数</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/special.html#module-scipy.special">special API</a></td></tr><tr><td align="left">scipy.stats</td><td align="left">统计函数</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/stats.html#module-scipy.stats">stats.mstats API</a></td></tr><tr><td align="left">scipy.misc</td><td align="left">图像处理</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/misc.html">misc API</a></td></tr></tbody></table><h2 id="Scipy常数模块"><a href="#Scipy常数模块" class="headerlink" title="Scipy常数模块"></a>Scipy常数模块</h2><p><code>Scipy.constants</code>模块内置多种常数,包括:</p><ul><li>公制单位</li><li>字节为单位的二进制</li><li>质量单位</li><li>角度换算</li><li>时间单位</li><li>长度单位</li><li>压强单位</li><li>体积单位</li><li>速度单位</li><li>温度单位</li><li>能量单位</li><li>功率单位</li><li>力学单位</li></ul><h2 id="Scipy-cluster模块"><a href="#Scipy-cluster模块" class="headerlink" title="Scipy cluster模块"></a>Scipy cluster模块</h2><p>这个模块分为vq模块和hierarchy模块.</p><h3 id="vq模块"><a href="#vq模块" class="headerlink" title="vq模块"></a>vq模块</h3><p>此模块实现k-means算法和向量量化.</p><h4 id="K-means算法"><a href="#K-means算法" class="headerlink" title="K-means算法"></a>K-means算法</h4><ul><li>1.首先给定需要的类/簇个数n</li><li>2.随机定n个簇心</li><li>3.将每个点分在离它最近的簇心</li><li>4.对于每个簇心,计算属于它的点集的平均点,该点为新的簇心</li><li>5.在获得新的n个簇心之后,重复 3,4步骤,如果划分新的点集的时候,点集没有变则循环结束.</li></ul><p>这个算法最后返回的是质心坐标矩阵,通过<code>vq</code>方法再把每个点分给对应的质心,<code>vq</code>方法的返回值是每个观察的簇是失真.</p><h3 id="hierarchy模块"><a href="#hierarchy模块" class="headerlink" title="hierarchy模块"></a>hierarchy模块</h3><p>见<a href="%E5%A4%9A%E5%85%83%E5%88%86%E6%9E%90.md">博客多元分析一节</a></p><h2 id="Scipy-fftpack模块"><a href="#Scipy-fftpack模块" class="headerlink" title="Scipy fftpack模块"></a>Scipy fftpack模块</h2><p>fftpack模块提供了快速傅里叶变化的方法.</p><h3 id="一维离散傅里叶变换"><a href="#一维离散傅里叶变换" class="headerlink" title="一维离散傅里叶变换"></a>一维离散傅里叶变换</h3><p>长度为n的x序列,通过fft方法算出其在复数域上的映射a+bi.ifft方法是逆傅里叶变换.</p><h3 id="离散余弦变换"><a href="#离散余弦变换" class="headerlink" title="离散余弦变换"></a>离散余弦变换</h3><p>离散余弦变换是实偶函数的傅里叶变换,不含虚数单位项.可以认为是0i.也即没有初项,只有振幅和频率两个参数.<br>Scipy提供了dct和idct方法求得</p><h2 id="Scipy-integrade模块"><a href="#Scipy-integrade模块" class="headerlink" title="Scipy integrade模块"></a>Scipy integrade模块</h2><p>下表是integrate库中的常用功能</p><table><thead><tr><th align="left">编号</th><th align="left">功能说明</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">quad单积分</td></tr><tr><td align="left">2</td><td align="left">dblquad双重积分</td></tr><tr><td align="left">3</td><td align="left">tplquad三重积分</td></tr><tr><td align="left">4</td><td align="left">nquadn倍多重积分</td></tr><tr><td align="left">5</td><td align="left">fixed_quad高斯积分，阶数n</td></tr><tr><td align="left">6</td><td align="left">quadrature高斯正交到容差</td></tr><tr><td align="left">7</td><td align="left">romberg隆伯格积分</td></tr><tr><td align="left">8</td><td align="left">trapz梯形法则</td></tr><tr><td align="left">9</td><td align="left">cumtrapz梯形法则累计计算积分</td></tr><tr><td align="left">10</td><td align="left">simps辛普森的规则</td></tr><tr><td align="left">11</td><td align="left">romb隆伯格整合</td></tr><tr><td align="left">12</td><td align="left">polyint分析多项式积分（NumPy）</td></tr><tr><td align="left">13</td><td align="left">poly1d辅助函数polyint（NumPy）</td></tr></tbody></table><h3 id="quad-单积分"><a href="#quad-单积分" class="headerlink" title="quad 单积分"></a>quad 单积分</h3><p>$\int_a^bf\left(x\right)dx$ == quad(f,a,b)</p><p>quad返回两个值,第一个是积分结果,第二个是积分的绝对误差</p><p>实例:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> scipy<span class="token punctuation">.</span>integrate<span class="token keyword">from</span> numpy <span class="token keyword">import</span> expf<span class="token operator">=</span> <span class="token keyword">lambda</span> x<span class="token punctuation">:</span>exp<span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">)</span>i <span class="token operator">=</span> scipy<span class="token punctuation">.</span>integrate<span class="token punctuation">.</span>quad<span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">print</span> i<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="双重积分"><a href="#双重积分" class="headerlink" title="双重积分"></a>双重积分</h3><p>对于积分<br>$$\int_a^bdx\int_{g(x)}^{h(x)}dyf(x,y)$$<br>其等价于<code>dblquad（func，a，b，gfun，hfun)</code></p><p>其中func是<code>f(x,y)</code>这个复合函数 <code>a</code>,<code>b</code>是<code>x</code>的上下限,<code>gfunc</code>和<code>hfunc</code>是y的上下限.</p><p>输出和单积分相同,一个是积分结果,一个是绝对误差,</p><h2 id="interpolate-插值"><a href="#interpolate-插值" class="headerlink" title="interpolate 插值"></a>interpolate 插值</h2><h3 id="什么是插值"><a href="#什么是插值" class="headerlink" title="什么是插值"></a>什么是插值</h3><p>插值就是在离散数据的基础上补插连续函数,使得连续函数通过这些离散点.这是离散函数逼近的重要方法.</p><h3 id="Interp1d"><a href="#Interp1d" class="headerlink" title="Interp1d"></a>Interp1d</h3><p>scipy.interpolate中的interp1d类是一种基于固定数据点创建函数的便捷方法.</p><pre class="line-numbers language-none"><code class="language-none">interp1d(datax,datay,kind)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中的datax,datay分别为离散参数,kind是插值方式,比如线性(liner),最近(nearest),零,二次(cubic),立方等.</p><h3 id="多维数据插值-griddata"><a href="#多维数据插值-griddata" class="headerlink" title="多维数据插值-griddata"></a>多维数据插值-griddata</h3><pre class="line-numbers language-none"><code class="language-none">griddata(points,value,point_grid,method)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数解释:</p><ul><li>points 是每个点的坐标</li><li>value 是点相应的函数结果值</li><li>point_grid 是你要想获得结果的点的坐标</li><li>method 是插值方法</li></ul><p>这个方法返回的是点的函数结果</p><h3 id="单变量样条"><a href="#单变量样条" class="headerlink" title="单变量样条"></a>单变量样条</h3><p>UnivariateSpline是基于固定数据点类创建函数的便捷方法.</p><pre class="line-numbers language-none"><code class="language-none">scipy.interpolate.UnivariateSpline（x，y，w &#x3D; None，bbox &#x3D; [None，None]，k &#x3D; 3，s &#x3D;无，ext &#x3D; 0，check_finite &#x3D; False）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数解释:</p><ul><li>‘w’ - 指定样条拟合的权重。 必须是正数的。 如果没有（默认），权重都是相等的。</li><li>‘s’ - 通过指定平滑条件指定结的数量。</li><li>‘k’ - 平滑样条曲线的度数。 必须&lt;= 5.默认值为k = 3，三次样条曲线。</li><li>Ext - 控制不在结节序列定义的区间内的元素的外推模式。</li><li><ul><li>如果ext = 0或’extrapolate’，则返回外推值。</li></ul></li><li><ul><li>如果ext = 1或’0’，则返回0</li></ul></li><li><ul><li>如果ext = 2或’raise’，则引发ValueError</li></ul></li><li><ul><li>如果ext = 3’const’，则返回边界值。 </li></ul></li><li>check_finite - 是否检查输入数组是否仅包含有限数字。 </li></ul><h2 id="Scipy-I-O模块"><a href="#Scipy-I-O模块" class="headerlink" title="Scipy I/O模块"></a>Scipy I/O模块</h2><h3 id="MATLAB-files"><a href="#MATLAB-files" class="headerlink" title="MATLAB files"></a>MATLAB files</h3><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">loadmat(file_name[, mdict, appendmat])</td><td align="left">Load MATLAB file.</td></tr><tr><td align="left">savemat(file_name, mdict[, appendmat, …])</td><td align="left">Save a dictionary of names and arrays into a MATLAB-style .mat file.</td></tr><tr><td align="left">whosmat(file_name[, appendmat])</td><td align="left">List variables inside a MATLAB file.</td></tr></tbody></table><ul><li>loadmat<blockquote><p>squeeze_me参数为true时能将文件中1*1大小的矩阵滤除<br>struct_as_record 参数为False时能将struct类型变成类似python的对象,能直接通过属性访问数据,而不是字典.</p></blockquote></li><li>savemat 可以通过字典的形式存<pre class="line-numbers language-python" data-language="python"><code class="language-python">a_dict <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">'field1'</span><span class="token punctuation">:</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token string">'field2'</span><span class="token punctuation">:</span> <span class="token string">'a string'</span><span class="token punctuation">&#125;</span>sio<span class="token punctuation">.</span>savemat<span class="token punctuation">(</span><span class="token string">'saved_struct.mat'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token string">'a_dict'</span><span class="token punctuation">:</span> a_dict<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="ID-files"><a href="#ID-files" class="headerlink" title="ID files"></a>ID files</h3><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">readsav(file_name[, idict, python_dict, …])</td><td align="left">Read an IDL .sav file.</td></tr></tbody></table><h3 id="Matrix-Market-files"><a href="#Matrix-Market-files" class="headerlink" title="Matrix Market files"></a>Matrix Market files</h3><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">mminfo(source)</td><td align="left">Return size and storage parameters from Matrix Market file-like ‘source’.</td></tr><tr><td align="left">mmread(source)</td><td align="left">Reads the contents of a Matrix Market file-like ‘source’ into a matrix.</td></tr><tr><td align="left">mmwrite(target, a[, comment, field, …])</td><td align="left">Writes the sparse or dense array a to Matrix Market file-like target.</td></tr></tbody></table><h2 id="Scipy-linalg-模块"><a href="#Scipy-linalg-模块" class="headerlink" title="Scipy.linalg 模块"></a>Scipy.linalg 模块</h2><code>Scipy,linalg</code>包含所有的<code>numpy.linalg</code>函数,另外还有一些高级函数.<h3 id="linalg-solve"><a href="#linalg-solve" class="headerlink" title="linalg.solve"></a>linalg.solve</h3><code>solve(a,b)</code> a是系数矩阵,b是右手侧常数项.如<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#importing the scipy and numpy packages</span><span class="token keyword">from</span> scipy <span class="token keyword">import</span> linalg<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment">#Declaring the numpy arrays</span>a <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>b <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#Passing the values to the solve function</span>x <span class="token operator">=</span> linalg<span class="token punctuation">.</span>solve<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token comment">#printing the result array</span><span class="token keyword">print</span> x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>等于下列线性方程组<br>$$3x + 2y + 0z = 2$$<br>$$1x + -1y + 0z = 4$$<br>$$0x + 5y + 1z = -1$$<br>这个方法返回解数组<h3 id="行列式值"><a href="#行列式值" class="headerlink" title="行列式值"></a>行列式值</h3><code>Scipy.linalg.det</code>函数计算矩阵的标量值<h3 id="特征值和特征向量"><a href="#特征值和特征向量" class="headerlink" title="特征值和特征向量"></a>特征值和特征向量</h3>$$Av = \lambda v$$<br>A是矩阵,v是特征向量,$\lambda$是特征值.scipy.linalg.eig能返回函数特征值和特征向量.</li></ul><p><code>l,v = eig(array)</code> l是特征值,v是特征向量. </p><h3 id="奇异值分解"><a href="#奇异值分解" class="headerlink" title="奇异值分解"></a>奇异值分解</h3><h4 id="理论解释"><a href="#理论解释" class="headerlink" title="理论解释"></a>理论解释</h4><p>奇异值分解(SVD)可以认为是特征值问题对非平方矩阵的扩展.</p><p>对于方阵,如果求出了他的特征值和特征向量,那么方阵$A = W\Sigma W^T$</p><p>其中W为n个特征向量张成的矩阵,$\Sigma$是n个相应的特征值为主对角线的n*n维矩阵.</p><p>那么对于非平方矩阵,也有类似的特征分解表达式<br>$$A = U\Sigma V^T$$<br>A是一个m*n的矩阵,U是一个m*m的矩阵,$\Sigma$是一个m*n的矩阵,除了主对角线元素以外全为0,主对角线每个元素成为奇异值,V是一个n*n的矩阵.U和V都是酉矩阵,即满足$U^TU = I, V^TV = I$</p><p>那么$A^TA = V\Sigma^T U^TU\Sigma V^T =V\Sigma’ V^T = W\Sigma W^T$<br>所以由所有特征向量张成的矩阵就是矩阵<code>V</code>.</p><p>同样$AA^T = U\Sigma’’U^T$,那么其所有特征向量张成的矩阵就是矩阵<code>U</code></p><p>对于奇异值矩阵我们发现$AV = U\Sigma$那么$Av_i=\sigma_iu_i$所以$\sigma_i=Av_i/u_i$</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>scipy.linalg里面的svd方法能求出相应的U,S,V矩阵.<br><code>U,S,V = svd(array)</code></p><h2 id="Scipy-ndimage模块"><a href="#Scipy-ndimage模块" class="headerlink" title="Scipy.ndimage模块"></a>Scipy.ndimage模块</h2><p><code>ndimage</code>模块主要用于图像处理,常见功能如下:</p><ul><li>输入/输出，显示图像</li><li>基本操作 - 裁剪，翻转，旋转等</li><li>图像过滤 - 去噪，锐化等</li><li>图像分割 - 标记与不同对象相对应的像素</li><li>Classification</li><li>Feature extraction</li><li>Registration<h3 id="过滤器filter"><a href="#过滤器filter" class="headerlink" title="过滤器filter"></a>过滤器filter</h3>下面的函数都是对数组中的值进行过滤,输出元素是输入元素邻域元素的函数值.对于这个元素邻域我们成为过滤器内核,可以是矩形,也可以是任意图形,通过自己给的权重控制.对于过滤器内核,其内核中心一般是核形状的尺寸除以2,(长度为2的内核,中心就是1,既第一位元素.),但是也能通过设置参数移动内核中心.</li></ul><p>对于边界元素,需要边界外的值来辅助计算,所以需要选择边界条件.</p><table><thead><tr><th align="left">mode</th><th align="left">description</th><th align="left">example</th></tr></thead><tbody><tr><td align="left">nearest</td><td align="left">使用边界值</td><td align="left">[1,2]-&gt;[1,1,2,2]</td></tr><tr><td align="left">wrap</td><td align="left">复制阵列</td><td align="left">[1,2,3]-&gt;[3,1,2,3,1]</td></tr><tr><td align="left">reflect</td><td align="left">反射在边界的数组</td><td align="left">[1,2,3]-&gt;[1,1,2,3,3]</td></tr><tr><td align="left">mirror</td><td align="left">镜像边界处的数组</td><td align="left">[1,2,3]-&gt;[2,1,2,3,2]</td></tr><tr><td align="left">constant</td><td align="left">使用常数填充(默认是0)</td><td align="left">[1,2,3]-&gt;[0,1,2,3,0]</td></tr></tbody></table><p>同时还支持以下关键字</p><table><thead><tr><th align="left">mode</th><th align="left">description</th></tr></thead><tbody><tr><td align="left">grid-constant</td><td align="left">等价于constant</td></tr><tr><td align="left">grid-mirror</td><td align="left">等价于mirror</td></tr><tr><td align="left">grid-wrap</td><td align="left">等价于wrap</td></tr></tbody></table><ul><li>correlate是计算多维相关的函数,数组和给定内核相关<blockquote><p><code>scipy.ndimage.correlate(input, weights, output=None, mode=&#39;reflect&#39;, cval=0.0, origin=0)</code></p><p>参数解释</br></p><ul><li>input:输入的矩阵</li><li>weights:内核权重</li><li>output:要在其中放置输出的数组，或返回数组的 dtype。默认情况下，将创建与输入相同的 dtype 数组。</li><li>mode:对于边界元素的处理方式</li><li>cval:如果mode是constant,填充的常数,默认是0</li><li>origin: 内核中心偏移</li></ul></blockquote></li><li>correlate1d 是计算一维线性相关的函数<blockquote><p><code>scipy.ndimage.correlate1d(input, weights, axis=- 1, output=None, mode=&#39;reflect&#39;, cval=0.0, origin=0)[source]</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">></span><span class="token keyword">from</span> scipy<span class="token punctuation">.</span>ndimage <span class="token keyword">import</span> correlate1d<span class="token operator">></span>correlate1d<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> weights<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">></span>array<span class="token punctuation">(</span><span class="token punctuation">[</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">,</span>  <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span>  <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">,</span>  <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><h3 id="插值函数"><a href="#插值函数" class="headerlink" title="插值函数"></a>插值函数</h3>Scipy.ndimage的插值函数是基于B-spline理论.其更详细的解释可以查看<a href="https://docs.scipy.org/doc/scipy/reference/tutorial/ndimage.html#interpolation-functions">官方文档</a>,本人因数理基础和时间原因,暂不能继续学习,未来或许会更新.<h3 id="形态学"><a href="#形态学" class="headerlink" title="形态学"></a>形态学</h3><a href="https://docs.scipy.org/doc/scipy/reference/tutorial/ndimage.html#interpolation-functions">官方文档</a><h3 id="距离变换"><a href="#距离变换" class="headerlink" title="距离变换"></a>距离变换</h3><a href="https://docs.scipy.org/doc/scipy/reference/tutorial/ndimage.html#interpolation-functions">官方文档</a><h2 id="Scipy-odr正交距离回归"><a href="#Scipy-odr正交距离回归" class="headerlink" title="Scipy.odr正交距离回归"></a>Scipy.odr正交距离回归</h2>odr表示<code>Orthogonal Distance Regression</code>,用于回归研究.在标准线性回归中,通常是通过计算Y的物产,但是有时候考虑X,Y和真实值的垂直距离误差更为明智.<br>ODR方法需要传递data,线性回归模型.<pre class="line-numbers language-python" data-language="python"><code class="language-python">ODR<span class="token punctuation">(</span>data<span class="token punctuation">,</span>linear_model<span class="token punctuation">,</span>beta0<span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">## 参数解释</span>linear_model <span class="token operator">=</span> Model<span class="token punctuation">(</span>linear_func<span class="token punctuation">)</span>data <span class="token operator">=</span> RealData<span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>linear_func <span class="token operator">=</span> <span class="token keyword">lambda</span> x<span class="token punctuation">,</span>p<span class="token punctuation">:</span>px<span class="token operator">+</span>px <span class="token operator">=</span> array<span class="token punctuation">(</span><span class="token punctuation">)</span>y <span class="token operator">=</span> array<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="Scipy-Optimize"><a href="#Scipy-Optimize" class="headerlink" title="Scipy.Optimize"></a>Scipy.Optimize</h2><p><code>Optimize</code>提供了几种优化算法,包括:</p><ul><li>无约束和约束最小化 </li><li>全局（强力）优化程序</li><li>最小二乘最小化和曲线拟合</li><li>标量单变量函数最小化器</li><li>根查找</li><li>使用各种算法的多变量方程系统求解器<h3 id="无约束和约束最小化多元标量函数"><a href="#无约束和约束最小化多元标量函数" class="headerlink" title="无约束和约束最小化多元标量函数"></a>无约束和约束最小化多元标量函数</h3>minimize方法是多变量标量函数无约束或约束最小化算法的通用接口.不同算法需要不同的method. minimize至少需要提供三个参数,分别是函数,自变量数组,算法.</li></ul><p>下面是rosenbrock函数的示例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> scipy<span class="token punctuation">.</span>optimize <span class="token keyword">import</span> minimize<span class="token keyword">def</span> <span class="token function">rosen</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""The Rosenbrock function"""</span>    <span class="token keyword">return</span> <span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token number">100.0</span><span class="token operator">*</span><span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">-</span>x<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">**</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2.0</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">-</span>x<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2.0</span><span class="token punctuation">)</span>x0 <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1.3</span><span class="token punctuation">,</span> <span class="token number">0.7</span><span class="token punctuation">,</span> <span class="token number">0.8</span><span class="token punctuation">,</span> <span class="token number">1.9</span><span class="token punctuation">,</span> <span class="token number">1.2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>res <span class="token operator">=</span> minimize<span class="token punctuation">(</span>rosen<span class="token punctuation">,</span> x0<span class="token punctuation">,</span> method<span class="token operator">=</span><span class="token string">'nelder-mead'</span><span class="token punctuation">,</span>               options<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token string">'xatol'</span><span class="token punctuation">:</span> <span class="token number">1e-8</span><span class="token punctuation">,</span> <span class="token string">'disp'</span><span class="token punctuation">:</span> <span class="token boolean">True</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其他算法详解:<a href="https://docs.scipy.org/doc/scipy/reference/tutorial/optimize.html">https://docs.scipy.org/doc/scipy/reference/tutorial/optimize.html</a></p><h3 id="全局优化"><a href="#全局优化" class="headerlink" title="全局优化"></a>全局优化</h3><p>有多个方法,分别是shgo,differential_evolution,basinhopping等,这些算法只需要提供函数和boundry就行.</p><h3 id="最小二乘法优化"><a href="#最小二乘法优化" class="headerlink" title="最小二乘法优化"></a>最小二乘法优化</h3><p>SciPy能够求解鲁棒约束的边界约束非线性最小二乘问题.给定残差f(x),损失函数rho(s),least_squares能找到代价函数F(x)的局部最小值</p><h3 id="根查找"><a href="#根查找" class="headerlink" title="根查找"></a>根查找</h3><p>root方法能找到非线性方程的根.示例如下.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np <span class="token keyword">from</span> scipy<span class="token punctuation">.</span>optimize <span class="token keyword">import</span> root<span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> x <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> np<span class="token punctuation">.</span>cos<span class="token punctuation">(</span>x<span class="token punctuation">)</span>sol <span class="token operator">=</span> root<span class="token punctuation">(</span>func<span class="token punctuation">,</span> <span class="token number">0.3</span><span class="token triple-quoted-string string">"""猜测值"""</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>sol<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token operator">//</span>解<span class="token comment">###array([-1.02986653])</span><span class="token keyword">print</span><span class="token punctuation">(</span>sol<span class="token punctuation">.</span>fun<span class="token punctuation">)</span> <span class="token operator">//</span>误差<span class="token comment">###array([ -6.66133815e-16])</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Scipy-sparse稀疏矩阵"><a href="#Scipy-sparse稀疏矩阵" class="headerlink" title="Scipy.sparse稀疏矩阵"></a>Scipy.sparse稀疏矩阵</h2><p>稀疏矩阵有不同的表现形式,主要是</p><ul><li>CSC -压缩稀疏列,按列压缩</li><li>CSR -压缩稀疏行,按行压缩</li></ul><p>对于稀疏矩阵,有data方法查看其矩阵内部非零元素,count_nonzero()方法计算非零元素总数,对于稀疏矩阵运算和linalg模块类似,但是需要调用sparse的子模块,sparse.linalg模块内部函数,具体看<a href="https://docs.scipy.org/doc/scipy/reference/reference/sparse.html">文档</a>.</p><h2 id="scipy-spatial-空间数据结构算法"><a href="#scipy-spatial-空间数据结构算法" class="headerlink" title="scipy.spatial 空间数据结构算法"></a>scipy.spatial 空间数据结构算法</h2><h2 id="scipy-special-特殊数学函数"><a href="#scipy-special-特殊数学函数" class="headerlink" title="scipy.special 特殊数学函数"></a>scipy.special 特殊数学函数</h2><h3 id="立方根函数"><a href="#立方根函数" class="headerlink" title="立方根函数"></a>立方根函数</h3><p> scipy.special.cbrt（x）获取x逐元素立方根。</p><h3 id="指数函数"><a href="#指数函数" class="headerlink" title="指数函数"></a>指数函数</h3><p>scipy.special.exp10（x）计算$10^x$。 </p><p>scipy.special.exp2（x）计算$2^x$。 </p><p>scipy.special.exp（x）计算$e^x$。</p><h3 id="相对误差指数函数"><a href="#相对误差指数函数" class="headerlink" title="相对误差指数函数"></a>相对误差指数函数</h3><p>scipy.special.exprel（x）生成相对误差指数，（exp（x） - 1）/ x。<br>当x接近零时，exp（x）接近1，因此exp（x）-1的数值计算可能遭受灾难性的精度损失。 所以需要xprel（x）以避免精度损失。 </p><h3 id="对数和指数函数"><a href="#对数和指数函数" class="headerlink" title="对数和指数函数"></a>对数和指数函数</h3><p>logsumexp(x) == log(sum(exp(a)))</p><h3 id="朗伯W函数"><a href="#朗伯W函数" class="headerlink" title="朗伯W函数"></a>朗伯W函数</h3><p>lambertw(x)函数是$f(x) = x * e^x$的反函数,也就是说<br>$$lambertw(x) = w$$<br>$$x = w*e^w$$</p><h3 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h3><p>组合函数的语法是 - scipy.special.comb（N，k）等价于 $C_n^k$</p><p>排列函数的语法是 - scipy.special.perm（N，k）等价于 $A_n^k$</p><h3 id="伽马功能"><a href="#伽马功能" class="headerlink" title="伽马功能"></a>伽马功能</h3><p>对于自然数<code>n</code>，伽马函数通常被称为广义阶乘，也即z * gamma（z）= gamma（z + 1）和gamma（n + 1）= n !,</p><h2 id="scipy-stats-统计数学函数"><a href="#scipy-stats-统计数学函数" class="headerlink" title="scipy.stats 统计数学函数"></a>scipy.stats 统计数学函数</h2><p>见<a href="https://docs.scipy.org/doc/scipy/reference/reference/generated/scipy.stats.rv_continuous.html#scipy.stats.rv_continuous">文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数学建模 </tag>
            
            <tag> Scipy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy学习</title>
      <link href="/2022/01/19/Numpy%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/01/19/Numpy%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h1><p>address:<a href="https://www.numpy.org.cn/reference/">https://www.numpy.org.cn/reference/</a></p><h2 id="Ndarray对象"><a href="#Ndarray对象" class="headerlink" title="Ndarray对象"></a>Ndarray对象</h2><ul><li><code>Ndarray</code>等价于多维数组</li><li>构造方法:<pre class="line-numbers language-none"><code class="language-none">numpy.array(object, dtype &#x3D; None, copy &#x3D; True, order &#x3D; None, subok &#x3D; False, ndmin &#x3D; 0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><code>object</code>:数组或者嵌套的数列<br><code>dtype</code>:数组元素的数据类型,可选<br><code>copy</code>:数组是否需要复制,如果为false,则是对原数组的引用<br><code>order</code>:数组在内存中样式<br><code>subok</code>:默认返回一个与基类类型一致的数组<br><code>ndmin</code>:数组最小维度</p></blockquote><h2 id="数据类型对象dtype"><a href="#数据类型对象dtype" class="headerlink" title="数据类型对象dtype"></a>数据类型对象dtype</h2><code>dtype</code>实例是用来描述与数组对应的内存区域是如何使用的.</li><li>数据类型</li><li>数据大小</li><li>数据的字节顺序(大小端,&lt;表示小端,&gt;表示大端)</li><li>在结构化类型下,字段的名称,每个字段的数据类型和每个字段所取得内存块得部分</li><li>如果数据类型是子数组,描述其形状和数据类型</li></ul><p>构造:</br><br><code>numpy.dtype(object, align, copy)</code></p><p>类似于C的<code>struct</code>,要指明类型索引和类型输于的数据结构,如</p><pre class="line-numbers language-none"><code class="language-none">d &#x3D; dtype([(&#39;name&#39;,&#96;S20&#96;),((&#39;grade&#39;,&#39;int8&#39;))])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Numpy数组属性"><a href="#Numpy数组属性" class="headerlink" title="Numpy数组属性"></a>Numpy数组属性</h2><table><thead><tr><th align="left">属性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">ndarray.ndim</td><td align="left">秩，即轴的数量或维度的数量</td></tr><tr><td align="left">ndarray.shape</td><td align="left">数组的维度，对于矩阵，n 行 m 列</td></tr><tr><td align="left">ndarray.size</td><td align="left">数组元素的总个数，相当于 .shape 中 n*m 的值</td></tr><tr><td align="left">ndarray.dtype</td><td align="left">ndarray 对象的元素类型</td></tr><tr><td align="left">ndarray.itemsize</td><td align="left">ndarray 对象中每个元素的大小，以字节为单位</td></tr><tr><td align="left">ndarray.flags</td><td align="left">ndarray 对象的内存信息</td></tr><tr><td align="left">ndarray.real</td><td align="left">ndarray元素的实部</td></tr><tr><td align="left">ndarray.imag</td><td align="left">ndarray 元素的虚部</td></tr><tr><td align="left">ndarray.data</td><td align="left">包含实际数组元素的缓冲区，由于一般通过数组的索引获取元素，所以通常不需要使用这个属性。</td></tr></tbody></table><h2 id="Numpy创建数组"><a href="#Numpy创建数组" class="headerlink" title="Numpy创建数组"></a>Numpy创建数组</h2><ul><li><p>numpy.empty创建一个指定形状,指定数据类型的未初始化数组 <code>= np.empty([3,2], dtype = int)</code></p></li><li><p>numpy.zero创建一个指定大小,0填充的数组,默认为浮点数<code>numpy.zeros(shape, dtype = float, order = &#39;C&#39;)</code></p></li><li><p>numpy.one创建一个指定形状,1填充的数组,默认为浮点数<code>x = np.ones([2,2], dtype = int)</code></p></li><li><p>numpy.asarray类似array</p><blockquote><p><code>numpy.asarray(a, dtype = None, order = None)</code></p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">a</td><td align="left">任意形式的输入参数，可以是，列表, 列表的元组, 元组, 元组的元组, 元组的列表，多维数组</td></tr><tr><td align="left">dtype</td><td align="left">数据类型，可选</td></tr><tr><td align="left">order</td><td align="left">可选，有”C”和”F”两个选项,分别代表，行优先和列优先，在计算机内存中的存储元素的顺序。</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">&gt;x &#x3D;  [1,2,3] &gt;a &#x3D; np.asarray(x)  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote></li><li><p>numpy.frombuffer用于实现动态数组,接受buffer输入参数,以流的形式读入转化成ndarray对象.</p><blockquote><p><code>numpy.frombuffer(buffer, dtype = float, count = -1, offset = 0)</code></p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">buffer</td><td align="left">可以是任意对象，会以流的形式读入。</td></tr><tr><td align="left">dtype</td><td align="left">返回数组的数据类型，可选</td></tr><tr><td align="left">count</td><td align="left">读取的数据数量，默认为-1，读取所有数据。</td></tr><tr><td align="left">offset</td><td align="left">读取的起始位置，默认为0。</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">&gt;s &#x3D;  b&#39;Hello World&#39; &gt;a &#x3D; np.frombuffer(s, dtype &#x3D;  &#39;S1&#39;)  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote></li><li><p>numpy.fromiter 从可迭代对象中建立ndarray对象.</p><blockquote><p><code>numpy.fromiter(iterable, dtype, count=-1)</code></p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">iterable</td><td align="left">可迭代对象</td></tr><tr><td align="left">dtype</td><td align="left">返回数组的数据类型</td></tr><tr><td align="left">count</td><td align="left">读取的数据数量，默认为-1，读取所有数据</td></tr></tbody></table></blockquote></li><li><p>numpy.arange创建数值范围并返回ndarray对象</br><br><code>numpy.arange(start, stop, step, dtype)</code></p></li><li><p>numpy.linspace创建一个等差数列组成的一维数组</br><br><code>np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)</code></p></li><li><p>numpy.logspace创建一个等比数列</br><br><code>np.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)</code></p><h2 id="Numpy切片"><a href="#Numpy切片" class="headerlink" title="Numpy切片"></a>Numpy切片</h2></li><li><p>可以通过创建slice类来对数组进行切片</p><pre class="line-numbers language-none"><code class="language-none">s &#x3D; slice(0,16,2)print(a[s])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>可以通过:和…切片</p><h2 id="Numpy索引"><a href="#Numpy索引" class="headerlink" title="Numpy索引"></a>Numpy索引</h2></li><li><p>整数数组索引</p><blockquote><p>设索引地址为x,y. x = {x1,x2,…xn}, y = {y1,y2,…yn},a[x,y] = [a[x1,y1],…,a[xn,yn]]</p><pre class="line-numbers language-none"><code class="language-none">&gt;import numpy as np &gt;x &#x3D; np.array([[  0,  1,  2],[  3,  4,  5],[  6,  7,  8],[  9,  10,  &gt;11]])  &gt;rows &#x3D; np.array([[0,0],[3,3]]) &gt;cols &#x3D; np.array([[0,2],[0,2]]) &gt;y &#x3D; x[rows,cols]  &gt;print (y) ##[y[0,0],y[0,2],y[3,0],y[3,2]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote></li><li><p>布尔索引</p><blockquote><p>x = bool运算 , a[x] = {ai | ai 属于 a 且 ai满足x}</p></blockquote></li><li><p>花式索引</p><blockquote><p>设索引地址为x, a[x] = {ai | ai的行坐标为xi}<br>设索引地址为x,y, a[x,y] = {ai | aij的行坐标为xi,aij的列坐标属于y}</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np  x<span class="token operator">=</span>np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span> <span class="token punctuation">(</span>x<span class="token punctuation">[</span>np<span class="token punctuation">.</span>ix_<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">"""[[ 4  7  5  6] [20 23 21 22] [28 31 29 30] [ 8 11  9 10]] """</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Numpy-的广播-broadcase"><a href="#Numpy-的广播-broadcase" class="headerlink" title="Numpy 的广播(broadcase)"></a>Numpy 的广播(broadcase)</h2><p>如果数组运算,这俩矩阵的shape不同,则触发broadcase.</p></li></ul><p>broadcase规则</p><ul><li>让所有输入数组都向其中形状最长的数组看齐，形状中不足的部分都通过在前面加 1 补齐。</li><li>输出数组的形状是输入数组形状的各个维度上的最大值。</li><li>如果输入数组的某个维度和输出数组的对应维度的长度相同或者其长度为 1 时，这个数组能够用来计算，否则出错。</li><li>当输入数组的某个维度的长度为 1 时，沿着此维度运算时都用此维度上的第一组值。<h2 id="Numpy的迭代"><a href="#Numpy的迭代" class="headerlink" title="Numpy的迭代"></a>Numpy的迭代</h2>numpy.nditer可以将数组转化为迭代,默认是根据数组内存布局.<pre class="line-numbers language-none"><code class="language-none">nditer(array,order &#x3D; &quot;C&quot;,op_flags &#x3D; [&#39;read_only&#39;],flags)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>其中flags可以取:<table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">c_index</td><td align="left">可以跟踪 C 顺序的索引</td></tr><tr><td align="left">f_index</td><td align="left">可以跟踪 Fortran 顺序的索引</td></tr><tr><td align="left">multi_index</td><td align="left">每次迭代可以跟踪一种索引类型</td></tr><tr><td align="left">external_loop</td><td align="left">给出的值是具有多个值的一维数组，而不是零维数组</td></tr></tbody></table></li></ul><p>如果迭代一个可广播的数组,则迭代放回的是两个值,这两个值是广播之后两个数组的值</p><h2 id="Numpy数组操作"><a href="#Numpy数组操作" class="headerlink" title="Numpy数组操作"></a>Numpy数组操作</h2><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">reshape</td><td align="left">不改变数据的条件下修改形状</td></tr><tr><td align="left">flat</td><td align="left">数组元素迭代器</td></tr><tr><td align="left">flatten</td><td align="left">返回一份数组拷贝，对拷贝所做的修改不会影响原始数组</td></tr><tr><td align="left">ravel</td><td align="left">返回展开数组</td></tr><tr><td align="left">transpose</td><td align="left">对换数组的维度,转置</td></tr><tr><td align="left">broadcase</td><td align="left">返回一个数组对另一个数组广播的结果</td></tr><tr><td align="left">split</td><td align="left">分割数组</td></tr></tbody></table><h2 id="Numpy位运算"><a href="#Numpy位运算" class="headerlink" title="Numpy位运算"></a>Numpy位运算</h2><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">bitwise_and</td><td align="left">对数组元素执行位与操作</td></tr><tr><td align="left">bitwise_or</td><td align="left">对数组元素执行位或操作</td></tr><tr><td align="left">invert</td><td align="left">按位取反</td></tr><tr><td align="left">left_shift</td><td align="left">向左移动二进制表示的位</td></tr><tr><td align="left">right_shift</td><td align="left">向右移动二进制表示的位</td></tr></tbody></table><h2 id="Numpy数学函数"><a href="#Numpy数学函数" class="headerlink" title="Numpy数学函数"></a>Numpy数学函数</h2><p>numpy内置了pi,numpy.pi就是pi</p><ul><li>三角函数<blockquote><p>sin,cos,tan只支持弧度制<br>arcsin,arccos,arctan返回弧度制,可通过degrees转化为角度值</p></blockquote><h2 id="Numpy算术函数"><a href="#Numpy算术函数" class="headerlink" title="Numpy算术函数"></a>Numpy算术函数</h2>add,subtract,multiply,divide,对数组相应数据进行计算<h2 id="Numpy统计函数"><a href="#Numpy统计函数" class="headerlink" title="Numpy统计函数"></a>Numpy统计函数</h2></li><li>amin函数 <code>amin(array,axis)</code>没有设置axis,默认当成一维数组</li><li>amax函数 <code>amax(array,axis)</code>没有设置axis,默认是一维数组</li><li>ptp函数 <code>ptp(array,axis)</code>没有设置axis,默认为一维数组</li><li>percentile函数<code>percentile(array, q, axis)</code>,p是有 <code>p%</code> 的数据项小于或等于这个值</li><li>media函数<code>media(array,axis)</code>计算中位数</li><li>mean函数<code>mean(array,axis)</code>计算算数平均数</li><li>average函数<code>mean(array,weights,returened,axis)</code> weights需要一个权重数组,returened是返回权重和</li><li>std标准差函数,var方差函数<h2 id="Numpy-排序条件筛选函数"><a href="#Numpy-排序条件筛选函数" class="headerlink" title="Numpy 排序条件筛选函数"></a>Numpy 排序条件筛选函数</h2></li><li>sort<code>sort(a, axis, kind, order)</code> kind为排序算法种,order就是排序字段</li><li>agsort返回数组从小到大的索引值</li><li>lexsort 对多个序列进行排序,排序时优先照顾靠后的序列</li><li>msort(a)    数组按第一个轴排序，返回排序后的数组副本。np.msort(a) 相等于 np.sort(a, axis=0)。</li><li>sort_complex(a)     对复数按照先实部后虚部的顺序进行排序。</li><li>partition(a, kth[, axis, kind, order])     指定一个数，对数组进行分区</li><li>argpartition(a, kth[, axis, kind, order])     可以通过关键字 kind 指定算法沿着指定轴对数组进行分区</li><li>numpy.argmax() 和 numpy.argmin()函数分别沿给定轴返回最大和最小元素的索引。</li><li>numpy.nonzero() 函数返回输入数组中非零元素的索引。</li><li>numpy.where() 函数返回输入数组中满足给定条件的元素的索引。</li><li>numpy.extract() 函数根据某个条件从数组中抽取元素，返回满足条件的元素。<h2 id="Numpy的副本和视图"><a href="#Numpy的副本和视图" class="headerlink" title="Numpy的副本和视图"></a>Numpy的副本和视图</h2>简单来说,副本和原来的数组面对的内存不一样,视图时对原来数组的引用.</li></ul><p>视图:</p><ul><li>切片</li><li>view方法</li></ul><p>副本:</p><ul><li>deepCopy</li><li>ndarray的copy方法<h2 id="Numpy矩阵库"><a href="#Numpy矩阵库" class="headerlink" title="Numpy矩阵库"></a>Numpy矩阵库</h2></li><li>matlib.empty <code>numpy.matlib.empty(shape, dtype, order)</code> 创建一个随机填充的矩阵</li><li>matlib.zeros创建一个以 0 填充的矩阵。</li><li>matlib.ones 创建一个以1填充的矩阵</li><li>matlib.eye 创建一个对角元素为1的矩阵<code>numpy.matlib.eye(n, M,k, dtype)</code>其中n为行数,M为列数,K为对角线的索引</li><li>numpy.matlib.identity() 函数返回给定大小的单位矩阵</li><li>numpy.matlib.rand() 函数创建一个给定大小的矩阵，数据是随机填充的。<h2 id="Numpy线性代数"><a href="#Numpy线性代数" class="headerlink" title="Numpy线性代数"></a>Numpy线性代数</h2><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">dot</td><td align="left">一维就是数组对应相乘,高维数组就是两个矩阵相乘。</td></tr><tr><td align="left">vdot</td><td align="left">两个向量的点积</td></tr><tr><td align="left">inner</td><td align="left">两个数组的内积</td></tr><tr><td align="left">matmul</td><td align="left">两个数组的矩阵积</td></tr><tr><td align="left">determinant</td><td align="left">数组的行列式</td></tr><tr><td align="left">solve</td><td align="left">求解线性矩阵方程</td></tr><tr><td align="left">inv</td><td align="left">计算矩阵的乘法逆矩阵</td></tr></tbody></table><h2 id="Numpy-I-O"><a href="#Numpy-I-O" class="headerlink" title="Numpy I/O"></a>Numpy I/O</h2></li><li>numpy.save 把一个数组存成npy形式 load取出<blockquote><p><code>numpy.save(file, arr, allow_pickle=True, fix_imports=True)</code></p></blockquote></li><li>numpy.savez 把多个数组存成npy形式 load取出<blockquote><p><code>numpy.savez(file, *args, **kwds)</code></p></blockquote></li><li>numpy.savetxt 把数组存储txt形式 loadtxt取出<blockquote><p><code>savetxt(FILENAME, a, fmt=&quot;%d&quot;, delimiter=&quot;,&quot;)</code></p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数学建模 </tag>
            
            <tag> Numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>httpx的使用</title>
      <link href="/2022/01/18/httpx%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/01/18/httpx%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTPX的使用"><a href="#HTTPX的使用" class="headerlink" title="HTTPX的使用"></a>HTTPX的使用</h1><p>有些网站使用的是http/2.0的协议,这种情况下,urllilb和requests模块是不能爬取数据的,这个时候就要使用httpx.<br><a href="https://www.python-httpx.org/quickstart/">官方文档</a></p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>httpx和requests很像,但是httpx有一个<code>Client</code>类,可以自定义协议,所以建议先实例化一个<code>Client</code>对象用于后续爬取.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> httpxclient <span class="token operator">=</span> httpx<span class="token punctuation">.</span>Client<span class="token punctuation">(</span>http2 <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token comment">## 手动打开http2的使能,不然是默认http/1.1</span>response <span class="token operator">=</span> client<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>headers <span class="token operator">=</span> headers<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Client对象"><a href="#Client对象" class="headerlink" title="Client对象"></a>Client对象</h2><p><code>Client</code>和<code>Session</code>对象类似,可以理解为维护爬虫的进程,可以随时结束进程,类似打开文件</p><p>示例代码:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">with</span> https<span class="token punctuation">.</span>Client<span class="token punctuation">(</span>http2 <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token keyword">as</span> client<span class="token punctuation">:</span>    response <span class="token operator">=</span> client<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>headers <span class="token operator">=</span> headers<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h2><p><code>httpx</code>还支持异步请求(即AsyncClient),支持Python的async请求模式,写法:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> httpx<span class="token keyword">import</span> asyncio<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">async</span> <span class="token keyword">with</span> httpx<span class="token punctuation">.</span>AsyncClient<span class="token punctuation">(</span>http2 <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token keyword">as</span> client<span class="token punctuation">:</span>        response <span class="token operator">=</span> client<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>text<span class="token punctuation">)</span>url <span class="token operator">=</span> <span class="token string">''</span>asyncio<span class="token punctuation">.</span>get_event_loop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>run_until_complete<span class="token punctuation">(</span>fetch<span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 爬虫学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> spider </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>logism自动化填充</title>
      <link href="/2022/01/17/logism%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
      <url>/2022/01/17/logism%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>P0的grf题需要32个寄存器,面对这种需要Ctrl-c/v的工作实在是浪费时间.对此,我们需要重拳出击,正好,logism的教程文件提到了怎么自动化复制,这不来尝试一下???</p><h3 id="寻找目标元件"><a href="#寻找目标元件" class="headerlink" title="寻找目标元件"></a>寻找目标元件</h3><p>用vsc打开circ文件,看到一堆标签,如何从标签里面找到需要的文件?我提出我的一些小办法:</br></p><ol><li>使用circuitname快速寻找:使用vsc自带的搜索功能,输入你要找的元件所属的circuit的名字,快速锁定大概范围.</li><li>根据元器件名字寻找:比如grf需要寄存器,那么,寻找名字为register 的器件,对于tunnel元件,可以根据朝向来判断需要<br>找到之后,把这些标签放在一起,好统一复制<br><img src="https://img-blog.csdnimg.cn/ef16719f8a9342609f5fa83238c3f246.png" alt="logism所需的元件"><br><img src="https://img-blog.csdnimg.cn/76f7ee75ad3b4bb8991c8878a85ca357.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Luj56CB5qyh5qyh5pegYnVn77yM546v5aKD5qyh5qyh5peg5Yay56qB,size_5,color_FFFFFF,t_70,g_se,x_16" alt="对应代码"><h3 id="写代码"><a href="#写代码" class="headerlink" title="写代码"></a>写代码</h3><del>python是最好的语言</del></br><br>一通操作猛如虎,打出代码,然后尝试一下 <del>(在写代码之前建议备份一下之前的circ文件,别问我怎么知道的,在1000+行的circ里面debug太痛苦了,不如直接/remake)</del></li></ol><p><img src="https://img-blog.csdnimg.cn/d1920bf2f4334199bb322184759e9014.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Luj56CB5qyh5qyh5pegYnVn77yM546v5aKD5qyh5qyh5peg5Yay56qB,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"><br><img src="https://img-blog.csdnimg.cn/7c4357f359e14dd2b690e84cc4473376.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Luj56CB5qyh5qyh5pegYnVn77yM546v5aKD5qyh5qyh5peg5Yay56qB,size_12,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"><br>好像emmmm,应该是双重循环.<br>修改一下,下面附上最终代码</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os<span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"F:\\LOGISIM_FILES\\P0_L0_GRF.circ"</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    template <span class="token operator">=</span> <span class="token triple-quoted-string string">r"""        &lt;comp lib="0" loc="(%d,%d)" name="Tunnel">      &lt;a name="width" val="8"/>      &lt;a name="label" val="r%d_out"/>    &lt;/comp>    &lt;comp lib="4" loc="(%d,%d)" name="Register"/>    &lt;comp lib="0" loc="(%d,%d)" name="Tunnel">      &lt;a name="facing" val="north"/>      &lt;a name="label" val="clk"/>    &lt;/comp>        &lt;comp lib="0" loc="(%d,%d)" name="Tunnel">      &lt;a name="facing" val="east"/>      &lt;a name="width" val="8"/>      &lt;a name="label" val="r%d_in"/>    &lt;/comp>    &lt;comp lib="0" loc="(%d,%d)" name="Tunnel">      &lt;a name="facing" val="north"/>      &lt;a name="label" val="clr"/>    &lt;/comp>        &lt;wire from="(%d,%d)" to="(%d,%d)"/>    &lt;wire from="(%d,%d)" to="(%d,%d)"/>    &lt;wire from="(%d,%d)" to="(%d,%d)"/>    &lt;wire from="(%d,%d)" to="(%d,%d)"/>    &lt;wire from="(%d,%d)" to="(%d,%d)"/>         &lt;wire from="(%d,%d)" to="(%d,%d)"/>    &lt;wire from="(%d,%d)" to="(%d,%d)"/>    &lt;wire from="(%d,%d)" to="(%d,%d)"/>"""</span>    <span class="token comment"># startx_clr+i*stepx starty_clr+j*stepy-10    startx_clr+i*stepx starty_clr+j*stepy</span>    <span class="token comment"># startx_clr+i*stepx-10, starty_clr+j*stepy-10, startx_clr+i*stepx,starty_clr+j*stepy-10</span>    <span class="token comment"># startx_clr+i*stepx-10,starty_clr+j*stepy-20,startx_clr+i*stepx-10,sstarty_clr+j*stepy-10</span>    <span class="token comment"># startx_ri+i*stepx,starty_ri+j*stepy,startx_ri+i*stepx+20,starty_ri+j*stepy</span>    <span class="token comment"># startx_ro+i*stepx,starty_ro+j*stepy,startx_ro+i*stepx,starty_ro+j*stepy</span>    <span class="token comment">#startx_clk+i*stepx+10 starty_clk+j*stepy-20   startx_clk+i*stepx+10 starty_clk+j*stepy-10</span>    <span class="token comment">#startx_clk+i*stepx starty_clk+j*stepy-10   startx_clk+i*stepx+10 starty_clk+j*stepy-10</span>    <span class="token comment">#startx_clk+i*stepx starty_clk+j*stepy-10   startx_clk+i*stepx starty_clk+j*stepy</span>    startx_ro <span class="token operator">=</span> <span class="token number">450</span>    starty_ro <span class="token operator">=</span> <span class="token number">200</span>    type_ro <span class="token operator">=</span> <span class="token number">0</span>     startx_re <span class="token operator">=</span> <span class="token number">410</span>    starty_re <span class="token operator">=</span> <span class="token number">200</span>    startx_clk <span class="token operator">=</span> <span class="token number">380</span>    starty_clk <span class="token operator">=</span> <span class="token number">240</span>    startx_ri <span class="token operator">=</span> <span class="token number">360</span>    starty_ri <span class="token operator">=</span> <span class="token number">200</span>    type_ri <span class="token operator">=</span> <span class="token number">0</span>    startx_clr <span class="token operator">=</span> <span class="token number">410</span>    starty_clr <span class="token operator">=</span> <span class="token number">240</span>    stepx <span class="token operator">=</span> <span class="token number">300</span>    stepy <span class="token operator">=</span> <span class="token number">300</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>   template <span class="token operator">%</span> <span class="token punctuation">(</span>              startx_ro<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token punctuation">,</span> starty_ro<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token punctuation">,</span> type_ro<span class="token operator">+</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token operator">*</span>i<span class="token operator">+</span>j<span class="token punctuation">)</span><span class="token punctuation">,</span>              startx_re<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token punctuation">,</span> starty_re<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token punctuation">,</span>              startx_clk<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token punctuation">,</span> starty_clk<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token punctuation">,</span>              startx_ri<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token punctuation">,</span> starty_ri<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token punctuation">,</span> type_ri<span class="token operator">+</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token operator">*</span>i<span class="token operator">+</span>j<span class="token punctuation">)</span><span class="token punctuation">,</span>              startx_clr<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token punctuation">,</span> starty_clr<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token punctuation">,</span>               startx_clr<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token punctuation">,</span> starty_clr<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span> startx_clr<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token punctuation">,</span>starty_clr<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token punctuation">,</span>              startx_clr<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span> starty_clr<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span> startx_clr<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token punctuation">,</span>starty_clr<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span>               startx_clr<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span>starty_clr<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token operator">-</span><span class="token number">20</span><span class="token punctuation">,</span>startx_clr<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span>starty_clr<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span>               startx_ri<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token punctuation">,</span>starty_ri<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token punctuation">,</span>startx_ri<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token operator">+</span><span class="token number">20</span><span class="token punctuation">,</span>starty_ri<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token punctuation">,</span>              startx_ro<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token punctuation">,</span>starty_ro<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token punctuation">,</span>startx_ro<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token operator">-</span><span class="token number">40</span><span class="token punctuation">,</span>starty_ro<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token punctuation">,</span>              startx_clk<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">,</span>starty_clk<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token operator">-</span><span class="token number">20</span><span class="token punctuation">,</span>startx_clk<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">,</span>starty_clk<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span>              startx_clk<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token punctuation">,</span>starty_clk<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span>startx_clk<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">,</span>starty_clk<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span>              startx_clk<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token punctuation">,</span>starty_clk<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span>startx_clk<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token punctuation">,</span>starty_clk<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token punctuation">)</span>  <span class="token punctuation">)</span>    f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token triple-quoted-string string">"""     &lt;/circuit>&lt;/project>"""</span><span class="token punctuation">)</span>      <span class="token comment">#logism通过这两个标签来判断circuit是否结束,所以在找到circ所需的元件之后,将这个标签删去,这样在f.write结束后自动填上/circuit,免得自己去翻   </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果:<br><img src="https://img-blog.csdnimg.cn/4f625359661141e286f54c83f247d08e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Luj56CB5qyh5qyh5pegYnVn77yM546v5aKD5qyh5qyh5peg5Yay56qB,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"></p><p>我宣布python是世界上最好的编程语言!</p>]]></content>
      
      
      <categories>
          
          <category> logism </category>
          
      </categories>
      
      
        <tags>
            
            <tag> logisim </tag>
            
            <tag> P0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/01/16/hello-world/"/>
      <url>/2022/01/16/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>就像万事有一个开头,对于程序员来说,<code>hello world</code>就是开始的仪式.这是<code>Hexo</code>建立的时候自带的文章,本应该删去,但还是留着当一个纪念.这个post的封面是动漫<code>Hello World</code>的海报,这俩还挺配的,就一起用了.也没啥特别意义,也算是矫情吧.那么,我的博客之旅要开始了.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式学习</title>
      <link href="/2022/01/16/regular_expression/"/>
      <url>/2022/01/16/regular_expression/</url>
      
        <content type="html"><![CDATA[<h2 id="关于正则表达式的学习笔记和总结"><a href="#关于正则表达式的学习笔记和总结" class="headerlink" title="关于正则表达式的学习笔记和总结"></a>关于正则表达式的学习笔记和总结</h2><h3 id="浅谈正则表达式"><a href="#浅谈正则表达式" class="headerlink" title="浅谈正则表达式"></a>浅谈正则表达式</h3><pre class="line-numbers language-none"><code class="language-none">我有一个问题可以用正则表达式解决，好了现在我有两个问题了<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="为什么是正则表达式"><a href="#为什么是正则表达式" class="headerlink" title="为什么是正则表达式"></a>为什么是正则表达式</h5><p>在我个人的学习经历中接触过各种字符串查找函数，但为什么正则表达式这么神奇？我觉得是它的模糊性，它的模糊性决定了查找时无关元素的影响更小，更能找到需要的内容</br><br>用一段python代码举例</br></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">str</span> <span class="token operator">=</span> <span class="token string">"abcdef"</span>res <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">.</span>find<span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这个代码能帮助你找到字符串中a这个字符，但如果换个问题，在一堆电话号码中找某一个开头的电话，或者末尾是某一片段的电话号码，那么，find函数就没这么好用了。</br>这时候，正则表达式的模糊性就能很好的得到需要的结果。</p><h5 id="正则表达式的应用范围"><a href="#正则表达式的应用范围" class="headerlink" title="正则表达式的应用范围"></a>正则表达式的应用范围</h5><p>正则表达式在java和python等语言中都有相应的包调用.在爬虫的使用中,正则表达式能很好的从一堆标签中找到你需要的某一段消息(虽然有时候在结构规整,目标不复杂的情况下,bs4有更好的效果).</p><h3 id="正则表达式规则"><a href="#正则表达式规则" class="headerlink" title="正则表达式规则"></a>正则表达式规则</h3><h4 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h4><ol><li><code>.</code> :匹配除换行符之外的任意字符</li><li><code>\w</code> :匹配字母或数字或下划线或汉字</li><li><code>\W</code> :匹配不是字母或数字或下划线或汉字的字符</li><li><code>\s</code> :匹配任意空白符</li><li><code>\S</code> :匹配任意非空白符</li><li><code>\d</code> :匹配数字</li><li><code>\D</code> :匹配非数字</li><li><code>\b</code> :匹配单词的开始或结束 如<code>&quot;er\b&quot;</code> 可以匹配never 不能匹配 very</li><li><code>\A</code> :匹配字符串开头</li><li><code>\z</code>:匹配字符串结尾,如果有换行符,则同时匹配换行符.</li><li><code>\Z</code>:匹配字符串结尾,不匹配换行符.</li><li><code>^</code> :匹配输入字符串的开始</li><li><code>$</code> :匹配输入字符串的结束<h4 id="重复限定符"><a href="#重复限定符" class="headerlink" title="重复限定符"></a>重复限定符</h4></li><li><code>*</code> 重复零次或者多次</li><li><code>+</code> 重复一次或多次</li><li><code>?</code>重复零次或一次</li><li><code>&#123;n&#125;</code> 重复n次</li><li><code>&#123;n,&#125;</code> 重复n次或者多次</li><li><code>&#123;n,m&#125;</code> 重复n次或者m次<h4 id="分组符"><a href="#分组符" class="headerlink" title="分组符"></a>分组符</h4></li><li><code>(ab)</code> 表明以字符串<code>&quot;ab&quot;</code>为一组的元素,例如: <code>&quot;^(ab)+&quot;</code>匹配以零个或者多个<code>&quot;ab&quot;</code>开头的字符串</li><li><code>[abc]</code>或者<code>[a-c]</code> 表明匹配abc中任意一个的字符  <h4 id="转义符"><a href="#转义符" class="headerlink" title="转义符"></a>转义符</h4></li><li><code>\</code> 表明将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。如:<code>&quot;(\n)&quot;</code>表示匹配\n <code>&quot;(\(ab\))+&quot;</code>表示匹配一个或者多个<code>&quot;(ab)&quot;</code>的字符<h4 id="条件符"><a href="#条件符" class="headerlink" title="条件符"></a>条件符</h4></li><li><code>|</code> 条件或,满足前者或者后者的字符,例如<code>&quot;(12)(3|4)&quot;</code>匹配<code>&quot;123&quot;</code>或者<code>&quot;124&quot;</code>的字符<h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4></li><li>正向先行断言<code>表达式1(?=pattern)</code>匹配pattern前面的表达式,不包含本身,例如下面的代码</br><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> reline <span class="token operator">=</span> <span class="token string">"&lt;div class = \"left_box\" height = 100px>"</span>pattern <span class="token operator">=</span> <span class="token string">".*(?=height)"</span>m <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>pattern<span class="token punctuation">,</span>line<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token operator">&lt;</span>div <span class="token keyword">class</span> <span class="token operator">=</span> <span class="token string">"left_box"</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>负向先行断言<code>表达式1(?!pattern)</code>匹配后面不含pattern的表达式,不包含本身,例如下面的代码</br><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> reline <span class="token operator">=</span> <span class="token string">"regular regex rlief"</span>pattern <span class="token operator">=</span> <span class="token string">r"r(\w&#123;1&#125;)(?!g)"</span>m <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>pattern<span class="token punctuation">,</span>line<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> rl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>正向后行断言<code>(?&lt;=pattern)表达式1</code>,同正向先行断言,只是匹配的是pattern后面的表达式</li><li>负向向后行断言<code>(?&lt;!pattern)表达式1</code>,同负向向先行断言,只是匹配的是pattern后面的表达式</li></ol><h4 id="懒惰-非贪婪"><a href="#懒惰-非贪婪" class="headerlink" title="懒惰(非贪婪)"></a>懒惰(非贪婪)</h4><h6 id="什么是正则表达式的贪婪"><a href="#什么是正则表达式的贪婪" class="headerlink" title="什么是正则表达式的贪婪?"></a>什么是正则表达式的贪婪?</h6><p>贪婪是指在匹配时尽可能多的匹配,如<code>\w&#123;2,9&#125;</code>则会尽量匹配9个,如果不够就匹配八个.</p><h6 id="如何做到懒惰"><a href="#如何做到懒惰" class="headerlink" title="如何做到懒惰"></a>如何做到懒惰</h6><ol><li><code>*?</code>重复0次或者无数次,从0开始匹配</li><li><code>+?</code>重复一到正无穷次,从1开始</li><li><code>??</code>重复0到1次,从0开始</li><li><code>&#123;n,m&#125;?</code> 重复n到m次,从n开始<h4 id="编号分组"><a href="#编号分组" class="headerlink" title="编号分组"></a>编号分组</h4></li><li>数字编号分组<code>&#123;表达式&#125;</code>,例如:<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> reline <span class="token operator">=</span> <span class="token string">"020-85653333"</span>pattern <span class="token operator">=</span> <span class="token string">r"(0\d&#123;2,3&#125;)-(\d&#123;8&#125;)"</span>m <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>pattern<span class="token punctuation">,</span>line<span class="token punctuation">)</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span><span class="token number">020</span><span class="token operator">-</span><span class="token number">85653333</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span><span class="token number">020</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span><span class="token number">85653333</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>命名编号捕获组<code>(?&lt;name&gt;表达式)</code>,非捕获组<code>()?:表达式</code>,不捕获(在不同语言中实现方式不同,如在python中需要添加P在?与<name>之间)<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> reline <span class="token operator">=</span> <span class="token string">"020-85653333"</span>pattern <span class="token operator">=</span> <span class="token string">r"(?P&lt;区号>0\d&#123;2,3&#125;)-(?P&lt;号码>\d&#123;8&#125;)"</span>m <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>pattern<span class="token punctuation">,</span>line<span class="token punctuation">)</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span><span class="token number">020</span><span class="token operator">-</span><span class="token number">85653333</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token string">"号码"</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span><span class="token number">020</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token string">"区号"</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span><span class="token number">85653333</span><span class="token keyword">import</span> reline <span class="token operator">=</span> <span class="token string">"020-85653333"</span>pattern <span class="token operator">=</span> <span class="token string">r"(?P&lt;区号>0\d&#123;2,3&#125;)-(?:\d&#123;8&#125;)"</span>m <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>pattern<span class="token punctuation">,</span>line<span class="token punctuation">)</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span><span class="token number">020</span><span class="token operator">-</span><span class="token number">85653333</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token string">"号码"</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span>Errorm<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token string">"区号"</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span><span class="token number">85653333</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python中re库介绍"><a href="#python中re库介绍" class="headerlink" title="python中re库介绍"></a>python中re库介绍</h3><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4></li></ol><ul><li>re.I 大小写不敏感</li><li>re.L 实现本地化识别(local-aware)匹配</li><li>re.M 多行匹配</li><li>re.S 匹配包括换行符在内的任何字符</li><li>re.U 使用Unicode字符集解析字符</li><li>re.X 该标志给予灵活格式.</li></ul><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li>search:从开头开始匹配,如果开头不匹配则失败</li><li>findall:获取匹配的所有字符串</li><li>sub:把匹配字符出从其中删去</li><li>compile:将正则表达式编译成正则表达式对象,方便之后复用</li><li>match:找到第一个匹配的字符串</li></ul><h3 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h3><p>正则表达式在线匹配网站:<code>https://c.runoob.com/front-end/854/</code></p>]]></content>
      
      
      <categories>
          
          <category> 正则表达式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>响应状态码</title>
      <link href="/2022/01/16/response_status_code/"/>
      <url>/2022/01/16/response_status_code/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th align="center">状态码</th><th align="center">状态码英文名称</th><th align="center">中文描述</th></tr></thead><tbody><tr><td align="center">100</td><td align="center">Continue</td><td align="center">继续。客户端应继续其请求</td></tr><tr><td align="center">101</td><td align="center">Switching Protocols</td><td align="center">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">200</td><td align="center">OK</td><td align="center">请求成功。一般用于GET与POST请求</td></tr><tr><td align="center">201</td><td align="center">Created</td><td align="center">已创建。成功请求并创建了新的资源</td></tr><tr><td align="center">202</td><td align="center">Accepted</td><td align="center">已接受。已经接受请求，但未处理完成</td></tr><tr><td align="center">203</td><td align="center">Non-Authoritative Information</td><td align="center">非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td align="center">204</td><td align="center">No Content</td><td align="center">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td align="center">205</td><td align="center">Reset Content</td><td align="center">重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td align="center">206</td><td align="center">Partial Content</td><td align="center">部分内容。服务器成功处理了部分GET请求</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">300</td><td align="center">Multiple Choices</td><td align="center">多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td></tr><tr><td align="center">301</td><td align="center">Moved Permanently</td><td align="center">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td align="center">302</td><td align="center">Found</td><td align="center">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td align="center">303</td><td align="center">See Other</td><td align="center">查看其它地址。与301类似。使用GET和POST请求查看</td></tr><tr><td align="center">304</td><td align="center">Not Modified</td><td align="center">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td align="center">305</td><td align="center">Use Proxy</td><td align="center">使用代理。所请求的资源必须通过代理访问</td></tr><tr><td align="center">306</td><td align="center">Unused</td><td align="center">已经被废弃的HTTP状态码</td></tr><tr><td align="center">307</td><td align="center">Temporary Redirect</td><td align="center">临时重定向。与302类似。使用GET请求重定向</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">400</td><td align="center">Bad Request</td><td align="center">客户端请求的语法错误，服务器无法理解</td></tr><tr><td align="center">401</td><td align="center">Unauthorized</td><td align="center">请求要求用户的身份认证</td></tr><tr><td align="center">402</td><td align="center">Payment Required</td><td align="center">保留，将来使用</td></tr><tr><td align="center">403</td><td align="center">Forbidden</td><td align="center">服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td align="center">404</td><td align="center">Not Found</td><td align="center">服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td></tr><tr><td align="center">405</td><td align="center">Method Not Allowed</td><td align="center">客户端请求中的方法被禁止</td></tr><tr><td align="center">406</td><td align="center">Not Acceptable</td><td align="center">服务器无法根据客户端请求的内容特性完成请求</td></tr><tr><td align="center">407</td><td align="center">Proxy Authentication Required</td><td align="center">请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td></tr><tr><td align="center">408</td><td align="center">Request Time-out</td><td align="center">服务器等待客户端发送的请求时间过长，超时</td></tr><tr><td align="center">409</td><td align="center">Conflict</td><td align="center">服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突</td></tr><tr><td align="center">410</td><td align="center">Gone</td><td align="center">客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td></tr><tr><td align="center">411</td><td align="center">Length Required</td><td align="center">服务器无法处理客户端发送的不带Content-Length的请求信息</td></tr><tr><td align="center">412</td><td align="center">Precondition Failed</td><td align="center">客户端请求信息的先决条件错误</td></tr><tr><td align="center">413</td><td align="center">Request Entity Too Large</td><td align="center">由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td></tr><tr><td align="center">414</td><td align="center">Request-URI Too Large</td><td align="center">请求的URI过长（URI通常为网址），服务器无法处理</td></tr><tr><td align="center">415</td><td align="center">Unsupported Media Type</td><td align="center">服务器无法处理请求附带的媒体格式</td></tr><tr><td align="center">416</td><td align="center">Requested range not satisfiable</td><td align="center">客户端请求的范围无效</td></tr><tr><td align="center">417</td><td align="center">Expectation Failed</td><td align="center">服务器无法满足Expect的请求头信息</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">500</td><td align="center">Internal Server Error</td><td align="center">服务器内部错误，无法完成请求</td></tr><tr><td align="center">501</td><td align="center">Not Implemented</td><td align="center">服务器不支持请求的功能，无法完成请求</td></tr><tr><td align="center">502</td><td align="center">Bad Gateway</td><td align="center">作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td></tr><tr><td align="center">503</td><td align="center">Service Unavailable</td><td align="center">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td align="center">504</td><td align="center">Gateway Time-out</td><td align="center">充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td align="center">505</td><td align="center">HTTP Version not supported</td><td align="center">服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 爬虫学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http基础</title>
      <link href="/2022/01/16/the_principle_of_HTTP/"/>
      <url>/2022/01/16/the_principle_of_HTTP/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP基本原理"><a href="#HTTP基本原理" class="headerlink" title="HTTP基本原理"></a>HTTP基本原理</h1><h2 id="1-URI-和-URL"><a href="#1-URI-和-URL" class="headerlink" title="1. URI  和  URL "></a>1.<strong> URI </strong> 和 <strong> URL </strong></h2><p>URI = URL(统一资源定位符,需要有路径) + URN(统一资源名称,只需要独一无二,例如ID card)</br><br>URL 统一格式:</br><br><code>scheme://[username:password@]hostname[:port][/path][;parameters][?query][#fragment] </code></p><h3 id="解释"><a href="#解释" class="headerlink" title="解释:"></a>解释:</h3><blockquote><p>scheme: 协议 也称protocol </br><br><strong>[username:password@]</strong>:用户名和密码<br><strong>hostname</strong>:主机地址</br><br><strong>port</strong>:端口</br><br><strong>path</strong>:路径,网络资源在服务器中的指定地址,类比操作系统中目录</br><br><strong>parameters</strong>:参数,访问资源的附加信息</br><br><strong>query</strong>:查询,查询某类资源,比如地址</br><code>https://www.baidu.com/baidu?tn=monline_3_dg&amp;ie=utf-8&amp;wd=%E4%BD%A0%E5%A5%BD%E6%9D%8E%E7%84%95%E8%8B%B1</code></br>问号后面限制了搜索引擎关键词<br>fragment:片段,对资源描述的部分补充.应用之一作为现代前端框架做路由管理,其二是HTML锚点(href = “#top”)</p></blockquote><h2 id="2-HTTP-和-HTTPS"><a href="#2-HTTP-和-HTTPS" class="headerlink" title="2. HTTP  和  HTTPS "></a>2.<strong> HTTP </strong> 和 <strong> HTTPS </strong></h2><p>HTTP只是单纯把超文本数据从网络传输到本地浏览器,HTTPS增加了SSL层,传输内容经过SSL加密.</br><br>这两个协议都是应用层协议,只负责信息传输的规范,其传输层还是TCP/IP(三次握手,四次挥手)协议,负责服务器和本地主机建立联系.</br></p><h2 id="3-HTTP-HTTPS请求过程"><a href="#3-HTTP-HTTPS请求过程" class="headerlink" title="3.HTTP/HTTPS请求过程:"></a>3.HTTP/HTTPS请求过程:</h2><p>客户端发送Request(请求),服务器收到请求进行解析,然后服务器返回Response(响应).浏览器得到响应之后进行响应解析渲染呈现.</p><h2 id="4-请求"><a href="#4-请求" class="headerlink" title="4.请求"></a>4.请求</h2><p>请求  ＝ 请求方法 + 请求网址 + 请求头 + 请求体</p><h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><p>常用<code>get</code>和<code>post</code></p><h4 id="GET方法"><a href="#GET方法" class="headerlink" title="GET方法:"></a>GET方法:</h4><blockquote><p>当输入网址按下回车的时候就已经输入了GET方法到服务器,请求参数(query)会和URL一起发给服务器.一个Get请求一次最多发送1024Byte大小数据</p></blockquote><h4 id="POST方法"><a href="#POST方法" class="headerlink" title="POST方法:"></a>POST方法:</h4><blockquote><p>当输入账号密码等需要提交表单的时候就是发送了<code>post</code>方法,参数不会包含在URL中,而是包含在请求体里面发给服务器.发送的数据没有大小要求.</p></blockquote><p>不常用方法有<code>HEAD</code>,<code>PUT</code>,<code>DELETE</code>,<code>CONNECT</code>,<code>OPTIONS</code>,<code>TRACE</code>.</p><ul><li>HEAD:类似于GET请求,但是Response中没有具体内容,用于获取响应头.</li><li>PUT: 用客户端发送给服务器的数据取代指定文档中的内容(修改操作,共享文档 <del>或许是</del> )</li><li>DELET: 请求服务器删除指定页面(类似于不使用<code>blank</code>)</li><li>CONNECT: 通过服务器代替客户端访问其他网页(<code>VPN</code>)</li><li>OPTIONS: 允许客户端查看服务器性能</li><li>TRACE: 回显服务器收到的请求,主要用于测试和诊断<h3 id="请求网址"><a href="#请求网址" class="headerlink" title="请求网址"></a>请求网址</h3>URL,不再赘述.<h3 id="请求头-headers"><a href="#请求头-headers" class="headerlink" title="请求头(headers)"></a>请求头(headers)</h3>服务器要使用的附加信息,常用来判断是否请求合法.<h4 id="常用请求头信息"><a href="#常用请求头信息" class="headerlink" title="常用请求头信息"></a>常用请求头信息</h4></li><li><strong>Accept</strong>: 请求报头域,用于指定客户端可接受哪些类型的信息 <del>(神画了一条线,说你只能在此地,不能逾越)</del> </li><li><strong>Accept-Language</strong>: 用于指定客户端的语言类型</li><li><strong>Accept-Encoding</strong>:用于指定客户端可接受的编码(常用UTF-8,也有GBK)</li><li><strong>Host</strong>:用于指定请求资源的主机IP和端口号</li><li><strong>Cookie/Cookies</strong>: 网站用于辨别用户,进行会话跟踪而存储在 <strong>用户本地</strong> 的数据.功能是 <strong>维持当前访问会话</strong>.</br><br>例如:</br>登录网站之后,客户端本地会保存服务器发来的Cookies,这样之后在网站内跳转,凭借Cookies就能保持登录状态,如果Cookies被删掉就要重新获得Cookies.(为了保证个人信息安全,请及时删除Cookies,以免病毒获得了你的Cookies,登入网站)</li><li><strong>Referer</strong>:用于标识请求是从那个页面发过来,判断访问是否合法(你不能在不进入浏览器的情况直接进入某宝的付款页面,但是正常登录就行,因为Referer不合法),以及来源统计(网站统计访问人数和来源).</li><li><strong>User-Agent/UA</strong>:帮助服务器识别客户端使用的操作系统以及版本、浏览器和版本信息.爬虫加上此头用于模仿浏览器的正常访问,如果不加,该UA就是Python.</li><li><strong>Content-Type</strong>: 也叫互联网媒体类型或者MIME类型,在HTTP中用来表示具体请求中的媒体类型信息,例如<code>text/html</code>表示<code>HTML</code>格式,<code>image/gif</code>表示<code>GIF</code>图片,<code>application/json</code>代表<code>json</code>类型<h3 id="请求体-body"><a href="#请求体-body" class="headerlink" title="请求体(body)"></a>请求体(body)</h3><a id="Content_Type_Table"></li></ul><p>在GET中为空,POSI为提交的表单信息</br></p><table><thead><tr><th align="center">Content-Type</th><th align="center">Post提交数据方式</th></tr></thead><tbody><tr><td align="center">application/x-www-form-urlencoded</td><td align="center">表单数据</td></tr><tr><td align="center">multipart/form-data</td><td align="center">表单文件上传</td></tr><tr><td align="center">application/json</td><td align="center">序列化json数据(<a href="https://baike.baidu.com/item/JSON/2462549?fr=aladdin">一种数据交换格式,本质是js对象的字符串表示方法</a>)</td></tr><tr><td align="center">text/xml</td><td align="center">xml数据(<a href="https://www.w3school.com.cn/xml/xml_intro.asp">一种可拓展标签语言,用来传递数据</a>)</td></tr></tbody></table><h2 id="5-响应"><a href="#5-响应" class="headerlink" title="5.响应"></a>5.响应</h2><h3 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h3><ul><li>状态码分类:</br></li></ul><table><thead><tr><th align="center">分类</th><th align="center">分类描述</th></tr></thead><tbody><tr><td align="center">1xx</td><td align="center">信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td align="center">2xx</td><td align="center">成功，操作被成功接收并处理</td></tr><tr><td align="center">3xx</td><td align="center">重定向，需要进一步的操作以完成请求</td></tr><tr><td align="center">4xx</td><td align="center">客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td align="center">5xx</td><td align="center">服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><ul><li>详解:</br></li><li>状态码    </li></ul><p><a href="response_status_code.md">详见响应状态码</a></p><h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h3><p>响应头包含服务器对请求的应答</p><ul><li><strong>Date</strong>:日期</li><li><strong>Last_Modified</strong>:指定资源的最后修改时间</li><li><strong>Content_Encoding</strong>:指定响应内容的编码</li><li><strong>Server</strong>:服务器信息</li><li><strong>Content_Type</strong>:文档类型,见<a href="#Content_Type_Table">请求头Content_Type对应数据类型</a></li><li><strong>Set_Cookie</strong>:服务器传给客户端的Cookies,需要在下次访问网站时携带此Cookie</li><li><strong>Expires</strong>:用于指定响应的过期时间,在此时间内浏览器可把内容写入缓存,下次直接从缓存中获得.</li></ul><h3 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h3><p>客户端对于请求返回的响应数据皆在此部分.是爬虫的爬取目标.</p><h2 id="6-HTTP2-0"><a href="#6-HTTP2-0" class="headerlink" title="6.HTTP2.0"></a>6.HTTP2.0</h2><h3 id="二进制分帧层"><a href="#二进制分帧层" class="headerlink" title="二进制分帧层"></a>二进制分帧层</h3><ul><li>帧是HTTP2.0中的概念.代表数据通信最小单位.比如请求头帧,请求体帧.</li><li>数据流:一个虚拟的双向通道,有唯一整数ID标识.</li><li>信息:与逻辑请求或响应信息对应的完整的一系列帧.</li></ul><p>HTTP2.0 将HTTP协议通信分解为二进制编码帧的交换,帧对应特定数据流中的信息,在一个TCP中复用,从而提高效率.</p><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>HTTP2.0通过讲HTTP消息分解为互不依赖的帧,交错发送,从而达到多路并行的效果(类似Pipeline),客户端再把这些帧拼接起来.</p><h3 id="流控制"><a href="#流控制" class="headerlink" title="流控制"></a>流控制</h3><p>流控制是为了防止服务器向客户端发送过量数据,客户端来不及处理.因为HTTP2.0只在一个TCP内复用,无法使用TCP自带流控制API.</br><br>为了解决这一问题,HTTP2.0提供了简单构建块.</p><ul><li>流控制具有方向性.每个接受方都能按自身需求为每个数据流甚至整个连接设置窗口大小.</li><li>流控制窗口大小是动态控制的.每个接受方都可以公布其窗口,当发送方发送DATA时窗口变小,接收方发出WINDOW_UPDATA时窗口变大.</li><li>流控制无法停止.<h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3>服务器可以对一个客户端请求发送多个数据.这个常用于发送了HTML文件之后再把CSS和JS发送过去.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 爬虫学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spider </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Requests的使用</title>
      <link href="/2022/01/16/the_use_of_requests/"/>
      <url>/2022/01/16/the_use_of_requests/</url>
      
        <content type="html"><![CDATA[<h1 id="Requests的应用"><a href="#Requests的应用" class="headerlink" title="Requests的应用"></a>Requests的应用</h1><h2 id="Get请求"><a href="#Get请求" class="headerlink" title="Get请求"></a>Get请求</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requests<span class="token comment">### 添加params</span>data <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token string">'name'</span><span class="token punctuation">:</span><span class="token string">'admin'</span><span class="token punctuation">,</span>    <span class="token string">'password'</span><span class="token punctuation">:</span><span class="token string">'passward'</span><span class="token punctuation">&#125;</span><span class="token comment">### 添加headers</span>headers <span class="token operator">=</span><span class="token punctuation">&#123;</span>    <span class="token string">"Host"</span><span class="token punctuation">:</span> <span class="token string">"pss.bdstatic.com"</span><span class="token punctuation">,</span>    <span class="token string">"User-Agent"</span><span class="token punctuation">:</span> <span class="token string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:96.0) Gecko/20100101 Firefox/96.0'</span>    <span class="token string">'Accept'</span><span class="token punctuation">:</span> <span class="token string">"*/*"</span>    <span class="token string">'Accept-Language'</span><span class="token punctuation">:</span> <span class="token string">'zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2'</span>    <span class="token string">'Accept-Encoding'</span><span class="token punctuation">:</span> <span class="token string">'gzip, deflate, br'</span>    <span class="token string">'Referer'</span><span class="token punctuation">:</span> <span class="token string">'https://www.baidu.com/baidu?tn=monline_3_dg&amp;ie=utf-8&amp;wd=%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%99%BB%E5%BD%95%E5%85%A8%E6%98%AFget'</span>    <span class="token string">'Connection'</span><span class="token punctuation">:</span> <span class="token string">'keep-alive'</span>    <span class="token string">'Sec-Fetch-Dest'</span><span class="token punctuation">:</span> <span class="token string">'script'</span>    <span class="token string">'Sec-Fetch-Mode'</span><span class="token punctuation">:</span> <span class="token string">'no-cors'</span>    <span class="token string">'Sec-Fetch-Site'</span><span class="token punctuation">:</span> <span class="token string">'cross-site'</span>    <span class="token string">'Pragma'</span><span class="token punctuation">:</span> <span class="token string">'no-cache'</span>    <span class="token string">'Cache-Control'</span><span class="token punctuation">:</span> <span class="token string">'no-cache'</span>    <span class="token string">'TE'</span><span class="token punctuation">:</span> <span class="token string">'trailers'</span><span class="token punctuation">&#125;</span>response <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span>params <span class="token operator">=</span> data<span class="token punctuation">,</span>headers <span class="token operator">=</span> headers<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token comment">### 如果返回是请求头,则能以str格式或者json格式输出</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>json<span class="token punctuation">)</span><span class="token comment">### 如果返回是网页,则能使用正则表达式匹配抓取</span><span class="token keyword">import</span> re pattern <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token builtin">compile</span><span class="token punctuation">(</span><span class="token string">"&lt;h1.*?> .*?&lt;/h1>"</span><span class="token punctuation">,</span>re<span class="token punctuation">.</span>S<span class="token punctuation">)</span>title <span class="token operator">=</span> re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>pattern<span class="token punctuation">,</span>response<span class="token punctuation">.</span>txt<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>title<span class="token punctuation">)</span><span class="token comment">### 如果是视频,图片,音频,则是二进制文件,使用context</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>context<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Post请求"><a href="#Post请求" class="headerlink" title="Post请求"></a>Post请求</h2><h3 id="基本用法实例"><a href="#基本用法实例" class="headerlink" title="基本用法实例"></a>基本用法实例</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requestsurl <span class="token operator">=</span> <span class="token string">''</span><span class="token comment">## </span>data <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token string">'name'</span><span class="token punctuation">:</span><span class="token string">'admin'</span><span class="token punctuation">,</span>    <span class="token string">'password'</span><span class="token punctuation">:</span><span class="token string">'passward'</span><span class="token punctuation">&#125;</span><span class="token comment">## 设置headers</span>headers <span class="token operator">=</span><span class="token punctuation">&#123;</span>    <span class="token string">"Host"</span><span class="token punctuation">:</span> <span class="token string">"pss.bdstatic.com"</span><span class="token punctuation">,</span>    <span class="token string">"User-Agent"</span><span class="token punctuation">:</span> <span class="token string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:96.0) Gecko/20100101 Firefox/96.0'</span>    <span class="token string">'Accept'</span><span class="token punctuation">:</span> <span class="token string">"*/*"</span>    <span class="token string">'Accept-Language'</span><span class="token punctuation">:</span> <span class="token string">'zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2'</span>    <span class="token string">'Accept-Encoding'</span><span class="token punctuation">:</span> <span class="token string">'gzip, deflate, br'</span>    <span class="token string">'Referer'</span><span class="token punctuation">:</span> <span class="token string">'https://www.baidu.com/baidu?tn=monline_3_dg&amp;ie=utf-8&amp;wd=%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%99%BB%E5%BD%95%E5%85%A8%E6%98%AFget'</span>    <span class="token string">'Connection'</span><span class="token punctuation">:</span> <span class="token string">'keep-alive'</span>    <span class="token string">'Sec-Fetch-Dest'</span><span class="token punctuation">:</span> <span class="token string">'script'</span>    <span class="token string">'Sec-Fetch-Mode'</span><span class="token punctuation">:</span> <span class="token string">'no-cors'</span>    <span class="token string">'Sec-Fetch-Site'</span><span class="token punctuation">:</span> <span class="token string">'cross-site'</span>    <span class="token string">'Pragma'</span><span class="token punctuation">:</span> <span class="token string">'no-cache'</span>    <span class="token string">'Cache-Control'</span><span class="token punctuation">:</span> <span class="token string">'no-cache'</span>    <span class="token string">'TE'</span><span class="token punctuation">:</span> <span class="token string">'trailers'</span><span class="token punctuation">&#125;</span><span class="token comment">##</span>response <span class="token operator">=</span> requests<span class="token punctuation">.</span>post<span class="token punctuation">(</span>url<span class="token punctuation">,</span>data <span class="token operator">=</span> data<span class="token punctuation">,</span> headers <span class="token operator">=</span> headers<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>status_code<span class="token punctuation">)</span><span class="token comment">##状态码</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>headers<span class="token punctuation">)</span><span class="token comment">##响应头</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>cookies<span class="token punctuation">)</span><span class="token comment">##cookie</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>url<span class="token punctuation">)</span><span class="token comment">##url</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>history<span class="token punctuation">)</span><span class="token comment">##请求你是</span><span class="token comment">## requests内置了状态码,比如 requests.codes,ok 就是 statsus_code 200</span>exit<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token keyword">not</span> response<span class="token punctuation">.</span>status_code <span class="token operator">==</span> requests<span class="token punctuation">.</span>codes<span class="token punctuation">.</span>ok <span class="token keyword">else</span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Successful"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requestsfiles <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">'file'</span><span class="token punctuation">:</span><span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"filepath"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>response <span class="token operator">=</span> requests<span class="token punctuation">.</span>post<span class="token punctuation">(</span>url<span class="token punctuation">,</span>files <span class="token operator">=</span> files<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Cookie设置"><a href="#Cookie设置" class="headerlink" title="Cookie设置"></a>Cookie设置</h4><pre class="line-numbers language-none"><code class="language-none">import requestsclass Spider:    def __init__(self,CookieJar):        self.cookies &#x3D; Requests.cookies.RequestsCookieJar() ## 创建一个Cookiejar类    def Update(cookies):        self.cookies.updata(cookies)    def Crawler_get(url)        self.response &#x3D; requests.get(url,cookies &#x3D; self.cookies)##r &#x3D; requests.get(url)print(r.cookies) ## cookies 属于RequestsCookieJar类型for key,values in r.cookies.items(): ##用items方法返回一个由Cookie组成的元组    print(key + &quot;:&quot; + values)## 使用Cookie去访问网站MySpider &#x3D; Spider()          ## 创捷Spider对象MySpider.Update(r.cookies)   ## 更新cookiesMySpider.Crawler_get(url)    ## 获取开始爬<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Session维持"><a href="#Session维持" class="headerlink" title="Session维持"></a>Session维持</h4><p><code>Session</code>维持能保证两次请求的时候都是同一个账户,并且不需要手动保持<code>Cookie</code>,显得更为方便.其主要模拟同一个浏览器访问同一个站点的不同页面.</p><p>下面举例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requestsrequests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'https://www.httpbin.org/cookies/set/number/123456789'</span><span class="token punctuation">)</span> <span class="token comment">##这个网址能设置cookies</span>response <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'http://www.httpbin.org/cookies'</span><span class="token punctuation">)</span> <span class="token comment">##访问这个网址能获取自己的请求头,这里是返回自己的cookies</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>text<span class="token punctuation">)</span> <span class="token comment">##这里面不会有之前这是的cookies</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requestss <span class="token operator">=</span> requests<span class="token punctuation">.</span>Session<span class="token punctuation">(</span><span class="token punctuation">)</span>s<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'https://www.httpbin.org/cookies/set/number/123456789'</span><span class="token punctuation">)</span>response <span class="token operator">=</span> s<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'http://www.httpbin.org/cookies'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>text<span class="token punctuation">)</span> <span class="token comment">###这里返回了cookies</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="SSL证书验证"><a href="#SSL证书验证" class="headerlink" title="SSL证书验证"></a>SSL证书验证</h4><p>有些网站可能没有设置好HTTPS证书,或者其证书没有被CA认证,那么访问的时候就会出现SSL证书错误异常,那么就需要让爬虫自动处理.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requestsresponse <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>verify <span class="token operator">=</span> <span class="token boolean">False</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>status_code<span class="token punctuation">)</span><span class="token comment">##这里能输出200,但是会有一个warning,让我们指定证书,我们可以设置忽略</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如下</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requests<span class="token keyword">from</span> requests<span class="token punctuation">.</span>packages<span class="token punctuation">.</span>md <span class="token keyword">import</span> urllib3urllib3<span class="token punctuation">.</span>disable_warnings<span class="token punctuation">(</span><span class="token punctuation">)</span>response <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>verify <span class="token operator">=</span> <span class="token boolean">False</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>status_code<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者我们可以把警告捕获到日志,从而忽略</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> logging<span class="token keyword">import</span> requestslogging<span class="token punctuation">.</span>CaptureWarnings<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>response <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>verify <span class="token operator">=</span> <span class="token boolean">False</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>status_code<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然也可以设置本地证书用作客户端证书,可以是单个文件,也可以是包含两个文件路径的元组</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requestsresponse <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>cert <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'/path/server.crt'</span><span class="token punctuation">,</span><span class="token string">'/path/server.key'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>status_code<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="超时设置"><a href="#超时设置" class="headerlink" title="超时设置"></a>超时设置</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requestsresponse <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>timeout <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h4><p><code>urllib</code>中有<code>HTTPBasicAuthHandler</code>来处理身份验证问题,那么同样的<code>requests</code>中也有相应的库来处理.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requests<span class="token keyword">from</span> requests<span class="token punctuation">.</span>auth <span class="token keyword">import</span> HTTPBasicAuthr <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>auth <span class="token operator">=</span> HTTPBasicAuth<span class="token punctuation">(</span><span class="token string">"admin"</span><span class="token punctuation">,</span><span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">##或者</span>r <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>auth <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"admin"</span><span class="token punctuation">,</span><span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>status_code<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外,<code>requests</code>还提供了其他认证方式,比如<code>oa</code>验证,提供了<code>OAuth</code>,需要安装<code>oauth</code>包.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requests<span class="token punctuation">.</span>oauthlib <span class="token keyword">import</span> OAuth1<span class="token keyword">import</span> requestauth <span class="token operator">=</span> OAuth1<span class="token punctuation">(</span><span class="token string">'Your_App_Key'</span><span class="token punctuation">,</span><span class="token string">'You_App_Secret'</span><span class="token punctuation">,</span><span class="token string">'User_Oauth_Token'</span><span class="token punctuation">,</span><span class="token string">'User_Oauth_Token_Secret'</span><span class="token punctuation">)</span>response <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">.</span>auth <span class="token operator">=</span> auth<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a>代理设置</h4><p><code>urllib</code>中有<code>ProxyHandler</code>来处理身份验证问题,那么同样的<code>requests</code>中也有相应的库来处理.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requestsproxies <span class="token operator">=</span> <span class="token punctuation">&#123;</span>        <span class="token string">'http'</span><span class="token punctuation">:</span><span class="token string">'http://'</span>        <span class="token string">'https'</span><span class="token punctuation">:</span><span class="token string">'https://'</span><span class="token punctuation">&#125;</span>requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>proxies <span class="token operator">=</span> proxies<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果需要身份验证,那么,可以使用类似<code>http://user:password@host:port</code>的形式设置代理.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requestsproxies <span class="token operator">=</span> <span class="token punctuation">&#123;</span>        <span class="token string">'http'</span><span class="token punctuation">:</span><span class="token string">'http://user:password@'</span>        <span class="token string">'https'</span><span class="token punctuation">:</span><span class="token string">'https://user:password@'</span><span class="token punctuation">&#125;</span>requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>proxies <span class="token operator">=</span> proxies<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Requests库的实现浅尝"><a href="#Requests库的实现浅尝" class="headerlink" title="Requests库的实现浅尝"></a>Requests库的实现浅尝</h3><p>实际上,在使用requests库的时候,他是在内部构造了一个Request对象,并给这个对象各种参数,再把这个Request对象发送出去,请求成功之后再返回Response对象.</p><p>这个Request对象是Prepare Request类型</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> requests <span class="token keyword">import</span> Request<span class="token punctuation">,</span>Sessionurl <span class="token operator">=</span> <span class="token string">''</span>data <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">''</span><span class="token punctuation">:</span><span class="token string">''</span><span class="token punctuation">&#125;</span>headers <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">''</span><span class="token punctuation">:</span><span class="token string">''</span><span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">:</span><span class="token string">''</span><span class="token punctuation">&#125;</span>s <span class="token operator">=</span> Session<span class="token punctuation">(</span><span class="token punctuation">)</span>req <span class="token operator">=</span> Request<span class="token punctuation">(</span><span class="token string">'POST'</span><span class="token punctuation">,</span>url<span class="token punctuation">,</span>data<span class="token operator">=</span> data<span class="token punctuation">,</span>headers <span class="token operator">=</span> headers<span class="token punctuation">)</span> <span class="token comment">##创建了一个request对象</span>prepped <span class="token operator">=</span> s<span class="token punctuation">.</span>prepare_request<span class="token punctuation">(</span>req<span class="token punctuation">)</span> <span class="token comment">##把request对象转换为一个prepare_request对象</span>r <span class="token operator">=</span> s<span class="token punctuation">.</span>send<span class="token punctuation">(</span>prepped<span class="token punctuation">)</span><span class="token comment">##把prepare_request对象发送出去,获得其response对象</span><span class="token keyword">print</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 爬虫学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> spider </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫基础</title>
      <link href="/2022/01/16/the_principle_of_crawler/"/>
      <url>/2022/01/16/the_principle_of_crawler/</url>
      
        <content type="html"><![CDATA[<h1 id="一、爬虫的基本原理"><a href="#一、爬虫的基本原理" class="headerlink" title="一、爬虫的基本原理"></a>一、爬虫的基本原理</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>爬虫就是假装浏览器爬取网页并获取信息.</p><h2 id="爬取数据类型"><a href="#爬取数据类型" class="headerlink" title="爬取数据类型"></a>爬取数据类型</h2><ul><li>最常见的就是爬虫能爬取JSON形式的HTML代码.</li><li>对于js,css等文件,需分析源代码后台Ajax接口,或者使用<code>Selenium</code>,<code>Splash</code>,<code>Pyppeteer</code>,<code>Playwright</code>等库来模拟js渲染.<h1 id="二、Session-和-Cookie"><a href="#二、Session-和-Cookie" class="headerlink" title="二、Session 和 Cookie"></a>二、Session 和 Cookie</h1><h2 id="无状态HTTP-查询wink状态"><a href="#无状态HTTP-查询wink状态" class="headerlink" title="无状态HTTP (#查询wink状态)"></a>无状态HTTP <del>(#查询wink状态)</del></h2>HTTP对无状态表示HTTP协议对于事务处理没有记忆能力,也就是说服务器并不知道客户端处于什么状态.这意味着如果需要处理前面的信息,客户端必须重传,造成资源浪费.所以,服务器端会保存一个<code>Session</code>,客户端保存一个<code>Cookie</code>,通过这两个凭证,服务器才能做出相应响应.<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2>Web中,Session对象用来存储特定用户是所需的属性和配置信息.这样用户再响应的网页跳转时,存储在Session中的信息不丢失.如果Session过期或者没有Session,服务器会创建一个Session.<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2>见<a href="the_principle_of_HTTP.md">HTTP原理</a><h2 id="Session维持"><a href="#Session维持" class="headerlink" title="Session维持"></a>Session维持</h2>客户端第一次请求服务器的时候,服务器会返回一个<code>Set_Cookie</code>.客户端保存响应字符串,并在之后的请求中带上<code>Cookie</code>.<code>Cookie</code>中保存着响应的<code>SessionID</code>,服务器通过查询<code>SessionID</code>来找到对应<code>Session</code>,进而判断用户状态.<h2 id="Cookie的属性结构"><a href="#Cookie的属性结构" class="headerlink" title="Cookie的属性结构"></a>Cookie的属性结构</h2>在浏览器中打开<code>Application</code>选项卡,<code>Storage</code>最后一项就是<code>Cookie</code>.</li><li><strong>Name</strong>: <code>Cookie</code>名称</li><li><strong>Value</strong>:<code>Cookie</code>的值,如果是<code>Unicode</code>字符则需要字符编码,如果是二进制数据,则是<code>BASE64</code>编码.</li><li><strong>Domain</strong>:指定可以访问该<code>Cookie</code>的域名.表示该<code>Cookie</code>的可用范围.</li><li><strong>Path</strong>:<code>Cookie</code>的使用路径.如果是/path/,则表示只在该路径可用,如果是/则表示在该<code>Domain</code>下都可用.</li><li><strong>Size</strong>:表示<code>Cookie</code>的大小.</li><li><strong>HTTP</strong>:<code>Cookie</code>的<code>httponly</code>属性,如果是<code>True</code>,则表示只有在<code>HTTP Headers</code>中才含有此<code>Cookie</code>,而不能使用<code>document.cookie</code>来访问此<code>Cookie</code>.</li><li><strong>Secure</strong>:是否允许使用安全协议传输<code>Cookie</code>.<h2 id="会话Cookie和持久Cookie"><a href="#会话Cookie和持久Cookie" class="headerlink" title="会话Cookie和持久Cookie"></a>会话Cookie和持久Cookie</h2>会话<code>Cookie</code>和持久<code>Cookie</code>本质只是Cookie存储的位置不同,一个是存在缓存,一个是存在硬盘.持久<code>Cookie</code>的有效期很久,所以可以在下次登录的时候直接使用硬盘中的<code>Cookie</code>.<h1 id="三、代理的基本原理"><a href="#三、代理的基本原理" class="headerlink" title="三、代理的基本原理"></a>三、代理的基本原理</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2>代理本名代理服务器(<code>Proxy Server</code>),功能是代网络用户获得信息.客户端把请求发给代理服务器,代理服务器再把请求发给服务器.响应在经过代理服务器返回给客户端.在这个过程中服务器接受到的是代理服务器的<code>IP</code>.<h2 id="代理的作用"><a href="#代理的作用" class="headerlink" title="代理的作用"></a>代理的作用</h2></li><li>突破IP访问限制,访问一些访问不到的站点 <del>(科学上网)</del></li><li>访问一些单位或者团队的内部资源 (校园VPN)</li><li>提高访问速度.代理服务器一般都有一个较大的硬盘缓冲区,可以保存数据.如果其他用户访问,可以直接把这些数据给用户(类似<code>cache</code>)</li><li>隐藏真实的IP,保护个人信息.<h2 id="爬虫代理"><a href="#爬虫代理" class="headerlink" title="爬虫代理"></a>爬虫代理</h2>爬虫爬取速度过快,服务器检测到一个IP地址行为异常会直接封锁IP.使用代理,爬虫就会认为是代理服务器在访问自己,通过切换代理就能防止被发现.<h2 id="代理分类"><a href="#代理分类" class="headerlink" title="代理分类"></a>代理分类</h2><h3 id="根据协议区分"><a href="#根据协议区分" class="headerlink" title="根据协议区分"></a>根据协议区分</h3></li><li>FTP代理,访问FTP服务器,主要端口是21和2121</li><li>HTTP代理 访问HTTP服务器,主流的代理,端口是80和8080</li><li>SSL/TLS代理 主要访问加密网站,一般有SSL和TLS加密功能,端口一般是443</li><li>RTSP代理 主要用于Realplayer访问Real流服务器,端口一般是554</li><li>Telnet代理 主要用于Telnet远程控制(黑客Ddos攻击时隐藏身份),一般端口时23</li><li>POP3/SMTP代理 主要用于以POP3/SMTP发送邮件,具有缓存功能,端口一般是110/25</li><li>SOCKS代理 单纯传递数据包,不关心协议和用法,一般有缓存功能,端口一般是1080.SOCK代理分为SOCKS4和SOCKS5.SOCKS4只支持TCP,SOCKS支持TCP和UDP,还支持身份验证机制,服务器端域名解析等.<h3 id="根据匿名程度区分"><a href="#根据匿名程度区分" class="headerlink" title="根据匿名程度区分"></a>根据匿名程度区分</h3></li><li>高度匿名代理 将数据包原封不动转发,在服务端看来就是一个普通客户端,记录的是代理的IP</li><li>普通匿名代理 会对数据包做一些处理,服务端可能发现这是一个代理,然后追查客户端的真实IP.这种代理通常会加入的HTTP头有HTTP_VIA,HTTP_X_FORWARDED_FOR</li><li>透明代理 该种代理不仅会更改数据包,还会告诉服务器真实IP,主要用于过滤数据包,常用于内网防火墙.</li><li>间谍代理 常见于组织或者个人创建的代理服务器,用于记录用户传输的数据,然后对传输数据进行研究和监控.<h3 id="常见代理设置"><a href="#常见代理设置" class="headerlink" title="常见代理设置"></a>常见代理设置</h3></li><li>网上的免费代理,建议全部抓取下来一个个筛选,然后维护代理池.</li><li>付费代理</li><li>ADSL拨号,昂贵但是稳定性高</li><li>蜂窝代理 即使用4G/5G网卡等制作的代理.该代理情形较小,封锁概念低,但是成本高.<h1 id="四、多线程和多进程的基本原理"><a href="#四、多线程和多进程的基本原理" class="headerlink" title="四、多线程和多进程的基本原理"></a>四、多线程和多进程的基本原理</h1><h2 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h2>进程可以理解为独立运行的程序单位.比如打开浏览器.<br>线程是进程中的多个任务,比如浏览器打开之后访问网址,加载网页,看视频能同时进行.这就是多线程<h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2></li><li>并发:指多个线程对应的多条指令被快速轮换地执行.人宏观上感受不到进程切换,感觉是一起执行</li><li>并行:指同一时刻有多条指令在多个处理器上同时执行.宏观和微观上都是并行.<h2 id="多线程的爬虫应用场景"><a href="#多线程的爬虫应用场景" class="headerlink" title="多线程的爬虫应用场景"></a>多线程的爬虫应用场景</h2>爬虫在向服务器发送请求等待响应的时间内可以处理其他线程.<h2 id="Python中的多线程"><a href="#Python中的多线程" class="headerlink" title="Python中的多线程"></a>Python中的多线程</h2>Python中GIL(Global Interpreter Lock)的限制导致同一时刻下只可能进行一个线程,无法发挥多核并行的优势.所以不可能并行,只能并发.<h3 id="Python多线程下每个线程的执行方式"><a href="#Python多线程下每个线程的执行方式" class="headerlink" title="Python多线程下每个线程的执行方式:"></a>Python多线程下每个线程的执行方式:</h3></li><li>获取GIL</li><li>执行代码</li><li>释放GIL<br>Python多进程效果强于多线程.因为每一个进程都有自己的GIL,互不干扰.而多线程需要频繁切换GIL,反而减慢速度.</br><br>可见大佬博客学习</br><blockquote><p>python多线程:<a href="https://cuiqingcai.com/3325.html">https://cuiqingcai.com/3325.html</a></br><br>python多进程:<a href="https://cuiqingcai.com/3335.html">https://cuiqingcai.com/3335.html</a></br></p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 爬虫学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spider </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>urllib的使用</title>
      <link href="/2022/01/16/the_use_of_urllib/"/>
      <url>/2022/01/16/the_use_of_urllib/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是python自带的爬虫相关模块,但市面上有更好的BeautifulSoup模块和requests模块.如果是速成爬虫直接学习那两个模块用法即可,但requests模块是使用urllib搭建而成,如果时间不急,可以从底层看起.</br></p><h1 id="urllib的使用"><a href="#urllib的使用" class="headerlink" title="urllib的使用"></a>urllib的使用</h1><p>基本模块:</p><ul><li><strong>request</strong>:HTTP请求模块</li><li><strong>error</strong>:异常处理模块</li><li><strong>parse</strong>:工具模块,提供url处理方法</li><li><strong>robotparser</strong>:识别网站的robot.txt文件<h2 id="requset模块"><a href="#requset模块" class="headerlink" title="requset模块"></a>requset模块</h2><h3 id="urlopen"><a href="#urlopen" class="headerlink" title="urlopen"></a>urlopen</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> urllib<span class="token punctuation">.</span>requsetresponse <span class="token operator">=</span> urlib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>url<span class="token punctuation">,</span>data<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span><span class="token punctuation">[</span>timeout<span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">,</span>cafile<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>capath<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>cadefault<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>context<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><strong ><font face = "仿宋"  size = 4 >参数解释</font></strong ></li><li>url: 网页地址</li><li>data: <code>bytes</code>类型的字节流编码<blockquote><p><code>data = bytes(urllib.parse.urlencode(&#123;&#39;username&#39;:&#39;admin&#39;&#125;),encoding = &quot;utf-8&quot;)</code></p></blockquote></li><li>timeout:超时时间设置,单位秒.</li><li>其他参数:<blockquote><p>context:接受ssl.SSLContext类,用来设置SSL</br><br>cafile/capath:设置CA证书和其路径,请求https链接有用</br><br>cadefault:已经弃用</br></p></blockquote></li></ul><h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> urllib<span class="token punctuation">.</span>requestrequest <span class="token operator">=</span> urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>Request<span class="token punctuation">(</span>url<span class="token punctuation">)</span>response <span class="token operator">=</span> urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>Request</code>使用<code>Request</code>对象传给<code>urlopen</code>,可读性更高,封装更好.</p><h4 id="Request构造"><a href="#Request构造" class="headerlink" title="Request构造"></a>Request构造</h4><pre class="line-numbers language-none"><code class="language-none">request &#x3D; urllib.request.Request(url,data&#x3D;None,headers&#x3D;&#123;&#125;,origin_req_host&#x3D;None,unverifiable&#x3D;False,method&#x3D;None)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>url:同urlopen</li><li>data:同urlopen</li><li>headers:传一个字典参数,作为请求头</li><li>origin_req_host:请求方的host名称或者IP地址</li><li>unverifiable:表示请求是否是无法验证的,默认为<code>False</code>,表示用户没有足够的权限来接受这个请求的结果</li><li>method:字符串参数,表示请求方法,如GET,POST,PUT,DELETE<h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3>request的高级用法依托<code>Handler</code>实现.<br>首先是所有<code>Handler</code>的父类<code>BaseHandler</code>,其提供了基本方法,如default_open,protocol_request等<br>其几个子类如下<blockquote><ul><li><strong>HTTPDefaultErrorHandler</strong>:用于处理<code>HTTP</code>响应错误,所有错误都会抛出<code>HTTPError</code>类型的异常</li><li><strong>HTTPRedirectHandler</strong>:用于处理重定向</li><li><strong>HTTPCookieProcessor</strong>:用于处理Cookie</li><li><strong>ProxyHandler</strong>:用于设置代理,代理默认为空</li><li><strong>HTTPPasswordMgr</strong>:用于密码管理,维护者用户名密码对照表</li><li><strong>HTTPBasicAuthHandler</strong>:用于管理认证,如果一个链接在打开的时候需要认证,那么可以用这个解决认证问题.</li></ul></blockquote></li></ul></br><p>另外一个比较重要的类是<code>OpenerDirector</code>,简称Opener.之前的<code>urlopen</code>方法就是一个<code>Opener</code>.<code>Request</code>类和<code>urlopen</code>类都是已经封装好的常用请求方法,如果需要高级用法则需要使用更加底层的实例来完成操作.</br><br><code>Opener</code>类提供<code>Open</code>方法,该方法的返回的响应类型和<code>urlopen</code>方法一致.<code>Opener</code>类需要使用<code>Handler</code>类来构建.<br></br></p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>在访问一些服务器的时候,有些网页需要用户输入账号密码进行身份验证.这就是<code>HTTP Basic Access Authentication</code>.</br><br>爬虫借助<code>HTTPBasicAuthHandler</code>模块就能完成身份验证.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> urllib<span class="token punctuation">.</span>request <span class="token keyword">import</span> HTTPPasswordMgrWithDefaultRealm<span class="token punctuation">,</span> HTTPBasicAuthHandler<span class="token punctuation">,</span> build_opener<span class="token keyword">import</span> urllib<span class="token punctuation">.</span>errorusername <span class="token operator">=</span> <span class="token string">'admin'</span>password <span class="token operator">=</span> <span class="token string">'password'</span>url <span class="token operator">=</span> <span class="token string">''</span>p <span class="token operator">=</span> HTTPPasswordMgrWithDefaultRealm<span class="token punctuation">(</span><span class="token punctuation">)</span> p<span class="token punctuation">.</span>addpassword<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">,</span>url<span class="token punctuation">,</span>username<span class="token punctuation">,</span>password<span class="token punctuation">)</span> <span class="token comment">##这个类是构建　用户名和密码　对一个地址的映射，这个映射可以是　url 也可以是 proxy </span>auth_handler <span class="token operator">=</span> HTTPBasicAuthHandler<span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token comment">## HTTPBasicAuthHandler的构造方法需要提供一个HTTPPasswordMgr(密码管理 Password Management Object) 对象 如果不知道域/对域不需要关心,就使用 HTTPPasswordMgrwithDefaultRealm 对象,使用None作为构造参数,知道的话就使用realm代替None </span>opener <span class="token operator">=</span> build_opener<span class="token punctuation">(</span>auth_handler<span class="token punctuation">)</span> <span class="token comment">## 构建了一个opener,可以使用这个opener去open url.如果这个opener是 网页验证,那么就是open url,如果是 代理验证,那么访问的时候,就是使用代理ip帮你访问(相当于Request封装再更底层)</span><span class="token keyword">try</span><span class="token punctuation">:</span>    result <span class="token operator">=</span> opener<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>    html <span class="token operator">=</span> result<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span><span class="token keyword">except</span> URLError <span class="token keyword">as</span> e<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>reason<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>代理的逻辑同验证一样,先使用ProxyHandler建立代理,再使用build_opener方法建立opener,再使用这个opener打开你需要的web</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> urllib<span class="token punctuation">.</span>requset <span class="token keyword">import</span> ProxyHandler<span class="token punctuation">,</span> build_opener<span class="token punctuation">,</span> <span class="token keyword">from</span> urllib<span class="token punctuation">.</span>error <span class="token keyword">import</span> URLErrorproxy_Handler <span class="token operator">=</span> ProxyHandler<span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token string">'http'</span><span class="token punctuation">:</span><span class="token string">'http://'</span><span class="token punctuation">,</span>                             <span class="token string">'https'</span><span class="token punctuation">:</span><span class="token string">'https://'</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token comment">## ProxyHandler类的构造需要一个字典</span>opener <span class="token operator">=</span> build_opener<span class="token punctuation">(</span>proxy_Handler<span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">:</span>    response <span class="token operator">=</span> opener<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">except</span> URLError <span class="token keyword">as</span> e<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>reason<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是如果碰到了代理验证的话,那么还是需要使用HTTPBasicAuthHandler</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> urllib<span class="token punctuation">.</span>request <span class="token keyword">import</span> HTTPPasswordMgrWithDefaultRealm<span class="token punctuation">,</span> HTTPBasicAuthHandler<span class="token punctuation">,</span> build_opener<span class="token keyword">import</span> urllib<span class="token punctuation">.</span>errorusername <span class="token operator">=</span> <span class="token string">'admin'</span>password <span class="token operator">=</span> <span class="token string">'password'</span>proxyserver <span class="token operator">=</span> <span class="token string">"61.158.163.130:16816"</span> <span class="token operator">//</span> 此时代理地址直接使用IP地址的字符串url <span class="token operator">=</span> <span class="token string">''</span>p <span class="token operator">=</span> HTTPPasswordMgrWithDefaultRealm<span class="token punctuation">(</span><span class="token punctuation">)</span> p<span class="token punctuation">.</span>addpassword<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">,</span>proxyserver<span class="token punctuation">,</span>username<span class="token punctuation">,</span>password<span class="token punctuation">)</span> <span class="token comment">##这个类是构建　用户名和密码　对代理地址的映射</span>auth_handler <span class="token operator">=</span> HTTPBasicAuthHandler<span class="token punctuation">(</span>p<span class="token punctuation">)</span> opener <span class="token operator">=</span> build_opener<span class="token punctuation">(</span>auth_handler<span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">:</span>    result <span class="token operator">=</span> opener<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>    html <span class="token operator">=</span> result<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span><span class="token keyword">except</span> URLError <span class="token keyword">as</span> e<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>reason<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>获取网站的Cookie,就是根据网站的响应头里面的 Set_Cookie的值来设置Cookie.</br><br>思路是构建CookieJar对象,再用这个对象创建opener,用这个opener打开网站,其响应的cookie会自动给CookieJar对象,通过直接访问CookieJar对象来获得Cookie.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> urlib<span class="token punctuation">.</span>request <span class="token keyword">import</span> HTTPCookieProcessor<span class="token punctuation">,</span>build_opener<span class="token keyword">from</span> http<span class="token punctuation">.</span>cookiejar <span class="token keyword">import</span> CookieJarcookie <span class="token operator">=</span> CookieJar<span class="token punctuation">(</span><span class="token punctuation">)</span>handler <span class="token operator">=</span> HTTPCookieProcessor<span class="token punctuation">(</span>cookie<span class="token punctuation">)</span>opener <span class="token operator">=</span> build_opener<span class="token punctuation">(</span>handler<span class="token punctuation">)</span>response <span class="token operator">=</span> opener<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token keyword">for</span> items <span class="token keyword">in</span> cookie<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">':'</span> <span class="token operator">+</span> item<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果需要保存cookie的话,那么需要使用MozillaCookieJar.它是CookieJar的子类,专门用于处理Cookie,比如Cookie的读取和保存,其将Cookie保存为Mozilla浏览器类型的Cookie,也就是在请求头中看到的格式.</br></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> urlib<span class="token punctuation">.</span>request <span class="token keyword">import</span> HTTPCookieProcessor<span class="token punctuation">,</span>build_opener<span class="token keyword">from</span> http<span class="token punctuation">.</span>cookiejar <span class="token keyword">import</span> MozillaCookieJarfilename <span class="token operator">=</span> <span class="token string">'cookie.txt'</span>cookie <span class="token operator">=</span> MozillaCookieJar<span class="token punctuation">(</span>filename<span class="token punctuation">)</span>handler <span class="token operator">=</span> HTTPCookieProcessor<span class="token punctuation">(</span>cookie<span class="token punctuation">)</span>opener <span class="token operator">=</span> build_opener<span class="token punctuation">(</span>handler<span class="token punctuation">)</span>response <span class="token operator">=</span> opener<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>cookie<span class="token punctuation">.</span>save<span class="token punctuation">(</span>ignore_discard <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">,</span>ignore_expires <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token comment">## ignore_discard 及时被弃用也将其保存下来,ignore_expires 及时已经过期也将其保存</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样的,如果是LWP(<code>libwww-perl</code>)格式,则使用</p><pre class="line-numbers language-none"><code class="language-none">cookie &#x3D; LWPCookieJar(filename)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那么,如何读取利用cookie?.下面是代码</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> urllib<span class="token punctuation">.</span>request <span class="token keyword">import</span> HTTPCookieProcessor<span class="token punctuation">,</span>build_opener<span class="token keyword">from</span> http<span class="token punctuation">.</span>cookiejar <span class="token keyword">import</span> MozillaCookieJarcookie <span class="token operator">=</span> CookieJar<span class="token punctuation">(</span><span class="token punctuation">)</span>cookie<span class="token punctuation">.</span>load<span class="token punctuation">(</span><span class="token string">"cookie.txt"</span><span class="token punctuation">,</span>ignore_discard <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">,</span>ignore_expires <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">)</span>handler <span class="token operator">=</span> HTTPCookieProcessor<span class="token punctuation">(</span>cookie<span class="token punctuation">)</span>opener <span class="token operator">=</span> build_opener<span class="token punctuation">(</span>handler<span class="token punctuation">)</span>response <span class="token operator">=</span> opener<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p><code>urllib.error</code>定义了<code>urllib.request</code>库产生的异常</p><h3 id="URLError"><a href="#URLError" class="headerlink" title="URLError"></a>URLError</h3><p><code>URLError</code>来自<code>urllib.error</code>库,继承于<code>OSError</code>,是<code>urllib.error</code>异常模块的基类.它具有一个reason属性,返回错误原因.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> urllib<span class="token punctuation">.</span>error<span class="token keyword">try</span><span class="token punctuation">:</span>    result <span class="token operator">=</span> opener<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>    html <span class="token operator">=</span> result<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span><span class="token keyword">except</span> URLError <span class="token keyword">as</span> e<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>reason<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="HTTPError"><a href="#HTTPError" class="headerlink" title="HTTPError"></a>HTTPError</h3><p><code>HTTPError</code>是<code>URLError</code>的子类,专门用来处理<code>HTTP</code>请求错误,例如认证请求失败.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> urllib<span class="token punctuation">.</span>error<span class="token keyword">try</span><span class="token punctuation">:</span>    result <span class="token operator">=</span> opener<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>    html <span class="token operator">=</span> result<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span><span class="token keyword">except</span> HTTPError <span class="token keyword">as</span> e<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>reason<span class="token punctuation">,</span>e<span class="token punctuation">.</span>code<span class="token punctuation">,</span>e<span class="token punctuation">.</span>headers<span class="token punctuation">)</span><span class="token keyword">except</span> URLError <span class="token keyword">as</span> e<span class="token punctuation">:</span> <span class="token comment">##如果不是HTTPError,则进入URLError捕获</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>reason<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="解析链接"><a href="#解析链接" class="headerlink" title="解析链接"></a>解析链接</h2><p><code>urllib.parse</code>块定义了处理URL的标准接口,例如实现URL各部分的抽取,合并已经连接转换.</p><h3 id="urlparse"><a href="#urlparse" class="headerlink" title="urlparse"></a>urlparse</h3><p>该方法实现<code>URL</code>的识别和分段</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> urllib<span class="token punctuation">.</span>parse <span class="token keyword">import</span> urlparseresult <span class="token operator">=</span> urlparse<span class="token punctuation">(</span><span class="token string">'https://www.baidu.com/index.html;user?id=5#commemt'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">##&lt;class 'urllib.parse.ParseResult'>,是一个元组,可以使用索引或者序列号访问其中的元素</span><span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token comment">## scheme,netloc,path,params,query fragment</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可得标准链接格式:</p><pre class="line-numbers language-none"><code class="language-none">scheme:&#x2F;&#x2F;netloc&#x2F;path;params?query#fragment<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>urlparse</code>含有三个参数,下面是解释</p><ul><li><strong>urlstring</strong>:待解析的url</li><li><strong>scheme</strong>:默认的协议,如果url没有提供协议则会用这个代替</li><li><strong>allow_fragment</strong>:是否忽略<code>fragment</code></li></ul><h3 id="urlunparse"><a href="#urlunparse" class="headerlink" title="urlunparse"></a>urlunparse</h3><p>此方法用于构造url.参数必须是一个可迭代对象,长度必须为6,否则会抛出异常.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> urllib<span class="token punctuation">.</span>parse <span class="token keyword">import</span> urlunparsestring <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"https"</span><span class="token punctuation">,</span><span class="token string">"www.baidu.com"</span><span class="token punctuation">,</span><span class="token string">"index.html"</span><span class="token punctuation">,</span><span class="token string">"user"</span><span class="token punctuation">,</span><span class="token string">"id=5"</span><span class="token punctuation">,</span><span class="token string">"commemt"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="urlsplit"><a href="#urlsplit" class="headerlink" title="urlsplit"></a>urlsplit</h3><p>和<code>urlparse</code>类似,只不过<code>params</code>不会单独出现,划分为path的一部分,返回结果是<code>SplitResult</code>,和<code>ParseResult</code>类似,既能索引,也可以序列访问.</p><h3 id="urlunsplit"><a href="#urlunsplit" class="headerlink" title="urlunsplit"></a>urlunsplit</h3><p>和<code>urlunparse</code>类似,使用长度为5的可迭代对象.</p><h3 id="urljoin"><a href="#urljoin" class="headerlink" title="urljoin"></a>urljoin</h3><p>该方法需要两个参数,一个是<code>base_url</code>,一个是待修改的链接.该方法会分析<code>base_url</code>中的<code>scheme</code>,<code>netloc</code>和<code>path</code>.如果待修改的链接不含这三个部分中的一个,则补充上去.</p><h3 id="urlencode"><a href="#urlencode" class="headerlink" title="urlencode"></a>urlencode</h3><p>这个方法在<code>GET</code>方法中特别实用</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> urllib<span class="token punctuation">.</span>parse <span class="token keyword">import</span> urlencodequery <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token string">'tn'</span><span class="token punctuation">:</span><span class="token string">'monline_3_dg'</span><span class="token punctuation">,</span>    <span class="token string">'ie'</span><span class="token punctuation">:</span><span class="token string">'utf-8'</span><span class="token punctuation">,</span>    <span class="token string">'wd'</span><span class="token punctuation">:</span><span class="token string">'python'</span><span class="token punctuation">&#125;</span>base_url <span class="token operator">=</span> <span class="token string">'https://www.baidu.com?'</span>url <span class="token operator">=</span> base_url <span class="token operator">+</span> urlencode<span class="token punctuation">(</span>query<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span> <span class="token comment">## https://www.baidu.com?tn=monline_3_dg&amp;ie=utf-8&amp;wd=python</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其作用就是把字典参数链接在url后面</p><h3 id="parse-qs"><a href="#parse-qs" class="headerlink" title="parse_qs"></a>parse_qs</h3><p>反序列化方法,将<code>query</code>参数返回为字典</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> urllib<span class="token punctuation">.</span>parse <span class="token keyword">import</span> parse_qsquery <span class="token operator">=</span> <span class="token string">"tn=monline_3_dg&amp;ie=utf-8&amp;wd=python"</span><span class="token keyword">print</span><span class="token punctuation">(</span>parse_qs<span class="token punctuation">(</span>query<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">## query = &#123;</span>                       <span class="token comment">##    'tn':'monline_3_dg',</span>                       <span class="token comment">##    'ie':'utf-8',</span>                       <span class="token comment">##    'wd':'python'</span>                       <span class="token comment">## &#125; </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="parse-qsl"><a href="#parse-qsl" class="headerlink" title="parse_qsl"></a>parse_qsl</h3><p>将参数转化为元组组成的列表</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> urllib<span class="token punctuation">.</span>parse <span class="token keyword">import</span> parse_qslquery <span class="token operator">=</span> <span class="token string">"tn=monline_3_dg&amp;ie=utf-8&amp;wd=python"</span><span class="token keyword">print</span><span class="token punctuation">(</span>parse_qsl<span class="token punctuation">(</span>query<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">## [('tn','monline_3_dg'),('ie','utf-8'),('wd','python')]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="quote"><a href="#quote" class="headerlink" title="quote"></a>quote</h3><p>将内容转化为<code>URL</code>编码格式.如果<code>URL</code>有中文参数,有可能乱码,所以需要<code>quote</code>将其转化为<code> URL</code>编码</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> url<span class="token punctuation">.</span>parse <span class="token keyword">import</span> quotekeyword <span class="token operator">=</span> <span class="token string">"爬虫"</span>url <span class="token operator">=</span> <span class="token string">'https://www.baidu.com/s?wd='</span> <span class="token operator">+</span> quote<span class="token punctuation">(</span>keyword<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="unquote"><a href="#unquote" class="headerlink" title="unquote"></a>unquote</h3><p>将<code>URL</code>编码转成中文</p><h2 id="分析Robot协议"><a href="#分析Robot协议" class="headerlink" title="分析Robot协议"></a>分析Robot协议</h2><p><code>Robot</code>协议也叫机器人协议,全名网络爬虫排除标准(Robot Exclusion Protocal),用来告诉爬虫那些网页可以抓取,那些不行.通常命名为<code>robot.txt</code>,放在网站根目录.</br><br>爬虫在实际爬取时,会先检查是否存在’robot.txt’,如果有则遵从,没有的话就随意爬取.<br>下面是一个<code>robot.txt</code>的实例</p><pre class="line-numbers language-none"><code class="language-none">User-Agent: * &#x2F;对所有爬虫生效Disallow: &#x2F; #不允许爬取任何页面Allow: &#x2F;public&#x2F; #只能爬取public<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="robotparser"><a href="#robotparser" class="headerlink" title="robotparser"></a>robotparser</h3><p>这个模块用于解析<code>robot.txt</code>文件,来判断是由有权利爬取这个网页.</p><pre class="line-numbers language-none"><code class="language-none">urllib.robotparser.RobotFileParser(url &#x3D; &#39;&#39;) ## 可以不设置url,之后用set_url添加<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以下是<code>RobotFileParset</code>常用方法</p><ul><li><strong>set_url</strong>:设置<code>robot.txt</code>文件链接.</li><li><strong>read</strong>:读取文件并进行分析.这个方法包含读取和分析,所以一定要使用.</li><li><strong>parse</strong>:解析文件,传入其中的参数是文件中某些行的内容.</li><li><strong>can_fetch</strong>:需要两个参数,一个是<code>User-Agent</code>,一个是<code>URL</code>.判断是否能爬取.</li><li><strong>mtime</strong>:返回上次抓取分析文件的时间,如果长时间爬取的话就需要获取最新的<code>robot.txt</code>文件来判断自己爬取的合法性.</li><li><strong>modified</strong>:将当前时间设置为上次抓取分析文件的时间,在长时间爬取中很有用.</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一节主要是<code>urllib</code>的使用,使用略显复杂,后面的<code>requesets</code>模块更加方便,但是对于自定义爬虫这很有用.<br>爬取逻辑分析:<br>判断是否需要验证和代理 -&gt; 根据情况建立HTTPBasicAuthHandler(PasswordMgrWithDefaultRealm)或者ProxyHandler(字典) -&gt; 根据Handler建立opener -&gt; 爬取网页,同时记得捕获异常,根据异常修改爬虫. -&gt;如果需要修改cookie,使用HTTPCookieProcessor(CookieJar类).</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> spider </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
