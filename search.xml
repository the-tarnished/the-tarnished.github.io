<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>多元分析</title>
      <link href="/2022/01/29/%E5%A4%9A%E5%85%83%E5%88%86%E6%9E%90/"/>
      <url>/2022/01/29/%E5%A4%9A%E5%85%83%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="多元分析"><a href="#多元分析" class="headerlink" title="多元分析"></a>多元分析</h1><h2 id="聚类分析"><a href="#聚类分析" class="headerlink" title="聚类分析"></a>聚类分析</h2><p>聚类分析是对多个样本或者变量进行定量<strong>分类</strong>的一种方法.对样本进行分类叫做<strong>Q型聚类分析</strong>,对变量进行分类叫做<strong>R型聚类分析</strong>.</p><p>Q型聚类分析主要针对样本,是综合利用多个变量信息进行分类.R型聚类分析是分析的变量之间的亲疏关系.</p><h3 id="Q型聚类分析"><a href="#Q型聚类分析" class="headerlink" title="Q型聚类分析"></a>Q型聚类分析</h3><p>对一群待分类的样本有n个变量描述,所以每一个样本可以堪称$R^n$空间中的一个点,每个样本之间的亲疏关系可以通过样本点间距离进行度量.</p><p>在聚类分析中,对于定量变量,最常用的就是<strong>闵氏距离</strong>，即<br>$$d_q(x,y)=[∑_{k=1}^n∣x_k−y_k∣^q]^{\frac1q},q&gt;0$$<br>以下是当q取特定值时的距离:</p><ul><li>绝对值距离:$d_1(x,y) = [∑_{k=1}^n∣x_k−y_k∣]$</li><li>欧几里得距离: $d_2(x,y)=[∑_{k=1}^n∣x_k−y_k∣^2]^{\frac12}$</li><li>切比雪夫距离: $d_{\infty}(x,y) = max|x_k-y_k|$<br>为了克服闵氏距离对于量纲的一致性要求的缺点,可以使用马氏距离:<br>$$d(x,y)=\sqrt{(x-y)^T\Sigma^T(x-y)}$$<br>其中$\Sigma$时Z的协方差矩阵.</li></ul><p>类的相似度度量有如下方法:</p><ul><li>最短距离:顾名思义</li><li>最长距离:顾名思义</li><li>重心:重心之间的距离</li><li>类平均:$D(G_1,G_2)=\frac1{n_1n_2}∑_{x_i∈G_1}∑_{x_j∈G_2}d(x_i,x_j)$,n1,n2为点的个数</li><li>离差平方和</li></ul><p>对于这一类聚类分析,代码思路</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> scipy<span class="token punctuation">.</span>cluster<span class="token punctuation">.</span>hierarchy <span class="token keyword">import</span> linkage<span class="token keyword">from</span> scipy<span class="token punctuation">.</span>spatial<span class="token punctuation">.</span>distance <span class="token keyword">import</span> pdist<span class="token punctuation">,</span>squareformy <span class="token operator">=</span> pdist<span class="token punctuation">(</span>a<span class="token punctuation">,</span>method <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">)</span> <span class="token comment">##a是各个点坐标,method选择距离计算方法</span>yc <span class="token operator">=</span> squareform<span class="token punctuation">(</span>y<span class="token punctuation">)</span>       <span class="token comment">##将距离转换为距离对称方阵</span>z <span class="token operator">=</span> linkage<span class="token punctuation">(</span>y<span class="token punctuation">,</span>method <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">)</span> <span class="token comment">##y是各点距离,method参数选择,返回聚类</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="R型聚类分析"><a href="#R型聚类分析" class="headerlink" title="R型聚类分析"></a>R型聚类分析</h3><p>对于R型聚类分析的变量相似性度量,有两种相似性度量:</p><ul><li>相关系数:用两变量$x_j$与$x_k$的样本相关系数作为他们的相似性度量</li><li>夹角余弦:用两变量$x_j$与$x_k$的样本夹角余弦作为他们的相似性度量</li></ul><p>对于R型聚类分析的类与类的相似性度量,与Q型类似,对于实际分析的时候,先用R型聚类法从所有变量中选取几个有代表性的变量(剔除相关性较强的变量),再对选取变量进行Q型聚类分析.</p><h3 id="动态聚类法"><a href="#动态聚类法" class="headerlink" title="动态聚类法"></a>动态聚类法</h3><p>K-mean算法,见<a href="../Scipy%E5%AD%A6%E4%B9%A0">Scipy学习</a></p><h2 id="主成分分析"><a href="#主成分分析" class="headerlink" title="主成分分析"></a>主成分分析</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>主成分分析将许多相关性很高的变量转化成彼此相互独立或不相关的变量，并用以解释资料的综合性指标。<br>设$X_1,…,X_p$表示p个随机变量,$x_1,…,x_p$表示样本观测值,若能找到$c_1,…,c_p,并且\Sigma_{i=1}^pc_i^2 = 1$使得$D(\Sigma_{i=1}^p(c_iX_i))$最大,由于方差反应的是数据差异程度,也就表明我们找到了这p个变量的最不相关的因素,这个解是p维空间的一个单位向量,代表一个主成分方向.</p><p>为了代表原来的p个向量,需要求多个主成分方向,并且这几个主成分方向向量正交/协方差为0.可以理解为主成分方向是原来p个变量的线性组合,通过找矩阵秩的方式降低了变量个数.之后,再通过选择特征值大的特征向量来笼统代表p个向量(特征值大说明这个因素对整体的贡献高,特征值小的变量对整体贡献值小)</p><h3 id="特征值因子筛选"><a href="#特征值因子筛选" class="headerlink" title="特征值因子筛选"></a>特征值因子筛选</h3><p>设有p个指标变量$x_1,…,x_p$,在第i此的取值为$a_{i1},…,a_{ip}$,其矩阵形式为<br>$$<br>A = \begin{bmatrix}<br>a_{11}&amp;\ldots&amp;a_{1p}\\<br>\vdots&amp;\ddots&amp;\vdots\\<br>a_{n1}&amp;\ldots&amp;a_{np}\\<br>\end{bmatrix}<br>$$<br>称A为设计阵,$A^TA$为方阵,取前面的特征值使所取特征值所占比重超过85%，每个特征值所对应的特征向量即为一个主成分方向。</p><h3 id="主成分回归分析"><a href="#主成分回归分析" class="headerlink" title="主成分回归分析"></a>主成分回归分析</h3><p>首先需要对样本值中心标准化,设i次观测的样本j的值为$a_{ij}$,中心标准化之后的值为$a_{ij}^{‘}$</p><p>$$a_{ij}^{‘} = \frac{a_{ij} - u_j}{S_j}$$<br>$u_j$为样本j的均值,$S_j$为样本j的方差,令$A = {a_ij}$,则$(A^TA)X = X^T\Sigma$</p><p>在等到样本矩阵之后,如果样本数据数量级差距很大,则计算相关系数矩阵,反之,则计算协方差矩阵.</p><p>之后,根据计算出来的关系矩阵计算特征值(特征值是白化数据的方差,因为中心标准化之后,方差为1,特征值是拉伸倍数)和特征向量(是白化数据的旋转变换矩阵).选取较大特征值对应的特征向量(相当于降维,降低离散点的影响)组成,求出转移矩阵P,和原始数据X相乘得到新的数据Y. Y=PX. </p><h2 id="因子分析"><a href="#因子分析" class="headerlink" title="因子分析"></a>因子分析</h2><p>因子分析通过研究众多变量之间的内部依赖关系，探求观测数据中的基本结构，用少数几个假想变量来表示其基本数据结构。这几个假想变量能够反映原来众多变量的主要信息，原始的变量时可观测的显在变量，而假想变量是不可观测的潜在变量，称为因子。</p><p>因子分析和主成分分析类似,都是降维方式.</p><p>在开始分析之前需要进行KMO检验(大于0.7)和bartlett球形度检验(小于0.05),</p><h3 id="因子分析模型"><a href="#因子分析模型" class="headerlink" title="因子分析模型"></a>因子分析模型</h3><p>设P个变量$X_i$可以表示为<br>$$X_i = u_i + a_{i1}F_1 + … + a_{im}F_m + \epsilon_i, m \leq p(降维所以一定m不能比p大)$$<br>或矩阵表示<br>$$X_i - u_i = \Lambda F + \epsilon$$<br>F为公共因子,$\Lambda$为载荷因子,$\epsilon$为特殊因子,且<br>$$E(F) = 0, E(\epsilon) = 0,Cov(F) = I_m,D(\epsilon) = Cov(\epsilon) = diag(\sigma_1^2,…,\sigma_p^2)$$<br>$$Cov(X-u) = \Lambda{Cov(F)}\Lambda^T+Cov(\epsilon)= \Lambda\Lambda^T + diag(\sigma_1^2,…,\sigma_p^2)$$</p><h3 id="因子载荷矩阵估计方法"><a href="#因子载荷矩阵估计方法" class="headerlink" title="因子载荷矩阵估计方法"></a>因子载荷矩阵估计方法</h3><p>设$\lambda_1 \geq \lambda_2…\geq \lambda_p$为样本系数矩阵R特征值,$\eta_1,…,\eta_p$为对应的特征向量,取较大的m个特征值以及其特征向量组成因子载荷矩阵$\Lambda$,<br>$$\Lambda = [\sqrt{\lambda_1}\eta_1,…,\sqrt{\lambda_m}\eta_m]$$<br>(有点类似主成分分析)<br>特殊因子的方差用$R-\Lambda\Lambda^T$的对角元来估计,为<br>$$\sigma^2_i = 1 - \Sigma_{(j = 1)}^m{a_{ij}^2}$$</p><h3 id="因子旋转"><a href="#因子旋转" class="headerlink" title="因子旋转"></a>因子旋转</h3><p>建立因子分析模型的重要目的是为了知道每个公共因子的含义.因为载荷因子矩阵不唯一,为使后期分析工作方便,需要对载荷因子矩阵进行旋转,使得载荷因子矩阵的各个因子之间方差最大,类似主成分分析法找主成分方向.</p><p>从简化因子载荷矩阵的每一列出发，使和每个因子有关的载荷的平方的方差最大。当只有少数几个变量在某个因子上有较高的载荷时，对因子的解释最简单。方差最大的直观意义是希望通过因子旋转后，使每个因子上的载荷尽量拉开距离，一部分载荷趋于 ±1，另一部分趋于0。(这一部分可以直接交给第三方库去做)</p><h3 id="因子得分"><a href="#因子得分" class="headerlink" title="因子得分"></a>因子得分</h3><p>因子得分也就是公共因子的估计也很必要.因子得分则需要把公共因子表示为原变量的线性组合，因子得分函数：<br>$F_j=c_j+b_{j1}X_1+⋯+b_{jp}X_p ,j=1,2,⋯,m$<br>若将原始数据中心标准化,则<br>$\hat{F} = X_0R^{-1}\Lambda$</p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数理知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>灰色系统理论及其应用</title>
      <link href="/2022/01/28/%E7%81%B0%E8%89%B2%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
      <url>/2022/01/28/%E7%81%B0%E8%89%B2%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="灰色系统介绍"><a href="#灰色系统介绍" class="headerlink" title="灰色系统介绍"></a>灰色系统介绍</h2><p>灰色系统本质就是系统内部信息部分已知而部分信息未知的系统.如果所有信息都已知,如力和加速度的关系,那么这就是白色系统,反之则成为黑色系统.</p><p>灰色系统提出了一个和回归分析不同的分析方法-关联度分析方法,即根据因素之间发展态势的相似或相异程度来衡量因素间的关联程度.</p><h2 id="关联分析"><a href="#关联分析" class="headerlink" title="关联分析"></a>关联分析</h2><h3 id="关联系数的定义"><a href="#关联系数的定义" class="headerlink" title="关联系数的定义"></a>关联系数的定义</h3><p>$选取参考数列x_0 = {x_0(k)|k = 1,2,…,n}其中k表示时刻.假设有m个比较数列x_i={x_i(k)|k = 1,2,…,n}(i=1,2,…,m)$</p><p>$则称\xi_{i}(k) = \frac{\min_{s}min_{t}\left|x_{0}(t), - x_{s}(t)\right|,+\rho , \max_{s}max_{t} \left | x_{0}(t), - x_{s}(t) \right | }{\left | x_{0}(k), - x_{i}(k) \right | , + \rho , \max_{s}max_{t} \left | x_{0}(t), - x_{s}(t) \right | } \cdots \left ( 1 \right )$</p><p>$为比较数列x_{i} 对参考数列x_{0} 在k时刻的关联系数，  其中 \rho \in \left [ 0, 1 \right ] 为分辨系数；$</p><p>称（1）式中$\min_{s}min_{t}\left|x_{0}(t), - x_{s}(t)\right|,\max_{s}max_{t}\left|x_{0}(t), - x_{s}(t) \right|$分别为两级最小差，两级最大差。</p><h3 id="关联度的定义"><a href="#关联度的定义" class="headerlink" title="关联度的定义"></a>关联度的定义</h3><p>称<br>$$r_i =\frac{1}{n}\Sigma\xi_i(k)$$<br>为数列$x_i$对参考数列$x_0$的关联度.</p><p>易得关联度是各个时刻的关联系数集中的一个平均值</p><h2 id="优势分析"><a href="#优势分析" class="headerlink" title="优势分析"></a>优势分析</h2><p>假设有m个参考数列,记为$y_1,y_2,…,y_m$.有l个比较数列,记为$x_1,…,x_l$.显然每一个参考数列对l个比较数列都有l个关联度.令$r_{ij}$表示比较数列$x_j$对$y_i$的关联度,可构造关联度矩阵$R=(r_{ij})_{m*l}$若某一列元素大于其他列元素的时候称此列对应的比较数列(子因素)为优势子因素;若某一行元素大于其他行元素,则称此行对应的参考数列(母元素)为优势母元素.</p><h2 id="生成数"><a href="#生成数" class="headerlink" title="生成数"></a>生成数</h2><h3 id="累加生成"><a href="#累加生成" class="headerlink" title="累加生成"></a>累加生成</h3><p>把数列 x 各时刻数据依次累加的过程叫做<strong>累加过程</strong>，记作 <strong>AGO</strong>，累加所得的新数列，叫做<strong>累加生成数列</strong>。具体地，设原始数列为<br>$$x^{(0)} = (x^{(0)}(1),…,x^{(0)}(n)),累加生成数列记为x^{(1)} = (x^{(1)}(1),…,x^{(1)}(n)),且x^{(0)}与x^{(1)}满足 $$<br>$$x^{(1)}(k) = \Sigma^k_{i=\alpha}x^{(0)}(i),k = \alpha,…,n$$<br>$$其中\alpha\leq n为正整数.上述累加过程当1&lt;\alpha \leq k时称为去首累加成,当\alpha = 1时称为一般累加成.$$<br>$$当\alpha = 1时, 式子x^{(1)}中的上标(1)表示一次累加生成,记作1-AGO.再做一次累加生成可得二次累加生成,所以易得$$<br>$$x^{(r)}(k) = \Sigma^k_{i=1}x^{(r-1)}(i),k = 1,…,n$$</p><p>一般的,对于实际情况为非负的数列,累加生成可以使得生成数列为递增数列,对于有负数的数列可以使用移轴的方式再累加生成.</p><h3 id="累减生成"><a href="#累减生成" class="headerlink" title="累减生成"></a>累减生成</h3><p>对累加生成的还原就是累减生成<br>$$x^{(r-1)}(k) = x^{(r)}(k)-x^{(r)}(k-1),k = 1,…,n$$</p><h3 id="均值生成"><a href="#均值生成" class="headerlink" title="均值生成"></a>均值生成</h3><h4 id="邻值生成数"><a href="#邻值生成数" class="headerlink" title="邻值生成数"></a>邻值生成数</h4><p>设原始数列为$x^{(0)} = (x^{(0)}(1),…,x^{(0)}(n))$,则称$x^{(0)}(k-1)$与$x^{(0)}(k1)$为数列$x^{(0)}$的一对邻值,$x^{(0)}(k-1)$称为前值,$x^{(0)}(k1)$称为后值.</p><p>对数常数$\alpha \in [0,1]$,则称<br>$$z^(0)(k) = \alpha x^{(0)}(k)+(1-\alpha) x^{(0)}(k-1)$$<br>为由数列$x^{(0)}$的邻值在生成系数$\alpha$下的邻值生成数.</p><h4 id="等权邻值生成数"><a href="#等权邻值生成数" class="headerlink" title="等权邻值生成数"></a>等权邻值生成数</h4><p>当$\alpha=0.5$时,$z^(0)(k)$称为等权邻值生成数</p><h4 id="非邻值生成数"><a href="#非邻值生成数" class="headerlink" title="非邻值生成数"></a>非邻值生成数</h4><p>类似的,可定义非邻值生成数:<br>$$z^(0)(k) = \alpha x^{(0)}(k+1)+(1-\alpha) x^{(0)}(k-1)$$</p><h2 id="灰色模型"><a href="#灰色模型" class="headerlink" title="灰色模型"></a>灰色模型</h2><h3 id="GM-1-1-模型的定义"><a href="#GM-1-1-模型的定义" class="headerlink" title="GM(1,1)模型的定义"></a>GM(1,1)模型的定义</h3><p><strong>灰导数</strong><br>$$x^{(0)} = (x^{(0)}(1),…,x^{(0)}(n)),x^{(0)}的AGO生成数列为x^{(1)} = (x^{(1)}(1),…,x^{(1)}(n)),其中x^{(1)}(k) = \Sigma^k_{i=1}x^{(0)}(i)$$<br>$则定义x^{(1)}的灰导数为$<br>$$d(k) = x^{(0)}(k) =x^{(1)}(k) -x^{(1)}(k-1)$$<br><strong>GM(1,1)的灰微分方程模型</strong><br>$$令x^{(1)}为数列x^{(1)}的紧邻均值数列,即z^(1)(k) = 0.5 x^{(1)}(k)+0.5 x^{(1)}(k-1),于是定义GM(1,1)的灰微分方程模型为$$</p><p>$$d(k)+az^{(1)}(k) = b$$</p><p>其中$x^{(0)}(k)$称为灰导数,a称为发展系数,$z^{(1)}(k)$称为白化背景值,b称为灰作用量.</p><h3 id="参数向量估计"><a href="#参数向量估计" class="headerlink" title="参数向量估计"></a>参数向量估计</h3><p>将k=2,3,…,n带入灰微分方程<br>$$\begin{cases}<br>d(2)+az^{(1)}(2) = x^{(0)}(2)+az^{(1)}(2) = b\\<br>d(3)+az^{(1)}(3) = x^{(0)}(3)+az^{(1)}(3) = b\\<br>…….\\<br>d(n)+az^{(1)}(n) = x^{(0)}(n)+az^{(1)}(n) = b\\<br>\end{cases}<br>$$</p><p>$$令Y=(x^{(0)}(2),x^{(0)}(3),…,x^{(0)}(n))^T,u=(a,b)^T,<br>B =\begin{bmatrix}<br>-z^{(1)}(2)&amp;1\\<br>-z^{(1)}(3)&amp;1\\<br>{\vdots}&amp;{\vdots}\\<br>-z^{(1)}(n)&amp;1\\<br>\end{bmatrix}<br>$$<br>称Y为数据向量,B为数据矩阵,u为参数向量,GM(1,1)模型可以表示为Y = Bu</p><p>由最小二乘法可以求得<br>$$\hat{u} = (\hat{a},\hat{b})^T = (B^TB)^{-1}B^TY$$</p><h3 id="GM-1-1-白化型"><a href="#GM-1-1-白化型" class="headerlink" title="GM(1,1)白化型"></a>GM(1,1)白化型</h3><p>对于GM(1,1)的灰微分方程,如果将k视为连续变量t,则数列$x^{(0)}$可视作t的函数,记为 $x^{(0)} = $x^{(0)}$(t)$ ,则 $x^{(1)}$ 是 $x^{(0)}$ 的积分,于是可得白微分方程为<br>$$\frac{dx^{(1)}}{dt}+ax^{(1)} = b$$</p><h3 id="GM-1-N-模型定义"><a href="#GM-1-N-模型定义" class="headerlink" title="GM(1,N)模型定义"></a>GM(1,N)模型定义</h3><p><code>GM(1,1)</code>即表示模型是 1 阶的，且只含 1 个变量的灰色模型。而<code>GM(1, N)</code> 即表示模型是 1 阶的，包含有 N 个变量的灰色模型。<br>设系统由N个行为因子,其原始数列为$x_i^{(0)} = (x_i^{(0)}(1),…,x_i^{(0)}(n)),i=1,…,N$</p><p>其一阶累加生成数列为$x_i^{(1)} = (x_i^{(1)}(1),…,x_i^{(1)}(n)),i=1,…,N,x_i^{(1)}(k)=\Sigma ^k_{j=1}x_i^{(0)}(j)$</p><p>取$x_i^{(1)}$的均值数列为$z_i^{(1)}(k) = 0.5x_i^{(1)}(k)+0.5x_i^{(1)}(k-1)$</p><p>则均值数列$z_i^{(1)} = (z_i^{(1)}(1),…,z_i^{(1)}(n))$</p><p>于是可得GM(1,N)的灰微分方程为<br>$$x_i^{(0)}(k) + az_i^{(1)} = \Sigma^N_{(j\neq{i})}b_jx_j^{(1)}(k)$$<br>其中$x_i^{(0)}(k)$为灰导数,$z_i^{(1)}$为背景值,a,$b_j$为参数.</p><p>引入向量矩阵符号,令i=1得<br>$$Y = [x_1^{(0)}(1),..,x_1^{(0)}(n)]^T,u=[a,b_2,…,b_N]^T$$<br>$$B = \begin{bmatrix}<br>-z_1^{(1)}(2) &amp;x_2^{(1)}(2) &amp;{\cdots} &amp;x_N^{(1)}(2)\\<br>{\vdots}&amp;{\vdots}&amp;{\vdots}&amp;{\vdots}\\<br>-z_1^{(1)}(n) &amp;x_2^{(1)}(n) &amp;{\cdots} &amp;x_N^{(1)}(n)\\<br>\end{bmatrix}$$<br>则GM(1,N)的灰微分方程为<br>$$Y=Bu$$</p><h3 id="GM-1-N-模型的参数估计"><a href="#GM-1-N-模型的参数估计" class="headerlink" title="GM(1,N)模型的参数估计"></a>GM(1,N)模型的参数估计</h3><p>如果$(B^TB)^{-1}$存在,则$\hat{u} = (B^TB)^{-1}B^TY$</p><p>如果$(B^TB)^{-1}$不存在,比如n-1 &lt;br N,那么$\hat{u}$不能通过上式确定,但注意到$\hat{u}$是对各子因素对主因素影响大小的反映,所以通过引入加权矩阵 $W = diag(w_1,…,w_N)$,对各因素进行调节,对于未来发展减弱趋势的因素赋予较大权值,对于未来发展增强趋势的因素赋予较小权值,则<br>$$\hat{u} = W^{-1}B^T(B^{-1}B^T)^{-1}Y$$</p><h3 id="GM-1-N-白化型"><a href="#GM-1-N-白化型" class="headerlink" title="GM(1,N)白化型"></a>GM(1,N)白化型</h3><p>$$\frac{dx_1^{(1)}}{dt} + ax_1^{(1)}(t) = \Sigma^N_{(j\neq{1})}b_jx_j^{(1)}(k)$$</p><h2 id="Verhulst模型"><a href="#Verhulst模型" class="headerlink" title="Verhulst模型"></a>Verhulst模型</h2><p>GM(1,1)模型适用于具有较强指数规律的序列，只能描述单调的变化过程。故对于非单调的摆动发展序列或具有饱和状态的 S 形序列， Verhulst 模型，GM(2,1),DGM(2,1)模型等更适用。</p><p>Verhulst 模型主要用来描述具有饱和状态的过程， 即 S 形过程，常用于人口预测、生物生长、繁殖预测及产品经济寿命预测等。</p><h3 id="Verhulst模型简介"><a href="#Verhulst模型简介" class="headerlink" title="Verhulst模型简介"></a>Verhulst模型简介</h3><p>设$x^{(0)}$为原始数据序列<br>$$x^{(0)} = (x^{(0)}(1),…,x^{(0)}(n))$$<br>其一阶累加生成序列为<br>$$x^{(1)} = (x^{(1)}(1),…,x^{(1)}(n))$$<br>$z^{(1)}$为$x^{(1)}$的紧邻均值生成序列<br>$$z^{(1)} = (z^{(1)}(1),…,z^{(1)}(n))$$<br>则称<br>$$x^{(0)} + az^{(1)} = b(z^{(1)})^2$$<br>为Verhulst灰色模型,a和b为参数.<br>其解为<br>$$\hat{x}^{(1)}(k+1) = \frac{ax^{(1)}(1)}{bx^{(1)}(1)+(a-bx^{(1)}(1))e^{ak}}$$<br>可通过累减还原为$\hat{x}^{(0)}$ </p><p>称<br>$$\frac{dx^{(1)}}{dt}+ax^{(1)} = b(x^{(1)})^2$$<br>为Verhulst白化方程,a和b为参数.<br>其解为<br>$$x^{(1)}(t) = \frac{ax^{(1)}(1)}{bx^{(1)}(1)+(a-bx^{(1)}(1))e^{ak}}$$<br>$$B = \begin{bmatrix}<br>-z^{(1)}(2)&amp;(z^{(1)}(2))^2\\<br>(\vdots)&amp;(\vdots)\\<br>-z^{(1)}(n)&amp;(z^{(1)}(n))^2\\<br>\end{bmatrix},<br>Y = \begin{bmatrix}<br>x^{(0)}(2)\\<br>\vdots\\<br>x^{(0)}(n)\\<br>\end{bmatrix}$$<br>参数估计值为<br>$$\hat\alpha = (B^TB)^{(-1)}B^TY$$</p><h3 id="模型检验"><a href="#模型检验" class="headerlink" title="模型检验"></a>模型检验</h3><ul><li>残差合格检验</li><li>关联度合格检验</li><li>均方差比合格检验</li><li>小误差概率合格检验</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数理知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Geatpy学习</title>
      <link href="/2022/01/22/Geatpy%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/01/22/Geatpy%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="geatpy"><a href="#geatpy" class="headerlink" title="geatpy"></a>geatpy</h1><p>address:<a href="http://geatpy.com/index.php/home/">http://geatpy.com/index.php/home/</a></p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模,Geatpy,Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matplotlib学习</title>
      <link href="/2022/01/22/Matplotlib%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/01/22/Matplotlib%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h1><p>address:<a href="https://www.matplotlib.org.cn/tutorials/#%E5%BA%8F%E8%A8%80">https://www.matplotlib.org.cn/tutorials/#%E5%BA%8F%E8%A8%80</a></p><h2 id="基本绘图"><a href="#基本绘图" class="headerlink" title="基本绘图"></a>基本绘图</h2><p>提供一对相同长度的数组,然后使用plot()绘制曲线.</p><p>如果想绘制特别的曲线,有以下修饰</p><table><thead><tr><th align="left">颜色</th><th align="left">描述</th><th align="left">标记</th><th align="left">描述</th><th align="left">线条</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">‘b’</td><td align="left">蓝色</td><td align="left">‘.’</td><td align="left">点标记</td><td align="left">‘-‘</td><td align="left">实线</td></tr><tr><td align="left">‘g’</td><td align="left">绿色</td><td align="left">‘o’</td><td align="left">圆圈标记</td><td align="left">‘–’</td><td align="left">虚线</td></tr><tr><td align="left">‘r’</td><td align="left">红色</td><td align="left">‘x’</td><td align="left">x标记</td><td align="left">‘-.’</td><td align="left">点划线</td></tr><tr><td align="left">‘c’</td><td align="left">青色</td><td align="left">‘D’</td><td align="left">钻石标记</td><td align="left">‘:’</td><td align="left">虚线</td></tr><tr><td align="left">‘m’</td><td align="left">品红色</td><td align="left">‘H’</td><td align="left">六角标记</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">‘y’</td><td align="left">黄色</td><td align="left">‘s’</td><td align="left">正方形标记</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">‘k’</td><td align="left">黑色</td><td align="left">‘+’</td><td align="left">加号标记</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">‘w’</td><td align="left">白色</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><p>如果想在同一幅图里面绘制多条曲线,只需使用多条plot指令即可.如果您想清除图像，直接在程序末尾调用 clf() 方法即可。</p><h2 id="figure对象"><a href="#figure对象" class="headerlink" title="figure对象"></a>figure对象</h2><p>通过面向对象的思想,将图形封装为图形对象,就能更好的处理控制多个画布.Matplotlib 提供了<code>matplotlib.figure</code>图形类模块，它包含了创建图形对象的方法。通过调用 pyplot 模块中 figure() 函数来实例化 figure 对象。</p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">figsize</td><td align="left">指定画布的大小，(宽度,高度)，单位为英寸。</td></tr><tr><td align="left">dpi</td><td align="left">指定绘图对象的分辨率，即每英寸多少个像素，默认值为80。</td></tr><tr><td align="left">facecolor</td><td align="left">背景颜色。</td></tr><tr><td align="left">dgecolor</td><td align="left">边框颜色。</td></tr><tr><td align="left">frameon</td><td align="left">是否显示边框。</td></tr></tbody></table><p>创建画布的步骤如下;</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> plot <span class="token keyword">as</span> pltfig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">## 实例化figure对象</span>ax<span class="token operator">=</span>fig<span class="token punctuation">.</span>add_axes<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">## 添加axes域到画布,这样ax就是我们的画布了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>add_axes() 的参数值是一个序列，序列中的 4 个数字分别对应图形的左侧，底部，宽度，和高度，且每个数字必须介于 0 到 1 之间。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ax<span class="token punctuation">.</span>set_title<span class="token punctuation">(</span><span class="token string">"sine wave"</span><span class="token punctuation">)</span> <span class="token comment">##设置标题</span>ax<span class="token punctuation">.</span>set_xlabel<span class="token punctuation">(</span><span class="token string">'angle'</span><span class="token punctuation">)</span> <span class="token comment">##设置x轴标签</span>ax<span class="token punctuation">.</span>set_ylabel<span class="token punctuation">(</span><span class="token string">'sine'</span><span class="token punctuation">)</span> <span class="token comment">##设置y轴标签</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="axes类使用详解"><a href="#axes类使用详解" class="headerlink" title="axes类使用详解"></a>axes类使用详解</h2><p>Matplotlib 定义了一个 axes 类（轴域类），该类的对象被称为 axes 对象（即轴域对象），它指定了一个有数值范围限制的绘图区域。在一个给定的画布（figure）中可以包含多个 axes 对象，但是同一个 axes 对象只能在一个画布中使用。</p><p>也就是说一个figure里面能有多个axes对象,每个对象是一幅图,但是一个axes对象只能隶属一个figure画布.</p><p>通过调用 add_axes() 方法能够将 axes 对象添加到画布中，该方法用来生成一个 axes 轴域对象，对象的位置由参数rect决定。</p><p>rect 是位置参数，接受一个由 4 个元素组成的浮点数列表，形如 [left, bottom, width, height] ，它表示添加到画布中的矩形区域的左下角坐标(x, y)，以及宽度和高度。(每个参数都是相对于画布的分数,是相对距离)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ax<span class="token operator">=</span>fig<span class="token punctuation">.</span>add_axes<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0.1</span><span class="token punctuation">,</span><span class="token number">0.1</span><span class="token punctuation">,</span><span class="token number">0.8</span><span class="token punctuation">,</span><span class="token number">0.8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">##表示从画布10%开始画,高与宽是画布的80%</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="legend-绘制图例"><a href="#legend-绘制图例" class="headerlink" title="legend()绘制图例"></a>legend()绘制图例</h3><p>axes 类的 legend() 方法负责绘制画布中的图例，它需要三个参数</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ax<span class="token punctuation">.</span>legend<span class="token punctuation">(</span>handles<span class="token punctuation">,</span> labels<span class="token punctuation">,</span> loc<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>handles:是一个序列,包含了所有线的实例</li><li>labels:指定标签名称,也可以在plot的时候,直接命名label</li><li>loc:指定图例位置<blockquote><table><thead><tr><th align="left">位置</th><th align="left">字符串表示</th><th align="left">整数数字表示</th></tr></thead><tbody><tr><td align="left">自适应</td><td align="left">Best</td><td align="left">0</td></tr><tr><td align="left">右上方</td><td align="left">upper right</td><td align="left">1</td></tr><tr><td align="left">左上方</td><td align="left">upper left</td><td align="left">2</td></tr><tr><td align="left">左下</td><td align="left">lower left</td><td align="left">3</td></tr><tr><td align="left">右下</td><td align="left">lower right</td><td align="left">4</td></tr><tr><td align="left">右侧</td><td align="left">right</td><td align="left">5</td></tr><tr><td align="left">居中靠左</td><td align="left">center left</td><td align="left">6</td></tr><tr><td align="left">居中靠右</td><td align="left">center right</td><td align="left">7</td></tr><tr><td align="left">底部居中</td><td align="left">lower center</td><td align="left">8</td></tr><tr><td align="left">上部居中</td><td align="left">upper center</td><td align="left">9</td></tr><tr><td align="left">中部</td><td align="left">center</td><td align="left">10</td></tr></tbody></table></blockquote></li></ul><h3 id="axes-plot-方法"><a href="#axes-plot-方法" class="headerlink" title="axes.plot()方法"></a>axes.plot()方法</h3><p>这是axes的基本方法,将一个数组和另一个数组汇成线,其修饰符和plot方法类似</p><table><thead><tr><th align="left">颜色</th><th align="left">描述</th><th align="left">标记</th><th align="left">描述</th><th align="left">线条</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">‘b’</td><td align="left">蓝色</td><td align="left">‘.’</td><td align="left">点标记</td><td align="left">‘-‘</td><td align="left">实线</td></tr><tr><td align="left">‘g’</td><td align="left">绿色</td><td align="left">‘o’</td><td align="left">圆圈标记</td><td align="left">‘–’</td><td align="left">虚线</td></tr><tr><td align="left">‘r’</td><td align="left">红色</td><td align="left">‘x’</td><td align="left">x标记</td><td align="left">‘-.’</td><td align="left">点划线</td></tr><tr><td align="left">‘c’</td><td align="left">青色</td><td align="left">‘D’</td><td align="left">钻石标记</td><td align="left">‘:’</td><td align="left">虚线</td></tr><tr><td align="left">‘m’</td><td align="left">品红色</td><td align="left">‘H’</td><td align="left">六角标记</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">‘y’</td><td align="left">黄色</td><td align="left">‘s’</td><td align="left">正方形标记</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">‘k’</td><td align="left">黑色</td><td align="left">‘+’</td><td align="left">加号标记</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">‘w’</td><td align="left">白色</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><h3 id="axes-grid-设置网格格式"><a href="#axes-grid-设置网格格式" class="headerlink" title="axes.grid()设置网格格式"></a>axes.grid()设置网格格式</h3><p>rid() 方法可以开启或者关闭画布中的网格（即是否显示网格）以及网格的主/次刻度。除此之外，grid() 函数还可以设置网格的颜色、线型以及线宽等属性。网格在默认状态下是关闭的，通过调用上述函数，网格会被自动开启，如果只是想开启不带任何样式的网格，可以通过 grid(True) 来实现。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">grid<span class="token punctuation">(</span>color<span class="token punctuation">,</span> ls<span class="token punctuation">,</span> lw<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>color:网格线的颜色</li><li>ls:网格线的样式</li><li>lw:网格线的宽度<h3 id="设置坐标轴格式"><a href="#设置坐标轴格式" class="headerlink" title="设置坐标轴格式"></a>设置坐标轴格式</h3>有时候不同的函数关系,x和y的刻度不应该相同,所以需要通过scale属性设置.</li></ul><p>轴是连接刻度的线，也就是绘图区域的边界，在绘图区域（axes 对象）的顶部、底部、左侧和右侧都有一个边界线（轴）。通过指定轴的颜色和宽度，从而对进行显示格式设置，比如将所有轴的颜色设置为 None，那么它们都会成为隐藏状态，或者也可以给轴添加相应的颜色。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> pltfig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token punctuation">)</span>ax <span class="token operator">=</span> fig<span class="token punctuation">.</span>add_axes<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#为左侧轴，底部轴添加颜色</span>ax<span class="token punctuation">.</span>spines<span class="token punctuation">[</span><span class="token string">'bottom'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_color<span class="token punctuation">(</span><span class="token string">'blue'</span><span class="token punctuation">)</span>ax<span class="token punctuation">.</span>spines<span class="token punctuation">[</span><span class="token string">'left'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_color<span class="token punctuation">(</span><span class="token string">'red'</span><span class="token punctuation">)</span>ax<span class="token punctuation">.</span>spines<span class="token punctuation">[</span><span class="token string">'left'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_linewidth<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment">#将侧轴、顶部轴设置为None</span>ax<span class="token punctuation">.</span>spines<span class="token punctuation">[</span><span class="token string">'right'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_color<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">)</span>ax<span class="token punctuation">.</span>spines<span class="token punctuation">[</span><span class="token string">'top'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_color<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">)</span>ax<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="设置坐标轴范围"><a href="#设置坐标轴范围" class="headerlink" title="设置坐标轴范围"></a>设置坐标轴范围</h3><p>Matplotlib 可以根据自变量与因变量的取值范围，自动设置 x 轴与 y 轴的数值大小。当然，您也可以用自定义的方式，通过 set_xlim() 和 set_ylim() 对 x、y 轴的数值范围进行设置。当对 3D 图像进行设置的时，会增加一个 z 轴，此时使用 set_zlim() 可以对 z 轴进行设置。</p><p>示例如下:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> npy<span class="token comment">##生成画布</span>fig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token punctuation">)</span>ax1 <span class="token operator">=</span> fig<span class="token punctuation">.</span>add_axes<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0.5</span><span class="token punctuation">,</span><span class="token number">0.5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">##自变量生成</span>x <span class="token operator">=</span> npy<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">*</span>npy<span class="token punctuation">.</span>pi<span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token comment">##绘图区域生成</span>ax1<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span>npy<span class="token punctuation">.</span>cos<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">'r--'</span><span class="token punctuation">,</span>label<span class="token operator">=</span><span class="token string">'cos'</span><span class="token punctuation">)</span>ax1<span class="token punctuation">.</span>legend<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">##设置y轴取值范围</span>ax1<span class="token punctuation">.</span>set_ylim<span class="token punctuation">(</span><span class="token operator">-</span>npy<span class="token punctuation">.</span>pi<span class="token punctuation">,</span>npy<span class="token punctuation">.</span>pi<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="设置刻度和刻度标签"><a href="#设置刻度和刻度标签" class="headerlink" title="设置刻度和刻度标签"></a>设置刻度和刻度标签</h3><p>如果需要将刻度设置为“英文数字形式”或者“大写阿拉伯数字”，自带的刻度就需要自己重新设置。</p><p>xticks() 和 yticks() 函数接受一个列表对象作为参数，列表中的元素表示对应数轴上要显示的刻度。如:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ax<span class="token punctuation">.</span>set_xticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以分别通过 set_xticklabels() 和 set_yticklabels() 函数设置与刻度线相对应的刻度标签。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> npy<span class="token comment">##生成画布对象</span>fig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#添加绘图区域</span>ax <span class="token operator">=</span> fig<span class="token punctuation">.</span>add_axes<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token number">0.8</span><span class="token punctuation">,</span> <span class="token number">0.8</span><span class="token punctuation">]</span><span class="token punctuation">)</span>y <span class="token operator">=</span> npy<span class="token punctuation">.</span>cos<span class="token punctuation">(</span>x<span class="token punctuation">)</span>ax<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token comment">#设置x轴标签</span>ax<span class="token punctuation">.</span>set_xlabel<span class="token punctuation">(</span>‘angle’<span class="token punctuation">)</span>ax<span class="token punctuation">.</span>set_title<span class="token punctuation">(</span><span class="token string">'sin'</span><span class="token punctuation">)</span>ax<span class="token punctuation">.</span>set_xticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#设置x轴刻度标签</span>ax<span class="token punctuation">.</span>set_xticklabels<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'zero'</span><span class="token punctuation">,</span><span class="token string">'two'</span><span class="token punctuation">,</span><span class="token string">'four'</span><span class="token punctuation">,</span><span class="token string">'six'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#设置y轴刻度</span>ax<span class="token punctuation">.</span>set_yticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="subplot-函数"><a href="#subplot-函数" class="headerlink" title="subplot()函数"></a>subplot()函数</h2><p>matplotlib.pyplot模块提供了一个 subplot() 函数，它可以均等地划分画布，该函数的参数格式如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span>nrows<span class="token punctuation">,</span> ncols<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>subplot如果出现了图像重叠,那么之前的那幅图就会被消除,但是,如果使用figure对象的add_subplot方法就不会被消除,而是两幅图重叠一起.</p><p>通过给figure画布创建多个axes对象也能做到subplot的效果.</p><h2 id="subplots-函数"><a href="#subplots-函数" class="headerlink" title="subplots()函数"></a>subplots()函数</h2><p>subplots() 函数和 subplot() 函数类似。其不同之处在于，subplots() 既创建了一个包含子图区域的画布，又创建了一个 figure 图形对象，而 subplot() 只是创建一个包含子图区域的画布。<br>格式如下</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">fig <span class="token punctuation">,</span> ax <span class="token operator">=</span> plt<span class="token punctuation">.</span>subplots<span class="token punctuation">(</span>nrows<span class="token punctuation">,</span> ncols<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>实例:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> pltfig<span class="token punctuation">,</span>a <span class="token operator">=</span>  plt<span class="token punctuation">.</span>subplots<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">import</span> numpy <span class="token keyword">as</span> npx <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token comment">#绘制平方函数</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span>x<span class="token operator">*</span>x<span class="token punctuation">)</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_title<span class="token punctuation">(</span><span class="token string">'square'</span><span class="token punctuation">)</span><span class="token comment">#绘制平方根图像</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span>np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_title<span class="token punctuation">(</span><span class="token string">'square root'</span><span class="token punctuation">)</span><span class="token comment">#绘制指数函数</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span>np<span class="token punctuation">.</span>exp<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_title<span class="token punctuation">(</span><span class="token string">'exp'</span><span class="token punctuation">)</span><span class="token comment">#绘制对数函数</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span>np<span class="token punctuation">.</span>log10<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_title<span class="token punctuation">(</span><span class="token string">'log'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="subplot2grid-函数"><a href="#subplot2grid-函数" class="headerlink" title="subplot2grid()函数"></a>subplot2grid()函数</h2><p> subplot2grid()能够在画布的特定位置创建 axes 对象（即绘图区域）。不仅如此，它还可以使用不同数量的行、列来创建跨度不同的绘图区域。与 subplot() 和 subplots() 函数不同，subplot2gird() 函数以非等分的形式对画布进行切分，并按照绘图区域的大小来展示最终绘图结果。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">plt<span class="token punctuation">.</span>subplot2grid<span class="token punctuation">(</span>shape<span class="token punctuation">,</span> location<span class="token punctuation">,</span> rowspan<span class="token punctuation">,</span> colspan<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>shape：把该参数值规定的网格区域作为绘图区域；</li><li>location：在给定的位置绘制图形，初始位置 (0,0) 表示第1行第1列；</li><li>rowsapan/colspan：这两个参数用来设置让子区跨越几行几列。<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment">#使用 colspan指定列，使用rowspan指定行</span>a1 <span class="token operator">=</span> plt<span class="token punctuation">.</span>subplot2grid<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>colspan <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span>a2 <span class="token operator">=</span> plt<span class="token punctuation">.</span>subplot2grid<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> rowspan <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span>a3 <span class="token operator">=</span> plt<span class="token punctuation">.</span>subplot2grid<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>rowspan <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> colspan <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span>x <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span>a2<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span> x<span class="token operator">*</span>x<span class="token punctuation">)</span>a2<span class="token punctuation">.</span>set_title<span class="token punctuation">(</span><span class="token string">'square'</span><span class="token punctuation">)</span>a1<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span> np<span class="token punctuation">.</span>exp<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>a1<span class="token punctuation">.</span>set_title<span class="token punctuation">(</span><span class="token string">'exp'</span><span class="token punctuation">)</span>a3<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span> np<span class="token punctuation">.</span>log<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>a3<span class="token punctuation">.</span>set_title<span class="token punctuation">(</span><span class="token string">'log'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>tight_layout<span class="token punctuation">(</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="双轴图"><a href="#双轴图" class="headerlink" title="双轴图"></a>双轴图</h2><p>在需要两个x轴或者两个y轴的情况下,可以使用Matplotlib提供的twinx()和twiny()函数,实现双轴功能.<br>绘制指数函数和对数函数的示例如下:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> npy<span class="token comment">## 布置画布</span>fig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token punctuation">)</span>ax1 <span class="token operator">=</span> fig<span class="token punctuation">.</span>add_axes<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">## 准备自变量x</span>x <span class="token operator">=</span> npy<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token comment">## 绘制指数函数</span>ax1<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span>npy<span class="token punctuation">.</span>exp<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">'r'</span><span class="token punctuation">,</span>label<span class="token operator">=</span><span class="token string">'exp'</span><span class="token punctuation">)</span>ax1<span class="token punctuation">.</span>set_ylabel<span class="token punctuation">(</span><span class="token string">'exp'</span><span class="token punctuation">)</span>ax1<span class="token punctuation">.</span>legend<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">## 绘制对数函数</span>ax2 <span class="token operator">=</span> ax1<span class="token punctuation">.</span>twiny<span class="token punctuation">(</span><span class="token punctuation">)</span>ax2<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">[</span>x<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>npy<span class="token punctuation">.</span>log<span class="token punctuation">(</span>x<span class="token punctuation">[</span>x<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">'b--'</span><span class="token punctuation">,</span>label<span class="token operator">=</span><span class="token string">'log'</span><span class="token punctuation">)</span>ax2<span class="token punctuation">.</span>set_ylabel<span class="token punctuation">(</span><span class="token string">'log'</span><span class="token punctuation">)</span>ax2<span class="token punctuation">.</span>legend<span class="token punctuation">(</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h2><p>Matplotlib 提供了bar()函数来绘制柱状图。当它与 axes 对象一起使用时，其语法格式如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ax<span class="token punctuation">.</span>bar<span class="token punctuation">(</span>x<span class="token punctuation">,</span> height<span class="token punctuation">,</span> width<span class="token punctuation">,</span> bottom<span class="token punctuation">,</span> align<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>x:标量,代表x坐标</li><li>height:标量序列,表示柱状图高度</li><li>width:可选参数,表示柱状图宽度</li><li>bottom:表示柱状图开始堆叠的起始值</li><li>align:有两个可选项 {“center”,”edge”}，默认为 ‘center’，该参数决定 x 值位于柱状图的位置。</li></ul><h2 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h2><p>语法格式:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">hist<span class="token punctuation">(</span>x<span class="token punctuation">,</span>bins<span class="token punctuation">,</span><span class="token builtin">range</span><span class="token punctuation">,</span>density<span class="token punctuation">,</span>histtype<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>x:数组或者数组序列</li><li>bins:可选参数,整数或者序列，表示每一个间隔的边缘（起点和终点）默认会生成10个间隔。</li><li>range:指定全局间隔的下限与上限值 (min,max)，元组类型，默认值为 None。</li><li>density:如果为 True，返回概率密度直方图；默认为 False，返回相应区间元素的个数的直方图。</li><li>histtype:要绘制的直方图类型，默认值为“bar”，可选值有 barstacked(堆叠条形图)、step(未填充的阶梯图)、stepfilled(已填充的阶梯图)。</li></ul><h2 id="饼状图"><a href="#饼状图" class="headerlink" title="饼状图"></a>饼状图</h2><p>Matplotlib 提供了一个 pie() 函数，该函数可以生成数组中数据的饼状图。您可使用 x/sum(x) 来计算各个扇形区域占饼图总和的百分比。pie() 函数的参数说明如下：</p><pre class="line-numbers language-none"><code class="language-none">pie(x,labels,color,autopct)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>x:数组</li><li>labels:字符串序列,给每一个扇形区域备注一个名字</li><li>color:为每个扇形区域设置颜色,默认按照颜色周期填充</li><li>autopct:     格式化字符串”fmt%pct”，使用百分比的格式设置每个扇形<br>区的标签，并将其放置在扇形区内。</li></ul><h2 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h2><p>matplotlib里面没有绘制折线图的函数,但是可以通过调用text()的方法在图像上绘制注释文本的方法,示例如下:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment">#准备绘制数据</span>x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Mon"</span><span class="token punctuation">,</span> <span class="token string">"Tues"</span><span class="token punctuation">,</span> <span class="token string">"Wed"</span><span class="token punctuation">,</span> <span class="token string">"Thur"</span><span class="token punctuation">,</span> <span class="token string">"Fri"</span><span class="token punctuation">,</span><span class="token string">"Sat"</span><span class="token punctuation">,</span><span class="token string">"Sun"</span><span class="token punctuation">]</span>y <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">,</span> <span class="token number">55</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">]</span><span class="token comment"># "g" 表示红色，marksize用来设置'D'菱形的大小</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> <span class="token string">"g"</span><span class="token punctuation">,</span> marker<span class="token operator">=</span><span class="token string">'D'</span><span class="token punctuation">,</span> markersize<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">"周活"</span><span class="token punctuation">)</span><span class="token comment">#绘制坐标轴标签</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">"登录时间"</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">"用户活跃度"</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">"C语言中文网活跃度"</span><span class="token punctuation">)</span><span class="token comment">#显示图例</span>plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span>loc<span class="token operator">=</span><span class="token string">"lower right"</span><span class="token punctuation">)</span><span class="token comment">#调用 text()在图像上绘制注释文本</span><span class="token comment">#x1、y1表示文本所处坐标位置，ha参数控制水平对齐方式, va控制垂直对齐方式，str(y1)表示要绘制的文本</span><span class="token keyword">for</span> x1<span class="token punctuation">,</span> y1 <span class="token keyword">in</span> <span class="token builtin">zip</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>    plt<span class="token punctuation">.</span>text<span class="token punctuation">(</span>x1<span class="token punctuation">,</span> y1<span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">(</span>y1<span class="token punctuation">)</span><span class="token punctuation">,</span> ha<span class="token operator">=</span><span class="token string">'center'</span><span class="token punctuation">,</span> va<span class="token operator">=</span><span class="token string">'bottom'</span><span class="token punctuation">,</span> fontsize<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token comment">#保存图片</span>plt<span class="token punctuation">.</span>savefig<span class="token punctuation">(</span><span class="token string">"1.jpg"</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h2><p>散点图的语法规范:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">scatter<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> color<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>x:自变量</li><li>y:因变量</li><li>color:点的颜色</li></ul><h2 id="等高线图"><a href="#等高线图" class="headerlink" title="等高线图"></a>等高线图</h2><p>如果您想要查看因变量 Z 与自变量 X、Y 之间的函数图像变化（即 Z=f(X,Y)），那么采用等高线图最为直观。</p><p><code>numpy</code>里面有函数<code>meshgrid</code>构建网格点矩阵.</p><p>在matplotlob API里面提供了绘制等高线（<code>contour</code>）与填充等高线（ <code>contourf</code>）的函数。这两个函数都需要三个参数，分别是 X、Y 与 Z。</p><p>示例:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> npy<span class="token comment">## 构建500*500的网格</span>x <span class="token operator">=</span> npy<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">500</span><span class="token punctuation">)</span>y <span class="token operator">=</span> npy<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">500</span><span class="token punctuation">)</span>X<span class="token punctuation">,</span>Y <span class="token operator">=</span> npy<span class="token punctuation">.</span>meshgrid<span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token comment">## 构建画布</span>fig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token punctuation">)</span>ax1 <span class="token operator">=</span> fig<span class="token punctuation">.</span>add_axes<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">## 构建函数</span>Z <span class="token operator">=</span> npy<span class="token punctuation">.</span>log<span class="token punctuation">(</span>X<span class="token operator">**</span><span class="token number">2</span><span class="token operator">+</span>Y<span class="token operator">**</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token comment">## 构建等高线</span>cp <span class="token operator">=</span> ax1<span class="token punctuation">.</span>contourf<span class="token punctuation">(</span>X<span class="token punctuation">,</span>Y<span class="token punctuation">,</span>Z<span class="token punctuation">)</span>fig<span class="token punctuation">.</span>colorbar<span class="token punctuation">(</span>cp<span class="token punctuation">)</span> <span class="token comment">##添加颜色柱</span>ax1<span class="token punctuation">.</span>set_title<span class="token punctuation">(</span><span class="token string">'Test'</span><span class="token punctuation">)</span>ax1<span class="token punctuation">.</span>set_ylabel<span class="token punctuation">(</span><span class="token string">'Y'</span><span class="token punctuation">)</span>ax1<span class="token punctuation">.</span>set_xlabel<span class="token punctuation">(</span><span class="token string">'X'</span><span class="token punctuation">)</span><span class="token comment">## 画等高线</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3D绘图"><a href="#3D绘图" class="headerlink" title="3D绘图"></a>3D绘图</h2><p>通过调用<code>matplotlib</code>的绘图工具包<code>mpl_toolkits.mplot3d</code>的一些接口可以实现绘制3D图形.</p><h3 id="基础绘图"><a href="#基础绘图" class="headerlink" title="基础绘图"></a>基础绘图</h3><p>首先需要创建一个<code>3D</code>绘图区域,<code>pyplot.axes()</code>这个<code>axes</code>对象构造方法提供了一个参数<code>projection</code>,将其参数值设置为<code>3d</code>.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> mpl_toolkits <span class="token keyword">import</span> mplot3d <span class="token keyword">as</span> m3d<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> npyax1 <span class="token operator">=</span> plt<span class="token punctuation">.</span>axes<span class="token punctuation">(</span>projection<span class="token operator">=</span><span class="token string">'3d'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后构建<code>3D</code>图像</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#从x,y,z轴开始构建</span>x <span class="token operator">=</span> npy<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">)</span>y <span class="token operator">=</span> npy<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">)</span>z <span class="token operator">=</span> npy<span class="token punctuation">.</span>exp<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">+</span>npy<span class="token punctuation">.</span>hstack<span class="token punctuation">(</span><span class="token punctuation">(</span>npy<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>npy<span class="token punctuation">.</span>log<span class="token punctuation">(</span>y<span class="token punctuation">[</span>y<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>最后调用<code>plot3D()</code>方法构建<code>3d</code>图形</p><pre class="line-numbers language-none"><code class="language-none">ax1.plot3D(x,y,z,&#39;b&#39;)ax1.set_title(&#39;The first 3D&#39;)plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3D散点图"><a href="#3D散点图" class="headerlink" title="3D散点图"></a>3D散点图</h3><p><code>ax.scatter3D()</code>函数可以绘制 3D 散点图</p><h3 id="3D等高线图"><a href="#3D等高线图" class="headerlink" title="3D等高线图"></a>3D等高线图</h3><p><code>ax.contour3D()</code>可以用来创建三维等高线图</p><h3 id="3D线框图"><a href="#3D线框图" class="headerlink" title="3D线框图"></a>3D线框图</h3><p><code>plot_wireframe()</code>能够绘制 3D 线框图。</p><h3 id="3D曲线图"><a href="#3D曲线图" class="headerlink" title="3D曲线图"></a>3D曲线图</h3><p><code>plot_surface()</code>函数可以绘制 3D 曲面图</p><h2 id="Matplotlib绘制文本"><a href="#Matplotlib绘制文本" class="headerlink" title="Matplotlib绘制文本"></a>Matplotlib绘制文本</h2><p><code>Matplotlib</code>通过下列函数绘制出相应内容</p><table><thead><tr><th align="left">函数</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">text</td><td align="left">在绘图区域的任意位置添加文本。</td></tr><tr><td align="left">annotate</td><td align="left">在绘图区域的任意位置添加带有可选箭头的注释。</td></tr><tr><td align="left">xlabel</td><td align="left">在绘图区域的 x 轴上添加标签。</td></tr><tr><td align="left">ylabel</td><td align="left">在绘图区域的 y 轴上添加标签。</td></tr><tr><td align="left">title</td><td align="left">为绘图区域添加标题。</td></tr><tr><td align="left">figtext</td><td align="left">在画布的任意位置添加文本。</td></tr><tr><td align="left">suptitle</td><td align="left">为画布中添加标题。</td></tr></tbody></table><h2 id="Matplotlib数学表达式"><a href="#Matplotlib数学表达式" class="headerlink" title="Matplotlib数学表达式"></a>Matplotlib数学表达式</h2><p>Matplotlib 中的文本字符串都可以使用 Text Markup（一种文本标记语言）显现出来，Text Markup类似Mathjax.</p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python,Matplotlib,数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scipy学习</title>
      <link href="/2022/01/22/Scipy%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/01/22/Scipy%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Scipy"><a href="#Scipy" class="headerlink" title="Scipy"></a>Scipy</h1><p>address:<a href="https://scipy.github.io/devdocs/tutorial/index.html">https://scipy.github.io/devdocs/tutorial/index.html</a></p><h2 id="Scipy内置模块"><a href="#Scipy内置模块" class="headerlink" title="Scipy内置模块"></a>Scipy内置模块</h2><table><thead><tr><th align="left">模块名</th><th align="left">功能</th><th align="left">参考文档</th></tr></thead><tbody><tr><td align="left">scipy.constants</td><td align="left">数学常量</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/constants.html">constants API</a></td></tr><tr><td align="left">scipy.cluster</td><td align="left">向量量化</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/cluster.html#module-scipy.cluster">cluster API</a></td></tr><tr><td align="left">scipy.fftpack</td><td align="left">快速傅里叶变换</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/fftpack.html#module-scipy.fftpack">fft API</a></td></tr><tr><td align="left">scipy.integrate</td><td align="left">积分</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/integrate.html#module-scipy.integrate">integrate API</a></td></tr><tr><td align="left">scipy.interpolate</td><td align="left">插值</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/interpolate.html#module-scipy.interpolate">interpolate API</a></td></tr><tr><td align="left">scipy.io</td><td align="left">数据输入输出</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/io.html#module-scipy.io">io API</a></td></tr><tr><td align="left">scipy.linalg</td><td align="left">线性代数</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/linalg.html#module-scipy.linalg">linalg API</a></td></tr><tr><td align="left">scipy.ndimage</td><td align="left">N 维图像</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/ndimage.html#module-scipy.ndimage">ndimage API</a></td></tr><tr><td align="left">scipy.odr</td><td align="left">正交距离回归</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/odr.html#module-scipy.odr">odr API</a></td></tr><tr><td align="left">scipy.optimize</td><td align="left">优化算法</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/optimize.html#module-scipy.optimize">optimize API</a></td></tr><tr><td align="left">scipy.signal</td><td align="left">信号处理</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/signal.html#module-scipy.signal">signal API</a></td></tr><tr><td align="left">scipy.sparse</td><td align="left">稀疏矩阵</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/sparse.html#module-scipy.sparse">sparse API</a></td></tr><tr><td align="left">scipy.spatial</td><td align="left">空间数据结构和算法</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/spatial.html#module-scipy.spatial">spatial API</a></td></tr><tr><td align="left">scipy.special</td><td align="left">特殊数学函数</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/special.html#module-scipy.special">special API</a></td></tr><tr><td align="left">scipy.stats</td><td align="left">统计函数</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/reference/stats.html#module-scipy.stats">stats.mstats API</a></td></tr><tr><td align="left">scipy.misc</td><td align="left">图像处理</td><td align="left"><a href="https://docs.scipy.org/doc/scipy/reference/misc.html">misc API</a></td></tr></tbody></table><h2 id="Scipy常数模块"><a href="#Scipy常数模块" class="headerlink" title="Scipy常数模块"></a>Scipy常数模块</h2><p><code>Scipy.constants</code>模块内置多种常数,包括:</p><ul><li>公制单位</li><li>字节为单位的二进制</li><li>质量单位</li><li>角度换算</li><li>时间单位</li><li>长度单位</li><li>压强单位</li><li>体积单位</li><li>速度单位</li><li>温度单位</li><li>能量单位</li><li>功率单位</li><li>力学单位</li></ul><h2 id="Scipy-cluster模块"><a href="#Scipy-cluster模块" class="headerlink" title="Scipy cluster模块"></a>Scipy cluster模块</h2><p>这个模块分为vq模块和hierarchy模块.</p><h3 id="vq模块"><a href="#vq模块" class="headerlink" title="vq模块"></a>vq模块</h3><p>此模块实现k-means算法和向量量化.</p><h4 id="K-means算法"><a href="#K-means算法" class="headerlink" title="K-means算法"></a>K-means算法</h4><ul><li>1.首先给定需要的类/簇个数n</li><li>2.随机定n个簇心</li><li>3.将每个点分在离它最近的簇心</li><li>4.对于每个簇心,计算属于它的点集的平均点,该点为新的簇心</li><li>5.在获得新的n个簇心之后,重复 3,4步骤,如果划分新的点集的时候,点集没有变则循环结束.</li></ul><p>这个算法最后返回的是质心坐标矩阵,通过<code>vq</code>方法再把每个点分给对应的质心,<code>vq</code>方法的返回值是每个观察的簇是失真.</p><h3 id="hierarchy模块"><a href="#hierarchy模块" class="headerlink" title="hierarchy模块"></a>hierarchy模块</h3><p>见<a href="%E5%A4%9A%E5%85%83%E5%88%86%E6%9E%90.md">博客多元分析一节</a></p><h2 id="Scipy-fftpack模块"><a href="#Scipy-fftpack模块" class="headerlink" title="Scipy fftpack模块"></a>Scipy fftpack模块</h2><p>fftpack模块提供了快速傅里叶变化的方法.</p><h3 id="一维离散傅里叶变换"><a href="#一维离散傅里叶变换" class="headerlink" title="一维离散傅里叶变换"></a>一维离散傅里叶变换</h3><p>长度为n的x序列,通过fft方法算出其在复数域上的映射a+bi.ifft方法是逆傅里叶变换.</p><h3 id="离散余弦变换"><a href="#离散余弦变换" class="headerlink" title="离散余弦变换"></a>离散余弦变换</h3><p>离散余弦变换是实偶函数的傅里叶变换,不含虚数单位项.可以认为是0i.也即没有初项,只有振幅和频率两个参数.<br>Scipy提供了dct和idct方法求得</p><h2 id="Scipy-integrade模块"><a href="#Scipy-integrade模块" class="headerlink" title="Scipy integrade模块"></a>Scipy integrade模块</h2><p>下表是integrate库中的常用功能</p><table><thead><tr><th align="left">编号</th><th align="left">功能说明</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">quad单积分</td></tr><tr><td align="left">2</td><td align="left">dblquad双重积分</td></tr><tr><td align="left">3</td><td align="left">tplquad三重积分</td></tr><tr><td align="left">4</td><td align="left">nquadn倍多重积分</td></tr><tr><td align="left">5</td><td align="left">fixed_quad高斯积分，阶数n</td></tr><tr><td align="left">6</td><td align="left">quadrature高斯正交到容差</td></tr><tr><td align="left">7</td><td align="left">romberg隆伯格积分</td></tr><tr><td align="left">8</td><td align="left">trapz梯形法则</td></tr><tr><td align="left">9</td><td align="left">cumtrapz梯形法则累计计算积分</td></tr><tr><td align="left">10</td><td align="left">simps辛普森的规则</td></tr><tr><td align="left">11</td><td align="left">romb隆伯格整合</td></tr><tr><td align="left">12</td><td align="left">polyint分析多项式积分（NumPy）</td></tr><tr><td align="left">13</td><td align="left">poly1d辅助函数polyint（NumPy）</td></tr></tbody></table><h3 id="quad-单积分"><a href="#quad-单积分" class="headerlink" title="quad 单积分"></a>quad 单积分</h3><p>$\int_a^bf\left(x\right)dx$ == quad(f,a,b)</p><p>quad返回两个值,第一个是积分结果,第二个是积分的绝对误差</p><p>实例:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> scipy<span class="token punctuation">.</span>integrate<span class="token keyword">from</span> numpy <span class="token keyword">import</span> expf<span class="token operator">=</span> <span class="token keyword">lambda</span> x<span class="token punctuation">:</span>exp<span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">)</span>i <span class="token operator">=</span> scipy<span class="token punctuation">.</span>integrate<span class="token punctuation">.</span>quad<span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">print</span> i<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="双重积分"><a href="#双重积分" class="headerlink" title="双重积分"></a>双重积分</h3><p>对于积分<br>$$\int_a^bdx\int_{g(x)}^{h(x)}dyf(x,y)$$<br>其等价于<code>dblquad（func，a，b，gfun，hfun)</code></p><p>其中func是<code>f(x,y)</code>这个复合函数 <code>a</code>,<code>b</code>是<code>x</code>的上下限,<code>gfunc</code>和<code>hfunc</code>是y的上下限.</p><p>输出和单积分相同,一个是积分结果,一个是绝对误差,</p><h2 id="interpolate-插值"><a href="#interpolate-插值" class="headerlink" title="interpolate 插值"></a>interpolate 插值</h2><h3 id="什么是插值"><a href="#什么是插值" class="headerlink" title="什么是插值"></a>什么是插值</h3><p>插值就是在离散数据的基础上补插连续函数,使得连续函数通过这些离散点.这是离散函数逼近的重要方法.</p><h3 id="Interp1d"><a href="#Interp1d" class="headerlink" title="Interp1d"></a>Interp1d</h3><p>scipy.interpolate中的interp1d类是一种基于固定数据点创建函数的便捷方法.</p><pre class="line-numbers language-none"><code class="language-none">interp1d(datax,datay,kind)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中的datax,datay分别为离散参数,kind是插值方式,比如线性(liner),最近(nearest),零,二次(cubic),立方等.</p><h3 id="多维数据插值-griddata"><a href="#多维数据插值-griddata" class="headerlink" title="多维数据插值-griddata"></a>多维数据插值-griddata</h3><pre class="line-numbers language-none"><code class="language-none">griddata(points,value,point_grid,method)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数解释:</p><ul><li>points 是每个点的坐标</li><li>value 是点相应的函数结果值</li><li>point_grid 是你要想获得结果的点的坐标</li><li>method 是插值方法</li></ul><p>这个方法返回的是点的函数结果</p><h3 id="单变量样条"><a href="#单变量样条" class="headerlink" title="单变量样条"></a>单变量样条</h3><p>UnivariateSpline是基于固定数据点类创建函数的便捷方法.</p><pre class="line-numbers language-none"><code class="language-none">scipy.interpolate.UnivariateSpline（x，y，w &#x3D; None，bbox &#x3D; [None，None]，k &#x3D; 3，s &#x3D;无，ext &#x3D; 0，check_finite &#x3D; False）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数解释:</p><ul><li>‘w’ - 指定样条拟合的权重。 必须是正数的。 如果没有（默认），权重都是相等的。</li><li>‘s’ - 通过指定平滑条件指定结的数量。</li><li>‘k’ - 平滑样条曲线的度数。 必须&lt;= 5.默认值为k = 3，三次样条曲线。</li><li>Ext - 控制不在结节序列定义的区间内的元素的外推模式。</li><li><ul><li>如果ext = 0或’extrapolate’，则返回外推值。</li></ul></li><li><ul><li>如果ext = 1或’0’，则返回0</li></ul></li><li><ul><li>如果ext = 2或’raise’，则引发ValueError</li></ul></li><li><ul><li>如果ext = 3’const’，则返回边界值。 </li></ul></li><li>check_finite - 是否检查输入数组是否仅包含有限数字。 </li></ul><h2 id="Scipy-I-O模块"><a href="#Scipy-I-O模块" class="headerlink" title="Scipy I/O模块"></a>Scipy I/O模块</h2><h3 id="MATLAB-files"><a href="#MATLAB-files" class="headerlink" title="MATLAB files"></a>MATLAB files</h3><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">loadmat(file_name[, mdict, appendmat])</td><td align="left">Load MATLAB file.</td></tr><tr><td align="left">savemat(file_name, mdict[, appendmat, …])</td><td align="left">Save a dictionary of names and arrays into a MATLAB-style .mat file.</td></tr><tr><td align="left">whosmat(file_name[, appendmat])</td><td align="left">List variables inside a MATLAB file.</td></tr></tbody></table><ul><li>loadmat<blockquote><p>squeeze_me参数为true时能将文件中1*1大小的矩阵滤除<br>struct_as_record 参数为False时能将struct类型变成类似python的对象,能直接通过属性访问数据,而不是字典.</p></blockquote></li><li>savemat 可以通过字典的形式存<pre class="line-numbers language-python" data-language="python"><code class="language-python">a_dict <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">'field1'</span><span class="token punctuation">:</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token string">'field2'</span><span class="token punctuation">:</span> <span class="token string">'a string'</span><span class="token punctuation">&#125;</span>sio<span class="token punctuation">.</span>savemat<span class="token punctuation">(</span><span class="token string">'saved_struct.mat'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token string">'a_dict'</span><span class="token punctuation">:</span> a_dict<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="ID-files"><a href="#ID-files" class="headerlink" title="ID files"></a>ID files</h3><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">readsav(file_name[, idict, python_dict, …])</td><td align="left">Read an IDL .sav file.</td></tr></tbody></table><h3 id="Matrix-Market-files"><a href="#Matrix-Market-files" class="headerlink" title="Matrix Market files"></a>Matrix Market files</h3><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">mminfo(source)</td><td align="left">Return size and storage parameters from Matrix Market file-like ‘source’.</td></tr><tr><td align="left">mmread(source)</td><td align="left">Reads the contents of a Matrix Market file-like ‘source’ into a matrix.</td></tr><tr><td align="left">mmwrite(target, a[, comment, field, …])</td><td align="left">Writes the sparse or dense array a to Matrix Market file-like target.</td></tr></tbody></table><h2 id="Scipy-linalg-模块"><a href="#Scipy-linalg-模块" class="headerlink" title="Scipy.linalg 模块"></a>Scipy.linalg 模块</h2><code>Scipy,linalg</code>包含所有的<code>numpy.linalg</code>函数,另外还有一些高级函数.<h3 id="linalg-solve"><a href="#linalg-solve" class="headerlink" title="linalg.solve"></a>linalg.solve</h3><code>solve(a,b)</code> a是系数矩阵,b是右手侧常数项.如<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#importing the scipy and numpy packages</span><span class="token keyword">from</span> scipy <span class="token keyword">import</span> linalg<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment">#Declaring the numpy arrays</span>a <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>b <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#Passing the values to the solve function</span>x <span class="token operator">=</span> linalg<span class="token punctuation">.</span>solve<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token comment">#printing the result array</span><span class="token keyword">print</span> x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>等于下列线性方程组<br>$$3x + 2y + 0z = 2$$<br>$$1x + -1y + 0z = 4$$<br>$$0x + 5y + 1z = -1$$<br>这个方法返回解数组<h3 id="行列式值"><a href="#行列式值" class="headerlink" title="行列式值"></a>行列式值</h3><code>Scipy.linalg.det</code>函数计算矩阵的标量值<h3 id="特征值和特征向量"><a href="#特征值和特征向量" class="headerlink" title="特征值和特征向量"></a>特征值和特征向量</h3>$$Av = \lambda v$$<br>A是矩阵,v是特征向量,$\lambda$是特征值.scipy.linalg.eig能返回函数特征值和特征向量.</li></ul><p><code>l,v = eig(array)</code> l是特征值,v是特征向量. </p><h3 id="奇异值分解"><a href="#奇异值分解" class="headerlink" title="奇异值分解"></a>奇异值分解</h3><h4 id="理论解释"><a href="#理论解释" class="headerlink" title="理论解释"></a>理论解释</h4><p>奇异值分解(SVD)可以认为是特征值问题对非平方矩阵的扩展.</p><p>对于方阵,如果求出了他的特征值和特征向量,那么方阵$A = W\Sigma W^T$</p><p>其中W为n个特征向量张成的矩阵,$\Sigma$是n个相应的特征值为主对角线的n*n维矩阵.</p><p>那么对于非平方矩阵,也有类似的特征分解表达式<br>$$A = U\Sigma V^T$$<br>A是一个m*n的矩阵,U是一个m*m的矩阵,$\Sigma$是一个m*n的矩阵,除了主对角线元素以外全为0,主对角线每个元素成为奇异值,V是一个n*n的矩阵.U和V都是酉矩阵,即满足$U^TU = I, V^TV = I$</p><p>那么$A^TA = V\Sigma^T U^TU\Sigma V^T =V\Sigma’ V^T = W\Sigma W^T$<br>所以由所有特征向量张成的矩阵就是矩阵<code>V</code>.</p><p>同样$AA^T = U\Sigma’’U^T$,那么其所有特征向量张成的矩阵就是矩阵<code>U</code></p><p>对于奇异值矩阵我们发现$AV = U\Sigma$那么$Av_i=\sigma_iu_i$所以$\sigma_i=Av_i/u_i$</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>scipy.linalg里面的svd方法能求出相应的U,S,V矩阵.<br><code>U,S,V = svd(array)</code></p><h2 id="Scipy-ndimage模块"><a href="#Scipy-ndimage模块" class="headerlink" title="Scipy.ndimage模块"></a>Scipy.ndimage模块</h2><p><code>ndimage</code>模块主要用于图像处理,常见功能如下:</p><ul><li>输入/输出，显示图像</li><li>基本操作 - 裁剪，翻转，旋转等</li><li>图像过滤 - 去噪，锐化等</li><li>图像分割 - 标记与不同对象相对应的像素</li><li>Classification</li><li>Feature extraction</li><li>Registration<h3 id="过滤器filter"><a href="#过滤器filter" class="headerlink" title="过滤器filter"></a>过滤器filter</h3>下面的函数都是对数组中的值进行过滤,输出元素是输入元素邻域元素的函数值.对于这个元素邻域我们成为过滤器内核,可以是矩形,也可以是任意图形,通过自己给的权重控制.对于过滤器内核,其内核中心一般是核形状的尺寸除以2,(长度为2的内核,中心就是1,既第一位元素.),但是也能通过设置参数移动内核中心.</li></ul><p>对于边界元素,需要边界外的值来辅助计算,所以需要选择边界条件.</p><table><thead><tr><th align="left">mode</th><th align="left">description</th><th align="left">example</th></tr></thead><tbody><tr><td align="left">nearest</td><td align="left">使用边界值</td><td align="left">[1,2]-&gt;[1,1,2,2]</td></tr><tr><td align="left">wrap</td><td align="left">复制阵列</td><td align="left">[1,2,3]-&gt;[3,1,2,3,1]</td></tr><tr><td align="left">reflect</td><td align="left">反射在边界的数组</td><td align="left">[1,2,3]-&gt;[1,1,2,3,3]</td></tr><tr><td align="left">mirror</td><td align="left">镜像边界处的数组</td><td align="left">[1,2,3]-&gt;[2,1,2,3,2]</td></tr><tr><td align="left">constant</td><td align="left">使用常数填充(默认是0)</td><td align="left">[1,2,3]-&gt;[0,1,2,3,0]</td></tr></tbody></table><p>同时还支持以下关键字</p><table><thead><tr><th align="left">mode</th><th align="left">description</th></tr></thead><tbody><tr><td align="left">grid-constant</td><td align="left">等价于constant</td></tr><tr><td align="left">grid-mirror</td><td align="left">等价于mirror</td></tr><tr><td align="left">grid-wrap</td><td align="left">等价于wrap</td></tr></tbody></table><ul><li>correlate是计算多维相关的函数,数组和给定内核相关<blockquote><p><code>scipy.ndimage.correlate(input, weights, output=None, mode=&#39;reflect&#39;, cval=0.0, origin=0)</code></p><p>参数解释</br></p><ul><li>input:输入的矩阵</li><li>weights:内核权重</li><li>output:要在其中放置输出的数组，或返回数组的 dtype。默认情况下，将创建与输入相同的 dtype 数组。</li><li>mode:对于边界元素的处理方式</li><li>cval:如果mode是constant,填充的常数,默认是0</li><li>origin: 内核中心偏移</li></ul></blockquote></li><li>correlate1d 是计算一维线性相关的函数<blockquote><p><code>scipy.ndimage.correlate1d(input, weights, axis=- 1, output=None, mode=&#39;reflect&#39;, cval=0.0, origin=0)[source]</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">></span><span class="token keyword">from</span> scipy<span class="token punctuation">.</span>ndimage <span class="token keyword">import</span> correlate1d<span class="token operator">></span>correlate1d<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> weights<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">></span>array<span class="token punctuation">(</span><span class="token punctuation">[</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">,</span>  <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span>  <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">,</span>  <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><h3 id="插值函数"><a href="#插值函数" class="headerlink" title="插值函数"></a>插值函数</h3>Scipy.ndimage的插值函数是基于B-spline理论.其更详细的解释可以查看<a href="https://docs.scipy.org/doc/scipy/reference/tutorial/ndimage.html#interpolation-functions">官方文档</a>,本人因数理基础和时间原因,暂不能继续学习,未来或许会更新.<h3 id="形态学"><a href="#形态学" class="headerlink" title="形态学"></a>形态学</h3><a href="https://docs.scipy.org/doc/scipy/reference/tutorial/ndimage.html#interpolation-functions">官方文档</a><h3 id="距离变换"><a href="#距离变换" class="headerlink" title="距离变换"></a>距离变换</h3><a href="https://docs.scipy.org/doc/scipy/reference/tutorial/ndimage.html#interpolation-functions">官方文档</a><h2 id="Scipy-odr正交距离回归"><a href="#Scipy-odr正交距离回归" class="headerlink" title="Scipy.odr正交距离回归"></a>Scipy.odr正交距离回归</h2>odr表示<code>Orthogonal Distance Regression</code>,用于回归研究.在标准线性回归中,通常是通过计算Y的物产,但是有时候考虑X,Y和真实值的垂直距离误差更为明智.<br>ODR方法需要传递data,线性回归模型.<pre class="line-numbers language-python" data-language="python"><code class="language-python">ODR<span class="token punctuation">(</span>data<span class="token punctuation">,</span>linear_model<span class="token punctuation">,</span>beta0<span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">## 参数解释</span>linear_model <span class="token operator">=</span> Model<span class="token punctuation">(</span>linear_func<span class="token punctuation">)</span>data <span class="token operator">=</span> RealData<span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>linear_func <span class="token operator">=</span> <span class="token keyword">lambda</span> x<span class="token punctuation">,</span>p<span class="token punctuation">:</span>px<span class="token operator">+</span>px <span class="token operator">=</span> array<span class="token punctuation">(</span><span class="token punctuation">)</span>y <span class="token operator">=</span> array<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="Scipy-Optimize"><a href="#Scipy-Optimize" class="headerlink" title="Scipy.Optimize"></a>Scipy.Optimize</h2><p><code>Optimize</code>提供了几种优化算法,包括:</p><ul><li>无约束和约束最小化 </li><li>全局（强力）优化程序</li><li>最小二乘最小化和曲线拟合</li><li>标量单变量函数最小化器</li><li>根查找</li><li>使用各种算法的多变量方程系统求解器<h3 id="无约束和约束最小化多元标量函数"><a href="#无约束和约束最小化多元标量函数" class="headerlink" title="无约束和约束最小化多元标量函数"></a>无约束和约束最小化多元标量函数</h3>minimize方法是多变量标量函数无约束或约束最小化算法的通用接口.不同算法需要不同的method. minimize至少需要提供三个参数,分别是函数,自变量数组,算法.</li></ul><p>下面是rosenbrock函数的示例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> scipy<span class="token punctuation">.</span>optimize <span class="token keyword">import</span> minimize<span class="token keyword">def</span> <span class="token function">rosen</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""The Rosenbrock function"""</span>    <span class="token keyword">return</span> <span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token number">100.0</span><span class="token operator">*</span><span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">-</span>x<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">**</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2.0</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">-</span>x<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2.0</span><span class="token punctuation">)</span>x0 <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1.3</span><span class="token punctuation">,</span> <span class="token number">0.7</span><span class="token punctuation">,</span> <span class="token number">0.8</span><span class="token punctuation">,</span> <span class="token number">1.9</span><span class="token punctuation">,</span> <span class="token number">1.2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>res <span class="token operator">=</span> minimize<span class="token punctuation">(</span>rosen<span class="token punctuation">,</span> x0<span class="token punctuation">,</span> method<span class="token operator">=</span><span class="token string">'nelder-mead'</span><span class="token punctuation">,</span>               options<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token string">'xatol'</span><span class="token punctuation">:</span> <span class="token number">1e-8</span><span class="token punctuation">,</span> <span class="token string">'disp'</span><span class="token punctuation">:</span> <span class="token boolean">True</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其他算法详解:<a href="https://docs.scipy.org/doc/scipy/reference/tutorial/optimize.html">https://docs.scipy.org/doc/scipy/reference/tutorial/optimize.html</a></p><h3 id="全局优化"><a href="#全局优化" class="headerlink" title="全局优化"></a>全局优化</h3><p>有多个方法,分别是shgo,differential_evolution,basinhopping等,这些算法只需要提供函数和boundry就行.</p><h3 id="最小二乘法优化"><a href="#最小二乘法优化" class="headerlink" title="最小二乘法优化"></a>最小二乘法优化</h3><p>SciPy能够求解鲁棒约束的边界约束非线性最小二乘问题.给定残差f(x),损失函数rho(s),least_squares能找到代价函数F(x)的局部最小值</p><h3 id="根查找"><a href="#根查找" class="headerlink" title="根查找"></a>根查找</h3><p>root方法能找到非线性方程的根.示例如下.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np <span class="token keyword">from</span> scipy<span class="token punctuation">.</span>optimize <span class="token keyword">import</span> root<span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> x <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> np<span class="token punctuation">.</span>cos<span class="token punctuation">(</span>x<span class="token punctuation">)</span>sol <span class="token operator">=</span> root<span class="token punctuation">(</span>func<span class="token punctuation">,</span> <span class="token number">0.3</span><span class="token triple-quoted-string string">"""猜测值"""</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>sol<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token operator">//</span>解<span class="token comment">###array([-1.02986653])</span><span class="token keyword">print</span><span class="token punctuation">(</span>sol<span class="token punctuation">.</span>fun<span class="token punctuation">)</span> <span class="token operator">//</span>误差<span class="token comment">###array([ -6.66133815e-16])</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Scipy-sparse稀疏矩阵"><a href="#Scipy-sparse稀疏矩阵" class="headerlink" title="Scipy.sparse稀疏矩阵"></a>Scipy.sparse稀疏矩阵</h2><p>稀疏矩阵有不同的表现形式,主要是</p><ul><li>CSC -压缩稀疏列,按列压缩</li><li>CSR -压缩稀疏行,按行压缩</li></ul><p>对于稀疏矩阵,有data方法查看其矩阵内部非零元素,count_nonzero()方法计算非零元素总数,对于稀疏矩阵运算和linalg模块类似,但是需要调用sparse的子模块,sparse.linalg模块内部函数,具体看<a href="https://docs.scipy.org/doc/scipy/reference/reference/sparse.html">文档</a>.</p><h2 id="scipy-spatial-空间数据结构算法"><a href="#scipy-spatial-空间数据结构算法" class="headerlink" title="scipy.spatial 空间数据结构算法"></a>scipy.spatial 空间数据结构算法</h2><h2 id="scipy-special-特殊数学函数"><a href="#scipy-special-特殊数学函数" class="headerlink" title="scipy.special 特殊数学函数"></a>scipy.special 特殊数学函数</h2><h3 id="立方根函数"><a href="#立方根函数" class="headerlink" title="立方根函数"></a>立方根函数</h3><p> scipy.special.cbrt（x）获取x逐元素立方根。</p><h3 id="指数函数"><a href="#指数函数" class="headerlink" title="指数函数"></a>指数函数</h3><p>scipy.special.exp10（x）计算$10^x$。 </p><p>scipy.special.exp2（x）计算$2^x$。 </p><p>scipy.special.exp（x）计算$e^x$。</p><h3 id="相对误差指数函数"><a href="#相对误差指数函数" class="headerlink" title="相对误差指数函数"></a>相对误差指数函数</h3><p>scipy.special.exprel（x）生成相对误差指数，（exp（x） - 1）/ x。<br>当x接近零时，exp（x）接近1，因此exp（x）-1的数值计算可能遭受灾难性的精度损失。 所以需要xprel（x）以避免精度损失。 </p><h3 id="对数和指数函数"><a href="#对数和指数函数" class="headerlink" title="对数和指数函数"></a>对数和指数函数</h3><p>logsumexp(x) == log(sum(exp(a)))</p><h3 id="朗伯W函数"><a href="#朗伯W函数" class="headerlink" title="朗伯W函数"></a>朗伯W函数</h3><p>lambertw(x)函数是$f(x) = x * e^x$的反函数,也就是说<br>$$lambertw(x) = w$$<br>$$x = w*e^w$$</p><h3 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h3><p>组合函数的语法是 - scipy.special.comb（N，k）等价于 $C_n^k$</p><p>排列函数的语法是 - scipy.special.perm（N，k）等价于 $A_n^k$</p><h3 id="伽马功能"><a href="#伽马功能" class="headerlink" title="伽马功能"></a>伽马功能</h3><p>对于自然数<code>n</code>，伽马函数通常被称为广义阶乘，也即z * gamma（z）= gamma（z + 1）和gamma（n + 1）= n !,</p><h2 id="scipy-stats-统计数学函数"><a href="#scipy-stats-统计数学函数" class="headerlink" title="scipy.stats 统计数学函数"></a>scipy.stats 统计数学函数</h2><p>见<a href="https://docs.scipy.org/doc/scipy/reference/reference/generated/scipy.stats.rv_continuous.html#scipy.stats.rv_continuous">文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模,Scipy,Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy学习</title>
      <link href="/2022/01/19/Numpy%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/01/19/Numpy%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h1><p>address:<a href="https://www.numpy.org.cn/reference/">https://www.numpy.org.cn/reference/</a></p><h2 id="Ndarray对象"><a href="#Ndarray对象" class="headerlink" title="Ndarray对象"></a>Ndarray对象</h2><ul><li><code>Ndarray</code>等价于多维数组</li><li>构造方法:<pre class="line-numbers language-none"><code class="language-none">numpy.array(object, dtype &#x3D; None, copy &#x3D; True, order &#x3D; None, subok &#x3D; False, ndmin &#x3D; 0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><code>object</code>:数组或者嵌套的数列<br><code>dtype</code>:数组元素的数据类型,可选<br><code>copy</code>:数组是否需要复制,如果为false,则是对原数组的引用<br><code>order</code>:数组在内存中样式<br><code>subok</code>:默认返回一个与基类类型一致的数组<br><code>ndmin</code>:数组最小维度</p></blockquote><h2 id="数据类型对象dtype"><a href="#数据类型对象dtype" class="headerlink" title="数据类型对象dtype"></a>数据类型对象dtype</h2><code>dtype</code>实例是用来描述与数组对应的内存区域是如何使用的.</li><li>数据类型</li><li>数据大小</li><li>数据的字节顺序(大小端,&lt;表示小端,&gt;表示大端)</li><li>在结构化类型下,字段的名称,每个字段的数据类型和每个字段所取得内存块得部分</li><li>如果数据类型是子数组,描述其形状和数据类型</li></ul><p>构造:</br><br><code>numpy.dtype(object, align, copy)</code></p><p>类似于C的<code>struct</code>,要指明类型索引和类型输于的数据结构,如</p><pre class="line-numbers language-none"><code class="language-none">d &#x3D; dtype([(&#39;name&#39;,&#96;S20&#96;),((&#39;grade&#39;,&#39;int8&#39;))])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Numpy数组属性"><a href="#Numpy数组属性" class="headerlink" title="Numpy数组属性"></a>Numpy数组属性</h2><table><thead><tr><th align="left">属性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">ndarray.ndim</td><td align="left">秩，即轴的数量或维度的数量</td></tr><tr><td align="left">ndarray.shape</td><td align="left">数组的维度，对于矩阵，n 行 m 列</td></tr><tr><td align="left">ndarray.size</td><td align="left">数组元素的总个数，相当于 .shape 中 n*m 的值</td></tr><tr><td align="left">ndarray.dtype</td><td align="left">ndarray 对象的元素类型</td></tr><tr><td align="left">ndarray.itemsize</td><td align="left">ndarray 对象中每个元素的大小，以字节为单位</td></tr><tr><td align="left">ndarray.flags</td><td align="left">ndarray 对象的内存信息</td></tr><tr><td align="left">ndarray.real</td><td align="left">ndarray元素的实部</td></tr><tr><td align="left">ndarray.imag</td><td align="left">ndarray 元素的虚部</td></tr><tr><td align="left">ndarray.data</td><td align="left">包含实际数组元素的缓冲区，由于一般通过数组的索引获取元素，所以通常不需要使用这个属性。</td></tr></tbody></table><h2 id="Numpy创建数组"><a href="#Numpy创建数组" class="headerlink" title="Numpy创建数组"></a>Numpy创建数组</h2><ul><li><p>numpy.empty创建一个指定形状,指定数据类型的未初始化数组 <code>= np.empty([3,2], dtype = int)</code></p></li><li><p>numpy.zero创建一个指定大小,0填充的数组,默认为浮点数<code>numpy.zeros(shape, dtype = float, order = &#39;C&#39;)</code></p></li><li><p>numpy.one创建一个指定形状,1填充的数组,默认为浮点数<code>x = np.ones([2,2], dtype = int)</code></p></li><li><p>numpy.asarray类似array</p><blockquote><p><code>numpy.asarray(a, dtype = None, order = None)</code></p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">a</td><td align="left">任意形式的输入参数，可以是，列表, 列表的元组, 元组, 元组的元组, 元组的列表，多维数组</td></tr><tr><td align="left">dtype</td><td align="left">数据类型，可选</td></tr><tr><td align="left">order</td><td align="left">可选，有”C”和”F”两个选项,分别代表，行优先和列优先，在计算机内存中的存储元素的顺序。</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">&gt;x &#x3D;  [1,2,3] &gt;a &#x3D; np.asarray(x)  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote></li><li><p>numpy.frombuffer用于实现动态数组,接受buffer输入参数,以流的形式读入转化成ndarray对象.</p><blockquote><p><code>numpy.frombuffer(buffer, dtype = float, count = -1, offset = 0)</code></p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">buffer</td><td align="left">可以是任意对象，会以流的形式读入。</td></tr><tr><td align="left">dtype</td><td align="left">返回数组的数据类型，可选</td></tr><tr><td align="left">count</td><td align="left">读取的数据数量，默认为-1，读取所有数据。</td></tr><tr><td align="left">offset</td><td align="left">读取的起始位置，默认为0。</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">&gt;s &#x3D;  b&#39;Hello World&#39; &gt;a &#x3D; np.frombuffer(s, dtype &#x3D;  &#39;S1&#39;)  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote></li><li><p>numpy.fromiter 从可迭代对象中建立ndarray对象.</p><blockquote><p><code>numpy.fromiter(iterable, dtype, count=-1)</code></p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">iterable</td><td align="left">可迭代对象</td></tr><tr><td align="left">dtype</td><td align="left">返回数组的数据类型</td></tr><tr><td align="left">count</td><td align="left">读取的数据数量，默认为-1，读取所有数据</td></tr></tbody></table></blockquote></li><li><p>numpy.arange创建数值范围并返回ndarray对象</br><br><code>numpy.arange(start, stop, step, dtype)</code></p></li><li><p>numpy.linspace创建一个等差数列组成的一维数组</br><br><code>np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)</code></p></li><li><p>numpy.logspace创建一个等比数列</br><br><code>np.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)</code></p><h2 id="Numpy切片"><a href="#Numpy切片" class="headerlink" title="Numpy切片"></a>Numpy切片</h2></li><li><p>可以通过创建slice类来对数组进行切片</p><pre class="line-numbers language-none"><code class="language-none">s &#x3D; slice(0,16,2)print(a[s])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>可以通过:和…切片</p><h2 id="Numpy索引"><a href="#Numpy索引" class="headerlink" title="Numpy索引"></a>Numpy索引</h2></li><li><p>整数数组索引</p><blockquote><p>设索引地址为x,y. x = {x1,x2,…xn}, y = {y1,y2,…yn},a[x,y] = [a[x1,y1],…,a[xn,yn]]</p><pre class="line-numbers language-none"><code class="language-none">&gt;import numpy as np &gt;x &#x3D; np.array([[  0,  1,  2],[  3,  4,  5],[  6,  7,  8],[  9,  10,  &gt;11]])  &gt;rows &#x3D; np.array([[0,0],[3,3]]) &gt;cols &#x3D; np.array([[0,2],[0,2]]) &gt;y &#x3D; x[rows,cols]  &gt;print (y) ##[y[0,0],y[0,2],y[3,0],y[3,2]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote></li><li><p>布尔索引</p><blockquote><p>x = bool运算 , a[x] = {ai | ai 属于 a 且 ai满足x}</p></blockquote></li><li><p>花式索引</p><blockquote><p>设索引地址为x, a[x] = {ai | ai的行坐标为xi}<br>设索引地址为x,y, a[x,y] = {ai | aij的行坐标为xi,aij的列坐标属于y}</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np  x<span class="token operator">=</span>np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span> <span class="token punctuation">(</span>x<span class="token punctuation">[</span>np<span class="token punctuation">.</span>ix_<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">"""[[ 4  7  5  6] [20 23 21 22] [28 31 29 30] [ 8 11  9 10]] """</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Numpy-的广播-broadcase"><a href="#Numpy-的广播-broadcase" class="headerlink" title="Numpy 的广播(broadcase)"></a>Numpy 的广播(broadcase)</h2><p>如果数组运算,这俩矩阵的shape不同,则触发broadcase.</p></li></ul><p>broadcase规则</p><ul><li>让所有输入数组都向其中形状最长的数组看齐，形状中不足的部分都通过在前面加 1 补齐。</li><li>输出数组的形状是输入数组形状的各个维度上的最大值。</li><li>如果输入数组的某个维度和输出数组的对应维度的长度相同或者其长度为 1 时，这个数组能够用来计算，否则出错。</li><li>当输入数组的某个维度的长度为 1 时，沿着此维度运算时都用此维度上的第一组值。<h2 id="Numpy的迭代"><a href="#Numpy的迭代" class="headerlink" title="Numpy的迭代"></a>Numpy的迭代</h2>numpy.nditer可以将数组转化为迭代,默认是根据数组内存布局.<pre class="line-numbers language-none"><code class="language-none">nditer(array,order &#x3D; &quot;C&quot;,op_flags &#x3D; [&#39;read_only&#39;],flags)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>其中flags可以取:<table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">c_index</td><td align="left">可以跟踪 C 顺序的索引</td></tr><tr><td align="left">f_index</td><td align="left">可以跟踪 Fortran 顺序的索引</td></tr><tr><td align="left">multi_index</td><td align="left">每次迭代可以跟踪一种索引类型</td></tr><tr><td align="left">external_loop</td><td align="left">给出的值是具有多个值的一维数组，而不是零维数组</td></tr></tbody></table></li></ul><p>如果迭代一个可广播的数组,则迭代放回的是两个值,这两个值是广播之后两个数组的值</p><h2 id="Numpy数组操作"><a href="#Numpy数组操作" class="headerlink" title="Numpy数组操作"></a>Numpy数组操作</h2><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">reshape</td><td align="left">不改变数据的条件下修改形状</td></tr><tr><td align="left">flat</td><td align="left">数组元素迭代器</td></tr><tr><td align="left">flatten</td><td align="left">返回一份数组拷贝，对拷贝所做的修改不会影响原始数组</td></tr><tr><td align="left">ravel</td><td align="left">返回展开数组</td></tr><tr><td align="left">transpose</td><td align="left">对换数组的维度,转置</td></tr><tr><td align="left">broadcase</td><td align="left">返回一个数组对另一个数组广播的结果</td></tr><tr><td align="left">split</td><td align="left">分割数组</td></tr></tbody></table><h2 id="Numpy位运算"><a href="#Numpy位运算" class="headerlink" title="Numpy位运算"></a>Numpy位运算</h2><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">bitwise_and</td><td align="left">对数组元素执行位与操作</td></tr><tr><td align="left">bitwise_or</td><td align="left">对数组元素执行位或操作</td></tr><tr><td align="left">invert</td><td align="left">按位取反</td></tr><tr><td align="left">left_shift</td><td align="left">向左移动二进制表示的位</td></tr><tr><td align="left">right_shift</td><td align="left">向右移动二进制表示的位</td></tr></tbody></table><h2 id="Numpy数学函数"><a href="#Numpy数学函数" class="headerlink" title="Numpy数学函数"></a>Numpy数学函数</h2><p>numpy内置了pi,numpy.pi就是pi</p><ul><li>三角函数<blockquote><p>sin,cos,tan只支持弧度制<br>arcsin,arccos,arctan返回弧度制,可通过degrees转化为角度值</p></blockquote><h2 id="Numpy算术函数"><a href="#Numpy算术函数" class="headerlink" title="Numpy算术函数"></a>Numpy算术函数</h2>add,subtract,multiply,divide,对数组相应数据进行计算<h2 id="Numpy统计函数"><a href="#Numpy统计函数" class="headerlink" title="Numpy统计函数"></a>Numpy统计函数</h2></li><li>amin函数 <code>amin(array,axis)</code>没有设置axis,默认当成一维数组</li><li>amax函数 <code>amax(array,axis)</code>没有设置axis,默认是一维数组</li><li>ptp函数 <code>ptp(array,axis)</code>没有设置axis,默认为一维数组</li><li>percentile函数<code>percentile(array, q, axis)</code>,p是有 <code>p%</code> 的数据项小于或等于这个值</li><li>media函数<code>media(array,axis)</code>计算中位数</li><li>mean函数<code>mean(array,axis)</code>计算算数平均数</li><li>average函数<code>mean(array,weights,returened,axis)</code> weights需要一个权重数组,returened是返回权重和</li><li>std标准差函数,var方差函数<h2 id="Numpy-排序条件筛选函数"><a href="#Numpy-排序条件筛选函数" class="headerlink" title="Numpy 排序条件筛选函数"></a>Numpy 排序条件筛选函数</h2></li><li>sort<code>sort(a, axis, kind, order)</code> kind为排序算法种,order就是排序字段</li><li>agsort返回数组从小到大的索引值</li><li>lexsort 对多个序列进行排序,排序时优先照顾靠后的序列</li><li>msort(a)    数组按第一个轴排序，返回排序后的数组副本。np.msort(a) 相等于 np.sort(a, axis=0)。</li><li>sort_complex(a)     对复数按照先实部后虚部的顺序进行排序。</li><li>partition(a, kth[, axis, kind, order])     指定一个数，对数组进行分区</li><li>argpartition(a, kth[, axis, kind, order])     可以通过关键字 kind 指定算法沿着指定轴对数组进行分区</li><li>numpy.argmax() 和 numpy.argmin()函数分别沿给定轴返回最大和最小元素的索引。</li><li>numpy.nonzero() 函数返回输入数组中非零元素的索引。</li><li>numpy.where() 函数返回输入数组中满足给定条件的元素的索引。</li><li>numpy.extract() 函数根据某个条件从数组中抽取元素，返回满足条件的元素。<h2 id="Numpy的副本和视图"><a href="#Numpy的副本和视图" class="headerlink" title="Numpy的副本和视图"></a>Numpy的副本和视图</h2>简单来说,副本和原来的数组面对的内存不一样,视图时对原来数组的引用.</li></ul><p>视图:</p><ul><li>切片</li><li>view方法</li></ul><p>副本:</p><ul><li>deepCopy</li><li>ndarray的copy方法<h2 id="Numpy矩阵库"><a href="#Numpy矩阵库" class="headerlink" title="Numpy矩阵库"></a>Numpy矩阵库</h2></li><li>matlib.empty <code>numpy.matlib.empty(shape, dtype, order)</code> 创建一个随机填充的矩阵</li><li>matlib.zeros创建一个以 0 填充的矩阵。</li><li>matlib.ones 创建一个以1填充的矩阵</li><li>matlib.eye 创建一个对角元素为1的矩阵<code>numpy.matlib.eye(n, M,k, dtype)</code>其中n为行数,M为列数,K为对角线的索引</li><li>numpy.matlib.identity() 函数返回给定大小的单位矩阵</li><li>numpy.matlib.rand() 函数创建一个给定大小的矩阵，数据是随机填充的。<h2 id="Numpy线性代数"><a href="#Numpy线性代数" class="headerlink" title="Numpy线性代数"></a>Numpy线性代数</h2><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">dot</td><td align="left">一维就是数组对应相乘,高维数组就是两个矩阵相乘。</td></tr><tr><td align="left">vdot</td><td align="left">两个向量的点积</td></tr><tr><td align="left">inner</td><td align="left">两个数组的内积</td></tr><tr><td align="left">matmul</td><td align="left">两个数组的矩阵积</td></tr><tr><td align="left">determinant</td><td align="left">数组的行列式</td></tr><tr><td align="left">solve</td><td align="left">求解线性矩阵方程</td></tr><tr><td align="left">inv</td><td align="left">计算矩阵的乘法逆矩阵</td></tr></tbody></table><h2 id="Numpy-I-O"><a href="#Numpy-I-O" class="headerlink" title="Numpy I/O"></a>Numpy I/O</h2></li><li>numpy.save 把一个数组存成npy形式 load取出<blockquote><p><code>numpy.save(file, arr, allow_pickle=True, fix_imports=True)</code></p></blockquote></li><li>numpy.savez 把多个数组存成npy形式 load取出<blockquote><p><code>numpy.savez(file, *args, **kwds)</code></p></blockquote></li><li>numpy.savetxt 把数组存储txt形式 loadtxt取出<blockquote><p><code>savetxt(FILENAME, a, fmt=&quot;%d&quot;, delimiter=&quot;,&quot;)</code></p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模,Numpy,Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>httpx的使用</title>
      <link href="/2022/01/18/httpx%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/01/18/httpx%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 爬虫学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spider/crawler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>logism自动化填充</title>
      <link href="/2022/01/17/logism%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
      <url>/2022/01/17/logism%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>P0的grf题需要32个寄存器,面对这种需要Ctrl-c/v的工作实在是浪费时间.对此,我们需要重拳出击,正好,logism的教程文件提到了怎么自动化复制,这不来尝试一下???</p><h3 id="寻找目标元件"><a href="#寻找目标元件" class="headerlink" title="寻找目标元件"></a>寻找目标元件</h3><p>用vsc打开circ文件,看到一堆标签,如何从标签里面找到需要的文件?我提出我的一些小办法:</br></p><ol><li>使用circuitname快速寻找:使用vsc自带的搜索功能,输入你要找的元件所属的circuit的名字,快速锁定大概范围.</li><li>根据元器件名字寻找:比如grf需要寄存器,那么,寻找名字为register 的器件,对于tunnel元件,可以根据朝向来判断需要<br>找到之后,把这些标签放在一起,好统一复制<br><img src="https://img-blog.csdnimg.cn/ef16719f8a9342609f5fa83238c3f246.png" alt="logism所需的元件"><br><img src="https://img-blog.csdnimg.cn/76f7ee75ad3b4bb8991c8878a85ca357.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Luj56CB5qyh5qyh5pegYnVn77yM546v5aKD5qyh5qyh5peg5Yay56qB,size_5,color_FFFFFF,t_70,g_se,x_16" alt="对应代码"><h3 id="写代码"><a href="#写代码" class="headerlink" title="写代码"></a>写代码</h3><del>python是最好的语言</del></br><br>一通操作猛如虎,打出代码,然后尝试一下 <del>(在写代码之前建议备份一下之前的circ文件,别问我怎么知道的,在1000+行的circ里面debug太痛苦了,不如直接/remake)</del></li></ol><p><img src="https://img-blog.csdnimg.cn/d1920bf2f4334199bb322184759e9014.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Luj56CB5qyh5qyh5pegYnVn77yM546v5aKD5qyh5qyh5peg5Yay56qB,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"><br><img src="https://img-blog.csdnimg.cn/7c4357f359e14dd2b690e84cc4473376.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Luj56CB5qyh5qyh5pegYnVn77yM546v5aKD5qyh5qyh5peg5Yay56qB,size_12,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"><br>好像emmmm,应该是双重循环.<br>修改一下,下面附上最终代码</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os<span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"F:\\LOGISIM_FILES\\P0_L0_GRF.circ"</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    template <span class="token operator">=</span> <span class="token triple-quoted-string string">r"""        &lt;comp lib="0" loc="(%d,%d)" name="Tunnel">      &lt;a name="width" val="8"/>      &lt;a name="label" val="r%d_out"/>    &lt;/comp>    &lt;comp lib="4" loc="(%d,%d)" name="Register"/>    &lt;comp lib="0" loc="(%d,%d)" name="Tunnel">      &lt;a name="facing" val="north"/>      &lt;a name="label" val="clk"/>    &lt;/comp>        &lt;comp lib="0" loc="(%d,%d)" name="Tunnel">      &lt;a name="facing" val="east"/>      &lt;a name="width" val="8"/>      &lt;a name="label" val="r%d_in"/>    &lt;/comp>    &lt;comp lib="0" loc="(%d,%d)" name="Tunnel">      &lt;a name="facing" val="north"/>      &lt;a name="label" val="clr"/>    &lt;/comp>        &lt;wire from="(%d,%d)" to="(%d,%d)"/>    &lt;wire from="(%d,%d)" to="(%d,%d)"/>    &lt;wire from="(%d,%d)" to="(%d,%d)"/>    &lt;wire from="(%d,%d)" to="(%d,%d)"/>    &lt;wire from="(%d,%d)" to="(%d,%d)"/>         &lt;wire from="(%d,%d)" to="(%d,%d)"/>    &lt;wire from="(%d,%d)" to="(%d,%d)"/>    &lt;wire from="(%d,%d)" to="(%d,%d)"/>"""</span>    <span class="token comment"># startx_clr+i*stepx starty_clr+j*stepy-10    startx_clr+i*stepx starty_clr+j*stepy</span>    <span class="token comment"># startx_clr+i*stepx-10, starty_clr+j*stepy-10, startx_clr+i*stepx,starty_clr+j*stepy-10</span>    <span class="token comment"># startx_clr+i*stepx-10,starty_clr+j*stepy-20,startx_clr+i*stepx-10,sstarty_clr+j*stepy-10</span>    <span class="token comment"># startx_ri+i*stepx,starty_ri+j*stepy,startx_ri+i*stepx+20,starty_ri+j*stepy</span>    <span class="token comment"># startx_ro+i*stepx,starty_ro+j*stepy,startx_ro+i*stepx,starty_ro+j*stepy</span>    <span class="token comment">#startx_clk+i*stepx+10 starty_clk+j*stepy-20   startx_clk+i*stepx+10 starty_clk+j*stepy-10</span>    <span class="token comment">#startx_clk+i*stepx starty_clk+j*stepy-10   startx_clk+i*stepx+10 starty_clk+j*stepy-10</span>    <span class="token comment">#startx_clk+i*stepx starty_clk+j*stepy-10   startx_clk+i*stepx starty_clk+j*stepy</span>    startx_ro <span class="token operator">=</span> <span class="token number">450</span>    starty_ro <span class="token operator">=</span> <span class="token number">200</span>    type_ro <span class="token operator">=</span> <span class="token number">0</span>     startx_re <span class="token operator">=</span> <span class="token number">410</span>    starty_re <span class="token operator">=</span> <span class="token number">200</span>    startx_clk <span class="token operator">=</span> <span class="token number">380</span>    starty_clk <span class="token operator">=</span> <span class="token number">240</span>    startx_ri <span class="token operator">=</span> <span class="token number">360</span>    starty_ri <span class="token operator">=</span> <span class="token number">200</span>    type_ri <span class="token operator">=</span> <span class="token number">0</span>    startx_clr <span class="token operator">=</span> <span class="token number">410</span>    starty_clr <span class="token operator">=</span> <span class="token number">240</span>    stepx <span class="token operator">=</span> <span class="token number">300</span>    stepy <span class="token operator">=</span> <span class="token number">300</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>   template <span class="token operator">%</span> <span class="token punctuation">(</span>              startx_ro<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token punctuation">,</span> starty_ro<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token punctuation">,</span> type_ro<span class="token operator">+</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token operator">*</span>i<span class="token operator">+</span>j<span class="token punctuation">)</span><span class="token punctuation">,</span>              startx_re<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token punctuation">,</span> starty_re<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token punctuation">,</span>              startx_clk<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token punctuation">,</span> starty_clk<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token punctuation">,</span>              startx_ri<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token punctuation">,</span> starty_ri<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token punctuation">,</span> type_ri<span class="token operator">+</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token operator">*</span>i<span class="token operator">+</span>j<span class="token punctuation">)</span><span class="token punctuation">,</span>              startx_clr<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token punctuation">,</span> starty_clr<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token punctuation">,</span>               startx_clr<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token punctuation">,</span> starty_clr<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span> startx_clr<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token punctuation">,</span>starty_clr<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token punctuation">,</span>              startx_clr<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span> starty_clr<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span> startx_clr<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token punctuation">,</span>starty_clr<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span>               startx_clr<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span>starty_clr<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token operator">-</span><span class="token number">20</span><span class="token punctuation">,</span>startx_clr<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span>starty_clr<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span>               startx_ri<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token punctuation">,</span>starty_ri<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token punctuation">,</span>startx_ri<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token operator">+</span><span class="token number">20</span><span class="token punctuation">,</span>starty_ri<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token punctuation">,</span>              startx_ro<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token punctuation">,</span>starty_ro<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token punctuation">,</span>startx_ro<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token operator">-</span><span class="token number">40</span><span class="token punctuation">,</span>starty_ro<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token punctuation">,</span>              startx_clk<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">,</span>starty_clk<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token operator">-</span><span class="token number">20</span><span class="token punctuation">,</span>startx_clk<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">,</span>starty_clk<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span>              startx_clk<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token punctuation">,</span>starty_clk<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span>startx_clk<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">,</span>starty_clk<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span>              startx_clk<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token punctuation">,</span>starty_clk<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span>startx_clk<span class="token operator">+</span>i<span class="token operator">*</span>stepx<span class="token punctuation">,</span>starty_clk<span class="token operator">+</span>j<span class="token operator">*</span>stepy<span class="token punctuation">)</span>  <span class="token punctuation">)</span>    f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token triple-quoted-string string">"""     &lt;/circuit>&lt;/project>"""</span><span class="token punctuation">)</span>      <span class="token comment">#logism通过这两个标签来判断circuit是否结束,所以在找到circ所需的元件之后,将这个标签删去,这样在f.write结束后自动填上/circuit,免得自己去翻   </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果:<br><img src="https://img-blog.csdnimg.cn/4f625359661141e286f54c83f247d08e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Luj56CB5qyh5qyh5pegYnVn77yM546v5aKD5qyh5qyh5peg5Yay56qB,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"></p><p>我宣布python是世界上最好的编程语言!</p>]]></content>
      
      
      <categories>
          
          <category> logism </category>
          
      </categories>
      
      
        <tags>
            
            <tag> logisim,P0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/01/16/hello-world/"/>
      <url>/2022/01/16/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>就像万事有一个开头,对于程序员来说,<code>hello world</code>就是开始的仪式.这是<code>Hexo</code>建立的时候自带的文章,本应该删去,但还是留着当一个纪念.这个post的封面是动漫<code>Hello World</code>的海报,这俩还挺配的,就一起用了.也没啥特别意义,也算是矫情吧.那么,我的博客之旅要开始了.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式学习</title>
      <link href="/2022/01/16/regular_expression/"/>
      <url>/2022/01/16/regular_expression/</url>
      
        <content type="html"><![CDATA[<h2 id="关于正则表达式的学习笔记和总结"><a href="#关于正则表达式的学习笔记和总结" class="headerlink" title="关于正则表达式的学习笔记和总结"></a>关于正则表达式的学习笔记和总结</h2><h3 id="浅谈正则表达式"><a href="#浅谈正则表达式" class="headerlink" title="浅谈正则表达式"></a>浅谈正则表达式</h3><pre class="line-numbers language-none"><code class="language-none">我有一个问题可以用正则表达式解决，好了现在我有两个问题了<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="为什么是正则表达式"><a href="#为什么是正则表达式" class="headerlink" title="为什么是正则表达式"></a>为什么是正则表达式</h5><p>在我个人的学习经历中接触过各种字符串查找函数，但为什么正则表达式这么神奇？我觉得是它的模糊性，它的模糊性决定了查找时无关元素的影响更小，更能找到需要的内容</br><br>用一段python代码举例</br></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">str</span> <span class="token operator">=</span> <span class="token string">"abcdef"</span>res <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">.</span>find<span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这个代码能帮助你找到字符串中a这个字符，但如果换个问题，在一堆电话号码中找某一个开头的电话，或者末尾是某一片段的电话号码，那么，find函数就没这么好用了。</br>这时候，正则表达式的模糊性就能很好的得到需要的结果。</p><h5 id="正则表达式的应用范围"><a href="#正则表达式的应用范围" class="headerlink" title="正则表达式的应用范围"></a>正则表达式的应用范围</h5><p>正则表达式在java和python等语言中都有相应的包调用.在爬虫的使用中,正则表达式能很好的从一堆标签中找到你需要的某一段消息(虽然有时候在结构规整,目标不复杂的情况下,bs4有更好的效果).</p><h3 id="正则表达式规则"><a href="#正则表达式规则" class="headerlink" title="正则表达式规则"></a>正则表达式规则</h3><h4 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h4><ol><li><code>.</code> :匹配除换行符之外的任意字符</li><li><code>\w</code> :匹配字母或数字或下划线或汉字</li><li><code>\W</code> :匹配不是字母或数字或下划线或汉字的字符</li><li><code>\s</code> :匹配任意空白符</li><li><code>\S</code> :匹配任意非空白符</li><li><code>\d</code> :匹配数字</li><li><code>\D</code> :匹配非数字</li><li><code>\b</code> :匹配单词的开始或结束 如<code>&quot;er\b&quot;</code> 可以匹配never 不能匹配 very</li><li><code>\A</code> :匹配字符串开头</li><li><code>\z</code>:匹配字符串结尾,如果有换行符,则同时匹配换行符.</li><li><code>\Z</code>:匹配字符串结尾,不匹配换行符.</li><li><code>^</code> :匹配输入字符串的开始</li><li><code>$</code> :匹配输入字符串的结束<h4 id="重复限定符"><a href="#重复限定符" class="headerlink" title="重复限定符"></a>重复限定符</h4></li><li><code>*</code> 重复零次或者多次</li><li><code>+</code> 重复一次或多次</li><li><code>?</code>重复零次或一次</li><li><code>&#123;n&#125;</code> 重复n次</li><li><code>&#123;n,&#125;</code> 重复n次或者多次</li><li><code>&#123;n,m&#125;</code> 重复n次或者m次<h4 id="分组符"><a href="#分组符" class="headerlink" title="分组符"></a>分组符</h4></li><li><code>(ab)</code> 表明以字符串<code>&quot;ab&quot;</code>为一组的元素,例如: <code>&quot;^(ab)+&quot;</code>匹配以零个或者多个<code>&quot;ab&quot;</code>开头的字符串</li><li><code>[abc]</code>或者<code>[a-c]</code> 表明匹配abc中任意一个的字符  <h4 id="转义符"><a href="#转义符" class="headerlink" title="转义符"></a>转义符</h4></li><li><code>\</code> 表明将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。如:<code>&quot;(\n)&quot;</code>表示匹配\n <code>&quot;(\(ab\))+&quot;</code>表示匹配一个或者多个<code>&quot;(ab)&quot;</code>的字符<h4 id="条件符"><a href="#条件符" class="headerlink" title="条件符"></a>条件符</h4></li><li><code>|</code> 条件或,满足前者或者后者的字符,例如<code>&quot;(12)(3|4)&quot;</code>匹配<code>&quot;123&quot;</code>或者<code>&quot;124&quot;</code>的字符<h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4></li><li>正向先行断言<code>表达式1(?=pattern)</code>匹配pattern前面的表达式,不包含本身,例如下面的代码</br><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> reline <span class="token operator">=</span> <span class="token string">"&lt;div class = \"left_box\" height = 100px>"</span>pattern <span class="token operator">=</span> <span class="token string">".*(?=height)"</span>m <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>pattern<span class="token punctuation">,</span>line<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token operator">&lt;</span>div <span class="token keyword">class</span> <span class="token operator">=</span> <span class="token string">"left_box"</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>负向先行断言<code>表达式1(?!pattern)</code>匹配后面不含pattern的表达式,不包含本身,例如下面的代码</br><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> reline <span class="token operator">=</span> <span class="token string">"regular regex rlief"</span>pattern <span class="token operator">=</span> <span class="token string">r"r(\w&#123;1&#125;)(?!g)"</span>m <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>pattern<span class="token punctuation">,</span>line<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> rl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>正向后行断言<code>(?&lt;=pattern)表达式1</code>,同正向先行断言,只是匹配的是pattern后面的表达式</li><li>负向向后行断言<code>(?&lt;!pattern)表达式1</code>,同负向向先行断言,只是匹配的是pattern后面的表达式</li></ol><h4 id="懒惰-非贪婪"><a href="#懒惰-非贪婪" class="headerlink" title="懒惰(非贪婪)"></a>懒惰(非贪婪)</h4><h6 id="什么是正则表达式的贪婪"><a href="#什么是正则表达式的贪婪" class="headerlink" title="什么是正则表达式的贪婪?"></a>什么是正则表达式的贪婪?</h6><p>贪婪是指在匹配时尽可能多的匹配,如<code>\w&#123;2,9&#125;</code>则会尽量匹配9个,如果不够就匹配八个.</p><h6 id="如何做到懒惰"><a href="#如何做到懒惰" class="headerlink" title="如何做到懒惰"></a>如何做到懒惰</h6><ol><li><code>*?</code>重复0次或者无数次,从0开始匹配</li><li><code>+?</code>重复一到正无穷次,从1开始</li><li><code>??</code>重复0到1次,从0开始</li><li><code>&#123;n,m&#125;?</code> 重复n到m次,从n开始<h4 id="编号分组"><a href="#编号分组" class="headerlink" title="编号分组"></a>编号分组</h4></li><li>数字编号分组<code>&#123;表达式&#125;</code>,例如:<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> reline <span class="token operator">=</span> <span class="token string">"020-85653333"</span>pattern <span class="token operator">=</span> <span class="token string">r"(0\d&#123;2,3&#125;)-(\d&#123;8&#125;)"</span>m <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>pattern<span class="token punctuation">,</span>line<span class="token punctuation">)</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span><span class="token number">020</span><span class="token operator">-</span><span class="token number">85653333</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span><span class="token number">020</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span><span class="token number">85653333</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>命名编号捕获组<code>(?&lt;name&gt;表达式)</code>,非捕获组<code>()?:表达式</code>,不捕获(在不同语言中实现方式不同,如在python中需要添加P在?与<name>之间)<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> reline <span class="token operator">=</span> <span class="token string">"020-85653333"</span>pattern <span class="token operator">=</span> <span class="token string">r"(?P&lt;区号>0\d&#123;2,3&#125;)-(?P&lt;号码>\d&#123;8&#125;)"</span>m <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>pattern<span class="token punctuation">,</span>line<span class="token punctuation">)</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span><span class="token number">020</span><span class="token operator">-</span><span class="token number">85653333</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token string">"号码"</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span><span class="token number">020</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token string">"区号"</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span><span class="token number">85653333</span><span class="token keyword">import</span> reline <span class="token operator">=</span> <span class="token string">"020-85653333"</span>pattern <span class="token operator">=</span> <span class="token string">r"(?P&lt;区号>0\d&#123;2,3&#125;)-(?:\d&#123;8&#125;)"</span>m <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>pattern<span class="token punctuation">,</span>line<span class="token punctuation">)</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span><span class="token number">020</span><span class="token operator">-</span><span class="token number">85653333</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token string">"号码"</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span>Errorm<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token string">"区号"</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span><span class="token number">85653333</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python中re库介绍"><a href="#python中re库介绍" class="headerlink" title="python中re库介绍"></a>python中re库介绍</h3><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4></li></ol><ul><li>re.I 大小写不敏感</li><li>re.L 实现本地化识别(local-aware)匹配</li><li>re.M 多行匹配</li><li>re.S 匹配包括换行符在内的任何字符</li><li>re.U 使用Unicode字符集解析字符</li><li>re.X 该标志给予灵活格式.</li></ul><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li>search:从开头开始匹配,如果开头不匹配则失败</li><li>findall:获取匹配的所有字符串</li><li>sub:把匹配字符出从其中删去</li><li>compile:将正则表达式编译成正则表达式对象,方便之后复用</li><li>match:找到第一个匹配的字符串</li></ul><h3 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h3><p>正则表达式在线匹配网站:<code>https://c.runoob.com/front-end/854/</code></p>]]></content>
      
      
      <categories>
          
          <category> 正则表达式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>响应状态码</title>
      <link href="/2022/01/16/response_status_code/"/>
      <url>/2022/01/16/response_status_code/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th align="center">状态码</th><th align="center">状态码英文名称</th><th align="center">中文描述</th></tr></thead><tbody><tr><td align="center">100</td><td align="center">Continue</td><td align="center">继续。客户端应继续其请求</td></tr><tr><td align="center">101</td><td align="center">Switching Protocols</td><td align="center">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">200</td><td align="center">OK</td><td align="center">请求成功。一般用于GET与POST请求</td></tr><tr><td align="center">201</td><td align="center">Created</td><td align="center">已创建。成功请求并创建了新的资源</td></tr><tr><td align="center">202</td><td align="center">Accepted</td><td align="center">已接受。已经接受请求，但未处理完成</td></tr><tr><td align="center">203</td><td align="center">Non-Authoritative Information</td><td align="center">非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td align="center">204</td><td align="center">No Content</td><td align="center">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td align="center">205</td><td align="center">Reset Content</td><td align="center">重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td align="center">206</td><td align="center">Partial Content</td><td align="center">部分内容。服务器成功处理了部分GET请求</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">300</td><td align="center">Multiple Choices</td><td align="center">多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td></tr><tr><td align="center">301</td><td align="center">Moved Permanently</td><td align="center">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td align="center">302</td><td align="center">Found</td><td align="center">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td align="center">303</td><td align="center">See Other</td><td align="center">查看其它地址。与301类似。使用GET和POST请求查看</td></tr><tr><td align="center">304</td><td align="center">Not Modified</td><td align="center">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td align="center">305</td><td align="center">Use Proxy</td><td align="center">使用代理。所请求的资源必须通过代理访问</td></tr><tr><td align="center">306</td><td align="center">Unused</td><td align="center">已经被废弃的HTTP状态码</td></tr><tr><td align="center">307</td><td align="center">Temporary Redirect</td><td align="center">临时重定向。与302类似。使用GET请求重定向</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">400</td><td align="center">Bad Request</td><td align="center">客户端请求的语法错误，服务器无法理解</td></tr><tr><td align="center">401</td><td align="center">Unauthorized</td><td align="center">请求要求用户的身份认证</td></tr><tr><td align="center">402</td><td align="center">Payment Required</td><td align="center">保留，将来使用</td></tr><tr><td align="center">403</td><td align="center">Forbidden</td><td align="center">服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td align="center">404</td><td align="center">Not Found</td><td align="center">服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td></tr><tr><td align="center">405</td><td align="center">Method Not Allowed</td><td align="center">客户端请求中的方法被禁止</td></tr><tr><td align="center">406</td><td align="center">Not Acceptable</td><td align="center">服务器无法根据客户端请求的内容特性完成请求</td></tr><tr><td align="center">407</td><td align="center">Proxy Authentication Required</td><td align="center">请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td></tr><tr><td align="center">408</td><td align="center">Request Time-out</td><td align="center">服务器等待客户端发送的请求时间过长，超时</td></tr><tr><td align="center">409</td><td align="center">Conflict</td><td align="center">服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突</td></tr><tr><td align="center">410</td><td align="center">Gone</td><td align="center">客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td></tr><tr><td align="center">411</td><td align="center">Length Required</td><td align="center">服务器无法处理客户端发送的不带Content-Length的请求信息</td></tr><tr><td align="center">412</td><td align="center">Precondition Failed</td><td align="center">客户端请求信息的先决条件错误</td></tr><tr><td align="center">413</td><td align="center">Request Entity Too Large</td><td align="center">由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td></tr><tr><td align="center">414</td><td align="center">Request-URI Too Large</td><td align="center">请求的URI过长（URI通常为网址），服务器无法处理</td></tr><tr><td align="center">415</td><td align="center">Unsupported Media Type</td><td align="center">服务器无法处理请求附带的媒体格式</td></tr><tr><td align="center">416</td><td align="center">Requested range not satisfiable</td><td align="center">客户端请求的范围无效</td></tr><tr><td align="center">417</td><td align="center">Expectation Failed</td><td align="center">服务器无法满足Expect的请求头信息</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">500</td><td align="center">Internal Server Error</td><td align="center">服务器内部错误，无法完成请求</td></tr><tr><td align="center">501</td><td align="center">Not Implemented</td><td align="center">服务器不支持请求的功能，无法完成请求</td></tr><tr><td align="center">502</td><td align="center">Bad Gateway</td><td align="center">作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td></tr><tr><td align="center">503</td><td align="center">Service Unavailable</td><td align="center">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td align="center">504</td><td align="center">Gateway Time-out</td><td align="center">充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td align="center">505</td><td align="center">HTTP Version not supported</td><td align="center">服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 爬虫学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http基础</title>
      <link href="/2022/01/16/the_principle_of_HTTP/"/>
      <url>/2022/01/16/the_principle_of_HTTP/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP基本原理"><a href="#HTTP基本原理" class="headerlink" title="HTTP基本原理"></a>HTTP基本原理</h1><h2 id="1-URI-和-URL"><a href="#1-URI-和-URL" class="headerlink" title="1. URI  和  URL "></a>1.<strong> URI </strong> 和 <strong> URL </strong></h2><p>URI = URL(统一资源定位符,需要有路径) + URN(统一资源名称,只需要独一无二,例如ID card)</br><br>URL 统一格式:</br><br><code>scheme://[username:password@]hostname[:port][/path][;parameters][?query][#fragment] </code></p><h3 id="解释"><a href="#解释" class="headerlink" title="解释:"></a>解释:</h3><blockquote><p>scheme: 协议 也称protocol </br><br><strong>[username:password@]</strong>:用户名和密码<br><strong>hostname</strong>:主机地址</br><br><strong>port</strong>:端口</br><br><strong>path</strong>:路径,网络资源在服务器中的指定地址,类比操作系统中目录</br><br><strong>parameters</strong>:参数,访问资源的附加信息</br><br><strong>query</strong>:查询,查询某类资源,比如地址</br><code>https://www.baidu.com/baidu?tn=monline_3_dg&amp;ie=utf-8&amp;wd=%E4%BD%A0%E5%A5%BD%E6%9D%8E%E7%84%95%E8%8B%B1</code></br>问号后面限制了搜索引擎关键词<br>fragment:片段,对资源描述的部分补充.应用之一作为现代前端框架做路由管理,其二是HTML锚点(href = “#top”)</p></blockquote><h2 id="2-HTTP-和-HTTPS"><a href="#2-HTTP-和-HTTPS" class="headerlink" title="2. HTTP  和  HTTPS "></a>2.<strong> HTTP </strong> 和 <strong> HTTPS </strong></h2><p>HTTP只是单纯把超文本数据从网络传输到本地浏览器,HTTPS增加了SSL层,传输内容经过SSL加密.</br><br>这两个协议都是应用层协议,只负责信息传输的规范,其传输层还是TCP/IP(三次握手,四次挥手)协议,负责服务器和本地主机建立联系.</br></p><h2 id="3-HTTP-HTTPS请求过程"><a href="#3-HTTP-HTTPS请求过程" class="headerlink" title="3.HTTP/HTTPS请求过程:"></a>3.HTTP/HTTPS请求过程:</h2><p>客户端发送Request(请求),服务器收到请求进行解析,然后服务器返回Response(响应).浏览器得到响应之后进行响应解析渲染呈现.</p><h2 id="4-请求"><a href="#4-请求" class="headerlink" title="4.请求"></a>4.请求</h2><p>请求  ＝ 请求方法 + 请求网址 + 请求头 + 请求体</p><h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><p>常用<code>get</code>和<code>post</code></p><h4 id="GET方法"><a href="#GET方法" class="headerlink" title="GET方法:"></a>GET方法:</h4><blockquote><p>当输入网址按下回车的时候就已经输入了GET方法到服务器,请求参数(query)会和URL一起发给服务器.一个Get请求一次最多发送1024Byte大小数据</p></blockquote><h4 id="POST方法"><a href="#POST方法" class="headerlink" title="POST方法:"></a>POST方法:</h4><blockquote><p>当输入账号密码等需要提交表单的时候就是发送了<code>post</code>方法,参数不会包含在URL中,而是包含在请求体里面发给服务器.发送的数据没有大小要求.</p></blockquote><p>不常用方法有<code>HEAD</code>,<code>PUT</code>,<code>DELETE</code>,<code>CONNECT</code>,<code>OPTIONS</code>,<code>TRACE</code>.</p><ul><li>HEAD:类似于GET请求,但是Response中没有具体内容,用于获取响应头.</li><li>PUT: 用客户端发送给服务器的数据取代指定文档中的内容(修改操作,共享文档 <del>或许是</del> )</li><li>DELET: 请求服务器删除指定页面(类似于不使用<code>blank</code>)</li><li>CONNECT: 通过服务器代替客户端访问其他网页(<code>VPN</code>)</li><li>OPTIONS: 允许客户端查看服务器性能</li><li>TRACE: 回显服务器收到的请求,主要用于测试和诊断<h3 id="请求网址"><a href="#请求网址" class="headerlink" title="请求网址"></a>请求网址</h3>URL,不再赘述.<h3 id="请求头-headers"><a href="#请求头-headers" class="headerlink" title="请求头(headers)"></a>请求头(headers)</h3>服务器要使用的附加信息,常用来判断是否请求合法.<h4 id="常用请求头信息"><a href="#常用请求头信息" class="headerlink" title="常用请求头信息"></a>常用请求头信息</h4></li><li><strong>Accept</strong>: 请求报头域,用于指定客户端可接受哪些类型的信息 <del>(神画了一条线,说你只能在此地,不能逾越)</del> </li><li><strong>Accept-Language</strong>: 用于指定客户端的语言类型</li><li><strong>Accept-Encoding</strong>:用于指定客户端可接受的编码(常用UTF-8,也有GBK)</li><li><strong>Host</strong>:用于指定请求资源的主机IP和端口号</li><li><strong>Cookie/Cookies</strong>: 网站用于辨别用户,进行会话跟踪而存储在 <strong>用户本地</strong> 的数据.功能是 <strong>维持当前访问会话</strong>.</br><br>例如:</br>登录网站之后,客户端本地会保存服务器发来的Cookies,这样之后在网站内跳转,凭借Cookies就能保持登录状态,如果Cookies被删掉就要重新获得Cookies.(为了保证个人信息安全,请及时删除Cookies,以免病毒获得了你的Cookies,登入网站)</li><li><strong>Referer</strong>:用于标识请求是从那个页面发过来,判断访问是否合法(你不能在不进入浏览器的情况直接进入某宝的付款页面,但是正常登录就行,因为Referer不合法),以及来源统计(网站统计访问人数和来源).</li><li><strong>User-Agent/UA</strong>:帮助服务器识别客户端使用的操作系统以及版本、浏览器和版本信息.爬虫加上此头用于模仿浏览器的正常访问,如果不加,该UA就是Python.</li><li><strong>Content-Type</strong>: 也叫互联网媒体类型或者MIME类型,在HTTP中用来表示具体请求中的媒体类型信息,例如<code>text/html</code>表示<code>HTML</code>格式,<code>image/gif</code>表示<code>GIF</code>图片,<code>application/json</code>代表<code>json</code>类型<h3 id="请求体-body"><a href="#请求体-body" class="headerlink" title="请求体(body)"></a>请求体(body)</h3><a id="Content_Type_Table"></li></ul><p>在GET中为空,POSI为提交的表单信息</br></p><table><thead><tr><th align="center">Content-Type</th><th align="center">Post提交数据方式</th></tr></thead><tbody><tr><td align="center">application/x-www-form-urlencoded</td><td align="center">表单数据</td></tr><tr><td align="center">multipart/form-data</td><td align="center">表单文件上传</td></tr><tr><td align="center">application/json</td><td align="center">序列化json数据(<a href="https://baike.baidu.com/item/JSON/2462549?fr=aladdin">一种数据交换格式,本质是js对象的字符串表示方法</a>)</td></tr><tr><td align="center">text/xml</td><td align="center">xml数据(<a href="https://www.w3school.com.cn/xml/xml_intro.asp">一种可拓展标签语言,用来传递数据</a>)</td></tr></tbody></table><h2 id="5-响应"><a href="#5-响应" class="headerlink" title="5.响应"></a>5.响应</h2><h3 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h3><ul><li>状态码分类:</br></li></ul><table><thead><tr><th align="center">分类</th><th align="center">分类描述</th></tr></thead><tbody><tr><td align="center">1xx</td><td align="center">信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td align="center">2xx</td><td align="center">成功，操作被成功接收并处理</td></tr><tr><td align="center">3xx</td><td align="center">重定向，需要进一步的操作以完成请求</td></tr><tr><td align="center">4xx</td><td align="center">客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td align="center">5xx</td><td align="center">服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><ul><li>详解:</br></li><li>状态码    </li></ul><p><a href="response_status_code.md">详见响应状态码</a></p><h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h3><p>响应头包含服务器对请求的应答</p><ul><li><strong>Date</strong>:日期</li><li><strong>Last_Modified</strong>:指定资源的最后修改时间</li><li><strong>Content_Encoding</strong>:指定响应内容的编码</li><li><strong>Server</strong>:服务器信息</li><li><strong>Content_Type</strong>:文档类型,见<a href="#Content_Type_Table">请求头Content_Type对应数据类型</a></li><li><strong>Set_Cookie</strong>:服务器传给客户端的Cookies,需要在下次访问网站时携带此Cookie</li><li><strong>Expires</strong>:用于指定响应的过期时间,在此时间内浏览器可把内容写入缓存,下次直接从缓存中获得.</li></ul><h3 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h3><p>客户端对于请求返回的响应数据皆在此部分.是爬虫的爬取目标.</p><h2 id="6-HTTP2-0"><a href="#6-HTTP2-0" class="headerlink" title="6.HTTP2.0"></a>6.HTTP2.0</h2><h3 id="二进制分帧层"><a href="#二进制分帧层" class="headerlink" title="二进制分帧层"></a>二进制分帧层</h3><ul><li>帧是HTTP2.0中的概念.代表数据通信最小单位.比如请求头帧,请求体帧.</li><li>数据流:一个虚拟的双向通道,有唯一整数ID标识.</li><li>信息:与逻辑请求或响应信息对应的完整的一系列帧.</li></ul><p>HTTP2.0 将HTTP协议通信分解为二进制编码帧的交换,帧对应特定数据流中的信息,在一个TCP中复用,从而提高效率.</p><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>HTTP2.0通过讲HTTP消息分解为互不依赖的帧,交错发送,从而达到多路并行的效果(类似Pipeline),客户端再把这些帧拼接起来.</p><h3 id="流控制"><a href="#流控制" class="headerlink" title="流控制"></a>流控制</h3><p>流控制是为了防止服务器向客户端发送过量数据,客户端来不及处理.因为HTTP2.0只在一个TCP内复用,无法使用TCP自带流控制API.</br><br>为了解决这一问题,HTTP2.0提供了简单构建块.</p><ul><li>流控制具有方向性.每个接受方都能按自身需求为每个数据流甚至整个连接设置窗口大小.</li><li>流控制窗口大小是动态控制的.每个接受方都可以公布其窗口,当发送方发送DATA时窗口变小,接收方发出WINDOW_UPDATA时窗口变大.</li><li>流控制无法停止.<h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3>服务器可以对一个客户端请求发送多个数据.这个常用于发送了HTML文件之后再把CSS和JS发送过去.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 爬虫学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spider/crawler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Requests的使用</title>
      <link href="/2022/01/16/the_use_of_requests/"/>
      <url>/2022/01/16/the_use_of_requests/</url>
      
        <content type="html"><![CDATA[<h1 id="Requests的应用"><a href="#Requests的应用" class="headerlink" title="Requests的应用"></a>Requests的应用</h1><h2 id="Get请求"><a href="#Get请求" class="headerlink" title="Get请求"></a>Get请求</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requests<span class="token comment">### 添加params</span>data <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token string">'name'</span><span class="token punctuation">:</span><span class="token string">'admin'</span><span class="token punctuation">,</span>    <span class="token string">'password'</span><span class="token punctuation">:</span><span class="token string">'passward'</span><span class="token punctuation">&#125;</span><span class="token comment">### 添加headers</span>headers <span class="token operator">=</span><span class="token punctuation">&#123;</span>    <span class="token string">"Host"</span><span class="token punctuation">:</span> <span class="token string">"pss.bdstatic.com"</span><span class="token punctuation">,</span>    <span class="token string">"User-Agent"</span><span class="token punctuation">:</span> <span class="token string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:96.0) Gecko/20100101 Firefox/96.0'</span>    <span class="token string">'Accept'</span><span class="token punctuation">:</span> <span class="token string">"*/*"</span>    <span class="token string">'Accept-Language'</span><span class="token punctuation">:</span> <span class="token string">'zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2'</span>    <span class="token string">'Accept-Encoding'</span><span class="token punctuation">:</span> <span class="token string">'gzip, deflate, br'</span>    <span class="token string">'Referer'</span><span class="token punctuation">:</span> <span class="token string">'https://www.baidu.com/baidu?tn=monline_3_dg&amp;ie=utf-8&amp;wd=%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%99%BB%E5%BD%95%E5%85%A8%E6%98%AFget'</span>    <span class="token string">'Connection'</span><span class="token punctuation">:</span> <span class="token string">'keep-alive'</span>    <span class="token string">'Sec-Fetch-Dest'</span><span class="token punctuation">:</span> <span class="token string">'script'</span>    <span class="token string">'Sec-Fetch-Mode'</span><span class="token punctuation">:</span> <span class="token string">'no-cors'</span>    <span class="token string">'Sec-Fetch-Site'</span><span class="token punctuation">:</span> <span class="token string">'cross-site'</span>    <span class="token string">'Pragma'</span><span class="token punctuation">:</span> <span class="token string">'no-cache'</span>    <span class="token string">'Cache-Control'</span><span class="token punctuation">:</span> <span class="token string">'no-cache'</span>    <span class="token string">'TE'</span><span class="token punctuation">:</span> <span class="token string">'trailers'</span><span class="token punctuation">&#125;</span>response <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span>params <span class="token operator">=</span> data<span class="token punctuation">,</span>headers <span class="token operator">=</span> headers<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token comment">### 如果返回是请求头,则能以str格式或者json格式输出</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>json<span class="token punctuation">)</span><span class="token comment">### 如果返回是网页,则能使用正则表达式匹配抓取</span><span class="token keyword">import</span> re pattern <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token builtin">compile</span><span class="token punctuation">(</span><span class="token string">"&lt;h1.*?> .*?&lt;/h1>"</span><span class="token punctuation">,</span>re<span class="token punctuation">.</span>S<span class="token punctuation">)</span>title <span class="token operator">=</span> re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>pattern<span class="token punctuation">,</span>response<span class="token punctuation">.</span>txt<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>title<span class="token punctuation">)</span><span class="token comment">### 如果是视频,图片,音频,则是二进制文件,使用context</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>context<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Post请求"><a href="#Post请求" class="headerlink" title="Post请求"></a>Post请求</h2><h3 id="基本用法实例"><a href="#基本用法实例" class="headerlink" title="基本用法实例"></a>基本用法实例</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requestsurl <span class="token operator">=</span> <span class="token string">''</span><span class="token comment">## </span>data <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token string">'name'</span><span class="token punctuation">:</span><span class="token string">'admin'</span><span class="token punctuation">,</span>    <span class="token string">'password'</span><span class="token punctuation">:</span><span class="token string">'passward'</span><span class="token punctuation">&#125;</span><span class="token comment">## 设置headers</span>headers <span class="token operator">=</span><span class="token punctuation">&#123;</span>    <span class="token string">"Host"</span><span class="token punctuation">:</span> <span class="token string">"pss.bdstatic.com"</span><span class="token punctuation">,</span>    <span class="token string">"User-Agent"</span><span class="token punctuation">:</span> <span class="token string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:96.0) Gecko/20100101 Firefox/96.0'</span>    <span class="token string">'Accept'</span><span class="token punctuation">:</span> <span class="token string">"*/*"</span>    <span class="token string">'Accept-Language'</span><span class="token punctuation">:</span> <span class="token string">'zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2'</span>    <span class="token string">'Accept-Encoding'</span><span class="token punctuation">:</span> <span class="token string">'gzip, deflate, br'</span>    <span class="token string">'Referer'</span><span class="token punctuation">:</span> <span class="token string">'https://www.baidu.com/baidu?tn=monline_3_dg&amp;ie=utf-8&amp;wd=%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%99%BB%E5%BD%95%E5%85%A8%E6%98%AFget'</span>    <span class="token string">'Connection'</span><span class="token punctuation">:</span> <span class="token string">'keep-alive'</span>    <span class="token string">'Sec-Fetch-Dest'</span><span class="token punctuation">:</span> <span class="token string">'script'</span>    <span class="token string">'Sec-Fetch-Mode'</span><span class="token punctuation">:</span> <span class="token string">'no-cors'</span>    <span class="token string">'Sec-Fetch-Site'</span><span class="token punctuation">:</span> <span class="token string">'cross-site'</span>    <span class="token string">'Pragma'</span><span class="token punctuation">:</span> <span class="token string">'no-cache'</span>    <span class="token string">'Cache-Control'</span><span class="token punctuation">:</span> <span class="token string">'no-cache'</span>    <span class="token string">'TE'</span><span class="token punctuation">:</span> <span class="token string">'trailers'</span><span class="token punctuation">&#125;</span><span class="token comment">##</span>response <span class="token operator">=</span> requests<span class="token punctuation">.</span>post<span class="token punctuation">(</span>url<span class="token punctuation">,</span>data <span class="token operator">=</span> data<span class="token punctuation">,</span> headers <span class="token operator">=</span> headers<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>status_code<span class="token punctuation">)</span><span class="token comment">##状态码</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>headers<span class="token punctuation">)</span><span class="token comment">##响应头</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>cookies<span class="token punctuation">)</span><span class="token comment">##cookie</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>url<span class="token punctuation">)</span><span class="token comment">##url</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>history<span class="token punctuation">)</span><span class="token comment">##请求你是</span><span class="token comment">## requests内置了状态码,比如 requests.codes,ok 就是 statsus_code 200</span>exit<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token keyword">not</span> response<span class="token punctuation">.</span>status_code <span class="token operator">==</span> requests<span class="token punctuation">.</span>codes<span class="token punctuation">.</span>ok <span class="token keyword">else</span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Successful"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requestsfiles <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">'file'</span><span class="token punctuation">:</span><span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"filepath"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>response <span class="token operator">=</span> requests<span class="token punctuation">.</span>post<span class="token punctuation">(</span>url<span class="token punctuation">,</span>files <span class="token operator">=</span> files<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Cookie设置"><a href="#Cookie设置" class="headerlink" title="Cookie设置"></a>Cookie设置</h4><pre class="line-numbers language-none"><code class="language-none">import requestsclass Spider:    def __init__(self,CookieJar):        self.cookies &#x3D; Requests.cookies.RequestsCookieJar() ## 创建一个Cookiejar类    def Update(cookies):        self.cookies.updata(cookies)    def Crawler_get(url)        self.response &#x3D; requests.get(url,cookies &#x3D; self.cookies)##r &#x3D; requests.get(url)print(r.cookies) ## cookies 属于RequestsCookieJar类型for key,values in r.cookies.items(): ##用items方法返回一个由Cookie组成的元组    print(key + &quot;:&quot; + values)## 使用Cookie去访问网站MySpider &#x3D; Spider()          ## 创捷Spider对象MySpider.Update(r.cookies)   ## 更新cookiesMySpider.Crawler_get(url)    ## 获取开始爬<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Session维持"><a href="#Session维持" class="headerlink" title="Session维持"></a>Session维持</h4><p><code>Session</code>维持能保证两次请求的时候都是同一个账户,并且不需要手动保持<code>Cookie</code>,显得更为方便.其主要模拟同一个浏览器访问同一个站点的不同页面.</p><p>下面举例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requestsrequests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'https://www.httpbin.org/cookies/set/number/123456789'</span><span class="token punctuation">)</span> <span class="token comment">##这个网址能设置cookies</span>response <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'http://www.httpbin.org/cookies'</span><span class="token punctuation">)</span> <span class="token comment">##访问这个网址能获取自己的请求头,这里是返回自己的cookies</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>text<span class="token punctuation">)</span> <span class="token comment">##这里面不会有之前这是的cookies</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requestss <span class="token operator">=</span> requests<span class="token punctuation">.</span>Session<span class="token punctuation">(</span><span class="token punctuation">)</span>s<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'https://www.httpbin.org/cookies/set/number/123456789'</span><span class="token punctuation">)</span>response <span class="token operator">=</span> s<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'http://www.httpbin.org/cookies'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>text<span class="token punctuation">)</span> <span class="token comment">###这里返回了cookies</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="SSL证书验证"><a href="#SSL证书验证" class="headerlink" title="SSL证书验证"></a>SSL证书验证</h4><p>有些网站可能没有设置好HTTPS证书,或者其证书没有被CA认证,那么访问的时候就会出现SSL证书错误异常,那么就需要让爬虫自动处理.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requestsresponse <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>verify <span class="token operator">=</span> <span class="token boolean">False</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>status_code<span class="token punctuation">)</span><span class="token comment">##这里能输出200,但是会有一个warning,让我们指定证书,我们可以设置忽略</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如下</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requests<span class="token keyword">from</span> requests<span class="token punctuation">.</span>packages<span class="token punctuation">.</span>md <span class="token keyword">import</span> urllib3urllib3<span class="token punctuation">.</span>disable_warnings<span class="token punctuation">(</span><span class="token punctuation">)</span>response <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>verify <span class="token operator">=</span> <span class="token boolean">False</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>status_code<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者我们可以把警告捕获到日志,从而忽略</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> logging<span class="token keyword">import</span> requestslogging<span class="token punctuation">.</span>CaptureWarnings<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>response <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>verify <span class="token operator">=</span> <span class="token boolean">False</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>status_code<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然也可以设置本地证书用作客户端证书,可以是单个文件,也可以是包含两个文件路径的元组</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requestsresponse <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>cert <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'/path/server.crt'</span><span class="token punctuation">,</span><span class="token string">'/path/server.key'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>status_code<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="超时设置"><a href="#超时设置" class="headerlink" title="超时设置"></a>超时设置</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requestsresponse <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>timeout <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h4><p><code>urllib</code>中有<code>HTTPBasicAuthHandler</code>来处理身份验证问题,那么同样的<code>requests</code>中也有相应的库来处理.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requests<span class="token keyword">from</span> requests<span class="token punctuation">.</span>auth <span class="token keyword">import</span> HTTPBasicAuthr <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>auth <span class="token operator">=</span> HTTPBasicAuth<span class="token punctuation">(</span><span class="token string">"admin"</span><span class="token punctuation">,</span><span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">##或者</span>r <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>auth <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"admin"</span><span class="token punctuation">,</span><span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>status_code<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外,<code>requests</code>还提供了其他认证方式,比如<code>oa</code>验证,提供了<code>OAuth</code>,需要安装<code>oauth</code>包.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requests<span class="token punctuation">.</span>oauthlib <span class="token keyword">import</span> OAuth1<span class="token keyword">import</span> requestauth <span class="token operator">=</span> OAuth1<span class="token punctuation">(</span><span class="token string">'Your_App_Key'</span><span class="token punctuation">,</span><span class="token string">'You_App_Secret'</span><span class="token punctuation">,</span><span class="token string">'User_Oauth_Token'</span><span class="token punctuation">,</span><span class="token string">'User_Oauth_Token_Secret'</span><span class="token punctuation">)</span>response <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">.</span>auth <span class="token operator">=</span> auth<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a>代理设置</h4><p><code>urllib</code>中有<code>ProxyHandler</code>来处理身份验证问题,那么同样的<code>requests</code>中也有相应的库来处理.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requestsproxies <span class="token operator">=</span> <span class="token punctuation">&#123;</span>        <span class="token string">'http'</span><span class="token punctuation">:</span><span class="token string">'http://'</span>        <span class="token string">'https'</span><span class="token punctuation">:</span><span class="token string">'https://'</span><span class="token punctuation">&#125;</span>requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>proxies <span class="token operator">=</span> proxies<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果需要身份验证,那么,可以使用类似<code>http://user:password@host:port</code>的形式设置代理.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requestsproxies <span class="token operator">=</span> <span class="token punctuation">&#123;</span>        <span class="token string">'http'</span><span class="token punctuation">:</span><span class="token string">'http://user:password@'</span>        <span class="token string">'https'</span><span class="token punctuation">:</span><span class="token string">'https://user:password@'</span><span class="token punctuation">&#125;</span>requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>proxies <span class="token operator">=</span> proxies<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Requests库的实现浅尝"><a href="#Requests库的实现浅尝" class="headerlink" title="Requests库的实现浅尝"></a>Requests库的实现浅尝</h3><p>实际上,在使用requests库的时候,他是在内部构造了一个Request对象,并给这个对象各种参数,再把这个Request对象发送出去,请求成功之后再返回Response对象.</p><p>这个Request对象是Prepare Request类型</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> requests <span class="token keyword">import</span> Request<span class="token punctuation">,</span>Sessionurl <span class="token operator">=</span> <span class="token string">''</span>data <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">''</span><span class="token punctuation">:</span><span class="token string">''</span><span class="token punctuation">&#125;</span>headers <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">''</span><span class="token punctuation">:</span><span class="token string">''</span><span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">:</span><span class="token string">''</span><span class="token punctuation">&#125;</span>s <span class="token operator">=</span> Session<span class="token punctuation">(</span><span class="token punctuation">)</span>req <span class="token operator">=</span> Request<span class="token punctuation">(</span><span class="token string">'POST'</span><span class="token punctuation">,</span>url<span class="token punctuation">,</span>data<span class="token operator">=</span> data<span class="token punctuation">,</span>headers <span class="token operator">=</span> headers<span class="token punctuation">)</span> <span class="token comment">##创建了一个request对象</span>prepped <span class="token operator">=</span> s<span class="token punctuation">.</span>prepare_request<span class="token punctuation">(</span>req<span class="token punctuation">)</span> <span class="token comment">##把request对象转换为一个prepare_request对象</span>r <span class="token operator">=</span> s<span class="token punctuation">.</span>send<span class="token punctuation">(</span>prepped<span class="token punctuation">)</span><span class="token comment">##把prepare_request对象发送出去,获得其response对象</span><span class="token keyword">print</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 爬虫学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spider/crawler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫基础</title>
      <link href="/2022/01/16/the_principle_of_crawler/"/>
      <url>/2022/01/16/the_principle_of_crawler/</url>
      
        <content type="html"><![CDATA[<h1 id="一、爬虫的基本原理"><a href="#一、爬虫的基本原理" class="headerlink" title="一、爬虫的基本原理"></a>一、爬虫的基本原理</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>爬虫就是假装浏览器爬取网页并获取信息.</p><h2 id="爬取数据类型"><a href="#爬取数据类型" class="headerlink" title="爬取数据类型"></a>爬取数据类型</h2><ul><li>最常见的就是爬虫能爬取JSON形式的HTML代码.</li><li>对于js,css等文件,需分析源代码后台Ajax接口,或者使用<code>Selenium</code>,<code>Splash</code>,<code>Pyppeteer</code>,<code>Playwright</code>等库来模拟js渲染.<h1 id="二、Session-和-Cookie"><a href="#二、Session-和-Cookie" class="headerlink" title="二、Session 和 Cookie"></a>二、Session 和 Cookie</h1><h2 id="无状态HTTP-查询wink状态"><a href="#无状态HTTP-查询wink状态" class="headerlink" title="无状态HTTP (#查询wink状态)"></a>无状态HTTP <del>(#查询wink状态)</del></h2>HTTP对无状态表示HTTP协议对于事务处理没有记忆能力,也就是说服务器并不知道客户端处于什么状态.这意味着如果需要处理前面的信息,客户端必须重传,造成资源浪费.所以,服务器端会保存一个<code>Session</code>,客户端保存一个<code>Cookie</code>,通过这两个凭证,服务器才能做出相应响应.<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2>Web中,Session对象用来存储特定用户是所需的属性和配置信息.这样用户再响应的网页跳转时,存储在Session中的信息不丢失.如果Session过期或者没有Session,服务器会创建一个Session.<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2>见<a href="the_principle_of_HTTP.md">HTTP原理</a><h2 id="Session维持"><a href="#Session维持" class="headerlink" title="Session维持"></a>Session维持</h2>客户端第一次请求服务器的时候,服务器会返回一个<code>Set_Cookie</code>.客户端保存响应字符串,并在之后的请求中带上<code>Cookie</code>.<code>Cookie</code>中保存着响应的<code>SessionID</code>,服务器通过查询<code>SessionID</code>来找到对应<code>Session</code>,进而判断用户状态.<h2 id="Cookie的属性结构"><a href="#Cookie的属性结构" class="headerlink" title="Cookie的属性结构"></a>Cookie的属性结构</h2>在浏览器中打开<code>Application</code>选项卡,<code>Storage</code>最后一项就是<code>Cookie</code>.</li><li><strong>Name</strong>: <code>Cookie</code>名称</li><li><strong>Value</strong>:<code>Cookie</code>的值,如果是<code>Unicode</code>字符则需要字符编码,如果是二进制数据,则是<code>BASE64</code>编码.</li><li><strong>Domain</strong>:指定可以访问该<code>Cookie</code>的域名.表示该<code>Cookie</code>的可用范围.</li><li><strong>Path</strong>:<code>Cookie</code>的使用路径.如果是/path/,则表示只在该路径可用,如果是/则表示在该<code>Domain</code>下都可用.</li><li><strong>Size</strong>:表示<code>Cookie</code>的大小.</li><li><strong>HTTP</strong>:<code>Cookie</code>的<code>httponly</code>属性,如果是<code>True</code>,则表示只有在<code>HTTP Headers</code>中才含有此<code>Cookie</code>,而不能使用<code>document.cookie</code>来访问此<code>Cookie</code>.</li><li><strong>Secure</strong>:是否允许使用安全协议传输<code>Cookie</code>.<h2 id="会话Cookie和持久Cookie"><a href="#会话Cookie和持久Cookie" class="headerlink" title="会话Cookie和持久Cookie"></a>会话Cookie和持久Cookie</h2>会话<code>Cookie</code>和持久<code>Cookie</code>本质只是Cookie存储的位置不同,一个是存在缓存,一个是存在硬盘.持久<code>Cookie</code>的有效期很久,所以可以在下次登录的时候直接使用硬盘中的<code>Cookie</code>.<h1 id="三、代理的基本原理"><a href="#三、代理的基本原理" class="headerlink" title="三、代理的基本原理"></a>三、代理的基本原理</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2>代理本名代理服务器(<code>Proxy Server</code>),功能是代网络用户获得信息.客户端把请求发给代理服务器,代理服务器再把请求发给服务器.响应在经过代理服务器返回给客户端.在这个过程中服务器接受到的是代理服务器的<code>IP</code>.<h2 id="代理的作用"><a href="#代理的作用" class="headerlink" title="代理的作用"></a>代理的作用</h2></li><li>突破IP访问限制,访问一些访问不到的站点 <del>(科学上网)</del></li><li>访问一些单位或者团队的内部资源 (校园VPN)</li><li>提高访问速度.代理服务器一般都有一个较大的硬盘缓冲区,可以保存数据.如果其他用户访问,可以直接把这些数据给用户(类似<code>cache</code>)</li><li>隐藏真实的IP,保护个人信息.<h2 id="爬虫代理"><a href="#爬虫代理" class="headerlink" title="爬虫代理"></a>爬虫代理</h2>爬虫爬取速度过快,服务器检测到一个IP地址行为异常会直接封锁IP.使用代理,爬虫就会认为是代理服务器在访问自己,通过切换代理就能防止被发现.<h2 id="代理分类"><a href="#代理分类" class="headerlink" title="代理分类"></a>代理分类</h2><h3 id="根据协议区分"><a href="#根据协议区分" class="headerlink" title="根据协议区分"></a>根据协议区分</h3></li><li>FTP代理,访问FTP服务器,主要端口是21和2121</li><li>HTTP代理 访问HTTP服务器,主流的代理,端口是80和8080</li><li>SSL/TLS代理 主要访问加密网站,一般有SSL和TLS加密功能,端口一般是443</li><li>RTSP代理 主要用于Realplayer访问Real流服务器,端口一般是554</li><li>Telnet代理 主要用于Telnet远程控制(黑客Ddos攻击时隐藏身份),一般端口时23</li><li>POP3/SMTP代理 主要用于以POP3/SMTP发送邮件,具有缓存功能,端口一般是110/25</li><li>SOCKS代理 单纯传递数据包,不关心协议和用法,一般有缓存功能,端口一般是1080.SOCK代理分为SOCKS4和SOCKS5.SOCKS4只支持TCP,SOCKS支持TCP和UDP,还支持身份验证机制,服务器端域名解析等.<h3 id="根据匿名程度区分"><a href="#根据匿名程度区分" class="headerlink" title="根据匿名程度区分"></a>根据匿名程度区分</h3></li><li>高度匿名代理 将数据包原封不动转发,在服务端看来就是一个普通客户端,记录的是代理的IP</li><li>普通匿名代理 会对数据包做一些处理,服务端可能发现这是一个代理,然后追查客户端的真实IP.这种代理通常会加入的HTTP头有HTTP_VIA,HTTP_X_FORWARDED_FOR</li><li>透明代理 该种代理不仅会更改数据包,还会告诉服务器真实IP,主要用于过滤数据包,常用于内网防火墙.</li><li>间谍代理 常见于组织或者个人创建的代理服务器,用于记录用户传输的数据,然后对传输数据进行研究和监控.<h3 id="常见代理设置"><a href="#常见代理设置" class="headerlink" title="常见代理设置"></a>常见代理设置</h3></li><li>网上的免费代理,建议全部抓取下来一个个筛选,然后维护代理池.</li><li>付费代理</li><li>ADSL拨号,昂贵但是稳定性高</li><li>蜂窝代理 即使用4G/5G网卡等制作的代理.该代理情形较小,封锁概念低,但是成本高.<h1 id="四、多线程和多进程的基本原理"><a href="#四、多线程和多进程的基本原理" class="headerlink" title="四、多线程和多进程的基本原理"></a>四、多线程和多进程的基本原理</h1><h2 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h2>进程可以理解为独立运行的程序单位.比如打开浏览器.<br>线程是进程中的多个任务,比如浏览器打开之后访问网址,加载网页,看视频能同时进行.这就是多线程<h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2></li><li>并发:指多个线程对应的多条指令被快速轮换地执行.人宏观上感受不到进程切换,感觉是一起执行</li><li>并行:指同一时刻有多条指令在多个处理器上同时执行.宏观和微观上都是并行.<h2 id="多线程的爬虫应用场景"><a href="#多线程的爬虫应用场景" class="headerlink" title="多线程的爬虫应用场景"></a>多线程的爬虫应用场景</h2>爬虫在向服务器发送请求等待响应的时间内可以处理其他线程.<h2 id="Python中的多线程"><a href="#Python中的多线程" class="headerlink" title="Python中的多线程"></a>Python中的多线程</h2>Python中GIL(Global Interpreter Lock)的限制导致同一时刻下只可能进行一个线程,无法发挥多核并行的优势.所以不可能并行,只能并发.<h3 id="Python多线程下每个线程的执行方式"><a href="#Python多线程下每个线程的执行方式" class="headerlink" title="Python多线程下每个线程的执行方式:"></a>Python多线程下每个线程的执行方式:</h3></li><li>获取GIL</li><li>执行代码</li><li>释放GIL<br>Python多进程效果强于多线程.因为每一个进程都有自己的GIL,互不干扰.而多线程需要频繁切换GIL,反而减慢速度.</br><br>可见大佬博客学习</br><blockquote><p>python多线程:<a href="https://cuiqingcai.com/3325.html">https://cuiqingcai.com/3325.html</a></br><br>python多进程:<a href="https://cuiqingcai.com/3335.html">https://cuiqingcai.com/3335.html</a></br></p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 爬虫学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spider/crawler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>urllib的使用</title>
      <link href="/2022/01/16/the_use_of_urllib/"/>
      <url>/2022/01/16/the_use_of_urllib/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是python自带的爬虫相关模块,但市面上有更好的BeautifulSoup模块和requests模块.如果是速成爬虫直接学习那两个模块用法即可,但requests模块是使用urllib搭建而成,如果时间不急,可以从底层看起.</br></p><h1 id="urllib的使用"><a href="#urllib的使用" class="headerlink" title="urllib的使用"></a>urllib的使用</h1><p>基本模块:</p><ul><li><strong>request</strong>:HTTP请求模块</li><li><strong>error</strong>:异常处理模块</li><li><strong>parse</strong>:工具模块,提供url处理方法</li><li><strong>robotparser</strong>:识别网站的robot.txt文件<h2 id="requset模块"><a href="#requset模块" class="headerlink" title="requset模块"></a>requset模块</h2><h3 id="urlopen"><a href="#urlopen" class="headerlink" title="urlopen"></a>urlopen</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> urllib<span class="token punctuation">.</span>requsetresponse <span class="token operator">=</span> urlib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>url<span class="token punctuation">,</span>data<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span><span class="token punctuation">[</span>timeout<span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">,</span>cafile<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>capath<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>cadefault<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>context<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><strong ><font face = "仿宋"  size = 4 >参数解释</font></strong ></li><li>url: 网页地址</li><li>data: <code>bytes</code>类型的字节流编码<blockquote><p><code>data = bytes(urllib.parse.urlencode(&#123;&#39;username&#39;:&#39;admin&#39;&#125;),encoding = &quot;utf-8&quot;)</code></p></blockquote></li><li>timeout:超时时间设置,单位秒.</li><li>其他参数:<blockquote><p>context:接受ssl.SSLContext类,用来设置SSL</br><br>cafile/capath:设置CA证书和其路径,请求https链接有用</br><br>cadefault:已经弃用</br></p></blockquote></li></ul><h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> urllib<span class="token punctuation">.</span>requestrequest <span class="token operator">=</span> urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>Request<span class="token punctuation">(</span>url<span class="token punctuation">)</span>response <span class="token operator">=</span> urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>Request</code>使用<code>Request</code>对象传给<code>urlopen</code>,可读性更高,封装更好.</p><h4 id="Request构造"><a href="#Request构造" class="headerlink" title="Request构造"></a>Request构造</h4><pre class="line-numbers language-none"><code class="language-none">request &#x3D; urllib.request.Request(url,data&#x3D;None,headers&#x3D;&#123;&#125;,origin_req_host&#x3D;None,unverifiable&#x3D;False,method&#x3D;None)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>url:同urlopen</li><li>data:同urlopen</li><li>headers:传一个字典参数,作为请求头</li><li>origin_req_host:请求方的host名称或者IP地址</li><li>unverifiable:表示请求是否是无法验证的,默认为<code>False</code>,表示用户没有足够的权限来接受这个请求的结果</li><li>method:字符串参数,表示请求方法,如GET,POST,PUT,DELETE<h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3>request的高级用法依托<code>Handler</code>实现.<br>首先是所有<code>Handler</code>的父类<code>BaseHandler</code>,其提供了基本方法,如default_open,protocol_request等<br>其几个子类如下<blockquote><ul><li><strong>HTTPDefaultErrorHandler</strong>:用于处理<code>HTTP</code>响应错误,所有错误都会抛出<code>HTTPError</code>类型的异常</li><li><strong>HTTPRedirectHandler</strong>:用于处理重定向</li><li><strong>HTTPCookieProcessor</strong>:用于处理Cookie</li><li><strong>ProxyHandler</strong>:用于设置代理,代理默认为空</li><li><strong>HTTPPasswordMgr</strong>:用于密码管理,维护者用户名密码对照表</li><li><strong>HTTPBasicAuthHandler</strong>:用于管理认证,如果一个链接在打开的时候需要认证,那么可以用这个解决认证问题.</li></ul></blockquote></li></ul></br><p>另外一个比较重要的类是<code>OpenerDirector</code>,简称Opener.之前的<code>urlopen</code>方法就是一个<code>Opener</code>.<code>Request</code>类和<code>urlopen</code>类都是已经封装好的常用请求方法,如果需要高级用法则需要使用更加底层的实例来完成操作.</br><br><code>Opener</code>类提供<code>Open</code>方法,该方法的返回的响应类型和<code>urlopen</code>方法一致.<code>Opener</code>类需要使用<code>Handler</code>类来构建.<br></br></p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>在访问一些服务器的时候,有些网页需要用户输入账号密码进行身份验证.这就是<code>HTTP Basic Access Authentication</code>.</br><br>爬虫借助<code>HTTPBasicAuthHandler</code>模块就能完成身份验证.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> urllib<span class="token punctuation">.</span>request <span class="token keyword">import</span> HTTPPasswordMgrWithDefaultRealm<span class="token punctuation">,</span> HTTPBasicAuthHandler<span class="token punctuation">,</span> build_opener<span class="token keyword">import</span> urllib<span class="token punctuation">.</span>errorusername <span class="token operator">=</span> <span class="token string">'admin'</span>password <span class="token operator">=</span> <span class="token string">'password'</span>url <span class="token operator">=</span> <span class="token string">''</span>p <span class="token operator">=</span> HTTPPasswordMgrWithDefaultRealm<span class="token punctuation">(</span><span class="token punctuation">)</span> p<span class="token punctuation">.</span>addpassword<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">,</span>url<span class="token punctuation">,</span>username<span class="token punctuation">,</span>password<span class="token punctuation">)</span> <span class="token comment">##这个类是构建　用户名和密码　对一个地址的映射，这个映射可以是　url 也可以是 proxy </span>auth_handler <span class="token operator">=</span> HTTPBasicAuthHandler<span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token comment">## HTTPBasicAuthHandler的构造方法需要提供一个HTTPPasswordMgr(密码管理 Password Management Object) 对象 如果不知道域/对域不需要关心,就使用 HTTPPasswordMgrwithDefaultRealm 对象,使用None作为构造参数,知道的话就使用realm代替None </span>opener <span class="token operator">=</span> build_opener<span class="token punctuation">(</span>auth_handler<span class="token punctuation">)</span> <span class="token comment">## 构建了一个opener,可以使用这个opener去open url.如果这个opener是 网页验证,那么就是open url,如果是 代理验证,那么访问的时候,就是使用代理ip帮你访问(相当于Request封装再更底层)</span><span class="token keyword">try</span><span class="token punctuation">:</span>    result <span class="token operator">=</span> opener<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>    html <span class="token operator">=</span> result<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span><span class="token keyword">except</span> URLError <span class="token keyword">as</span> e<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>reason<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>代理的逻辑同验证一样,先使用ProxyHandler建立代理,再使用build_opener方法建立opener,再使用这个opener打开你需要的web</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> urllib<span class="token punctuation">.</span>requset <span class="token keyword">import</span> ProxyHandler<span class="token punctuation">,</span> build_opener<span class="token punctuation">,</span> <span class="token keyword">from</span> urllib<span class="token punctuation">.</span>error <span class="token keyword">import</span> URLErrorproxy_Handler <span class="token operator">=</span> ProxyHandler<span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token string">'http'</span><span class="token punctuation">:</span><span class="token string">'http://'</span><span class="token punctuation">,</span>                             <span class="token string">'https'</span><span class="token punctuation">:</span><span class="token string">'https://'</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token comment">## ProxyHandler类的构造需要一个字典</span>opener <span class="token operator">=</span> build_opener<span class="token punctuation">(</span>proxy_Handler<span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">:</span>    response <span class="token operator">=</span> opener<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">except</span> URLError <span class="token keyword">as</span> e<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>reason<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是如果碰到了代理验证的话,那么还是需要使用HTTPBasicAuthHandler</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> urllib<span class="token punctuation">.</span>request <span class="token keyword">import</span> HTTPPasswordMgrWithDefaultRealm<span class="token punctuation">,</span> HTTPBasicAuthHandler<span class="token punctuation">,</span> build_opener<span class="token keyword">import</span> urllib<span class="token punctuation">.</span>errorusername <span class="token operator">=</span> <span class="token string">'admin'</span>password <span class="token operator">=</span> <span class="token string">'password'</span>proxyserver <span class="token operator">=</span> <span class="token string">"61.158.163.130:16816"</span> <span class="token operator">//</span> 此时代理地址直接使用IP地址的字符串url <span class="token operator">=</span> <span class="token string">''</span>p <span class="token operator">=</span> HTTPPasswordMgrWithDefaultRealm<span class="token punctuation">(</span><span class="token punctuation">)</span> p<span class="token punctuation">.</span>addpassword<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">,</span>proxyserver<span class="token punctuation">,</span>username<span class="token punctuation">,</span>password<span class="token punctuation">)</span> <span class="token comment">##这个类是构建　用户名和密码　对代理地址的映射</span>auth_handler <span class="token operator">=</span> HTTPBasicAuthHandler<span class="token punctuation">(</span>p<span class="token punctuation">)</span> opener <span class="token operator">=</span> build_opener<span class="token punctuation">(</span>auth_handler<span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">:</span>    result <span class="token operator">=</span> opener<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>    html <span class="token operator">=</span> result<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span><span class="token keyword">except</span> URLError <span class="token keyword">as</span> e<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>reason<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>获取网站的Cookie,就是根据网站的响应头里面的 Set_Cookie的值来设置Cookie.</br><br>思路是构建CookieJar对象,再用这个对象创建opener,用这个opener打开网站,其响应的cookie会自动给CookieJar对象,通过直接访问CookieJar对象来获得Cookie.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> urlib<span class="token punctuation">.</span>request <span class="token keyword">import</span> HTTPCookieProcessor<span class="token punctuation">,</span>build_opener<span class="token keyword">from</span> http<span class="token punctuation">.</span>cookiejar <span class="token keyword">import</span> CookieJarcookie <span class="token operator">=</span> CookieJar<span class="token punctuation">(</span><span class="token punctuation">)</span>handler <span class="token operator">=</span> HTTPCookieProcessor<span class="token punctuation">(</span>cookie<span class="token punctuation">)</span>opener <span class="token operator">=</span> build_opener<span class="token punctuation">(</span>handler<span class="token punctuation">)</span>response <span class="token operator">=</span> opener<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token keyword">for</span> items <span class="token keyword">in</span> cookie<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">':'</span> <span class="token operator">+</span> item<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果需要保存cookie的话,那么需要使用MozillaCookieJar.它是CookieJar的子类,专门用于处理Cookie,比如Cookie的读取和保存,其将Cookie保存为Mozilla浏览器类型的Cookie,也就是在请求头中看到的格式.</br></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> urlib<span class="token punctuation">.</span>request <span class="token keyword">import</span> HTTPCookieProcessor<span class="token punctuation">,</span>build_opener<span class="token keyword">from</span> http<span class="token punctuation">.</span>cookiejar <span class="token keyword">import</span> MozillaCookieJarfilename <span class="token operator">=</span> <span class="token string">'cookie.txt'</span>cookie <span class="token operator">=</span> MozillaCookieJar<span class="token punctuation">(</span>filename<span class="token punctuation">)</span>handler <span class="token operator">=</span> HTTPCookieProcessor<span class="token punctuation">(</span>cookie<span class="token punctuation">)</span>opener <span class="token operator">=</span> build_opener<span class="token punctuation">(</span>handler<span class="token punctuation">)</span>response <span class="token operator">=</span> opener<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>cookie<span class="token punctuation">.</span>save<span class="token punctuation">(</span>ignore_discard <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">,</span>ignore_expires <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token comment">## ignore_discard 及时被弃用也将其保存下来,ignore_expires 及时已经过期也将其保存</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样的,如果是LWP(<code>libwww-perl</code>)格式,则使用</p><pre class="line-numbers language-none"><code class="language-none">cookie &#x3D; LWPCookieJar(filename)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那么,如何读取利用cookie?.下面是代码</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> urllib<span class="token punctuation">.</span>request <span class="token keyword">import</span> HTTPCookieProcessor<span class="token punctuation">,</span>build_opener<span class="token keyword">from</span> http<span class="token punctuation">.</span>cookiejar <span class="token keyword">import</span> MozillaCookieJarcookie <span class="token operator">=</span> CookieJar<span class="token punctuation">(</span><span class="token punctuation">)</span>cookie<span class="token punctuation">.</span>load<span class="token punctuation">(</span><span class="token string">"cookie.txt"</span><span class="token punctuation">,</span>ignore_discard <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">,</span>ignore_expires <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">)</span>handler <span class="token operator">=</span> HTTPCookieProcessor<span class="token punctuation">(</span>cookie<span class="token punctuation">)</span>opener <span class="token operator">=</span> build_opener<span class="token punctuation">(</span>handler<span class="token punctuation">)</span>response <span class="token operator">=</span> opener<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p><code>urllib.error</code>定义了<code>urllib.request</code>库产生的异常</p><h3 id="URLError"><a href="#URLError" class="headerlink" title="URLError"></a>URLError</h3><p><code>URLError</code>来自<code>urllib.error</code>库,继承于<code>OSError</code>,是<code>urllib.error</code>异常模块的基类.它具有一个reason属性,返回错误原因.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> urllib<span class="token punctuation">.</span>error<span class="token keyword">try</span><span class="token punctuation">:</span>    result <span class="token operator">=</span> opener<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>    html <span class="token operator">=</span> result<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span><span class="token keyword">except</span> URLError <span class="token keyword">as</span> e<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>reason<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="HTTPError"><a href="#HTTPError" class="headerlink" title="HTTPError"></a>HTTPError</h3><p><code>HTTPError</code>是<code>URLError</code>的子类,专门用来处理<code>HTTP</code>请求错误,例如认证请求失败.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> urllib<span class="token punctuation">.</span>error<span class="token keyword">try</span><span class="token punctuation">:</span>    result <span class="token operator">=</span> opener<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>    html <span class="token operator">=</span> result<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span><span class="token keyword">except</span> HTTPError <span class="token keyword">as</span> e<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>reason<span class="token punctuation">,</span>e<span class="token punctuation">.</span>code<span class="token punctuation">,</span>e<span class="token punctuation">.</span>headers<span class="token punctuation">)</span><span class="token keyword">except</span> URLError <span class="token keyword">as</span> e<span class="token punctuation">:</span> <span class="token comment">##如果不是HTTPError,则进入URLError捕获</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>reason<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="解析链接"><a href="#解析链接" class="headerlink" title="解析链接"></a>解析链接</h2><p><code>urllib.parse</code>块定义了处理URL的标准接口,例如实现URL各部分的抽取,合并已经连接转换.</p><h3 id="urlparse"><a href="#urlparse" class="headerlink" title="urlparse"></a>urlparse</h3><p>该方法实现<code>URL</code>的识别和分段</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> urllib<span class="token punctuation">.</span>parse <span class="token keyword">import</span> urlparseresult <span class="token operator">=</span> urlparse<span class="token punctuation">(</span><span class="token string">'https://www.baidu.com/index.html;user?id=5#commemt'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">##&lt;class 'urllib.parse.ParseResult'>,是一个元组,可以使用索引或者序列号访问其中的元素</span><span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token comment">## scheme,netloc,path,params,query fragment</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可得标准链接格式:</p><pre class="line-numbers language-none"><code class="language-none">scheme:&#x2F;&#x2F;netloc&#x2F;path;params?query#fragment<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>urlparse</code>含有三个参数,下面是解释</p><ul><li><strong>urlstring</strong>:待解析的url</li><li><strong>scheme</strong>:默认的协议,如果url没有提供协议则会用这个代替</li><li><strong>allow_fragment</strong>:是否忽略<code>fragment</code></li></ul><h3 id="urlunparse"><a href="#urlunparse" class="headerlink" title="urlunparse"></a>urlunparse</h3><p>此方法用于构造url.参数必须是一个可迭代对象,长度必须为6,否则会抛出异常.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> urllib<span class="token punctuation">.</span>parse <span class="token keyword">import</span> urlunparsestring <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"https"</span><span class="token punctuation">,</span><span class="token string">"www.baidu.com"</span><span class="token punctuation">,</span><span class="token string">"index.html"</span><span class="token punctuation">,</span><span class="token string">"user"</span><span class="token punctuation">,</span><span class="token string">"id=5"</span><span class="token punctuation">,</span><span class="token string">"commemt"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="urlsplit"><a href="#urlsplit" class="headerlink" title="urlsplit"></a>urlsplit</h3><p>和<code>urlparse</code>类似,只不过<code>params</code>不会单独出现,划分为path的一部分,返回结果是<code>SplitResult</code>,和<code>ParseResult</code>类似,既能索引,也可以序列访问.</p><h3 id="urlunsplit"><a href="#urlunsplit" class="headerlink" title="urlunsplit"></a>urlunsplit</h3><p>和<code>urlunparse</code>类似,使用长度为5的可迭代对象.</p><h3 id="urljoin"><a href="#urljoin" class="headerlink" title="urljoin"></a>urljoin</h3><p>该方法需要两个参数,一个是<code>base_url</code>,一个是待修改的链接.该方法会分析<code>base_url</code>中的<code>scheme</code>,<code>netloc</code>和<code>path</code>.如果待修改的链接不含这三个部分中的一个,则补充上去.</p><h3 id="urlencode"><a href="#urlencode" class="headerlink" title="urlencode"></a>urlencode</h3><p>这个方法在<code>GET</code>方法中特别实用</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> urllib<span class="token punctuation">.</span>parse <span class="token keyword">import</span> urlencodequery <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token string">'tn'</span><span class="token punctuation">:</span><span class="token string">'monline_3_dg'</span><span class="token punctuation">,</span>    <span class="token string">'ie'</span><span class="token punctuation">:</span><span class="token string">'utf-8'</span><span class="token punctuation">,</span>    <span class="token string">'wd'</span><span class="token punctuation">:</span><span class="token string">'python'</span><span class="token punctuation">&#125;</span>base_url <span class="token operator">=</span> <span class="token string">'https://www.baidu.com?'</span>url <span class="token operator">=</span> base_url <span class="token operator">+</span> urlencode<span class="token punctuation">(</span>query<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span> <span class="token comment">## https://www.baidu.com?tn=monline_3_dg&amp;ie=utf-8&amp;wd=python</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其作用就是把字典参数链接在url后面</p><h3 id="parse-qs"><a href="#parse-qs" class="headerlink" title="parse_qs"></a>parse_qs</h3><p>反序列化方法,将<code>query</code>参数返回为字典</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> urllib<span class="token punctuation">.</span>parse <span class="token keyword">import</span> parse_qsquery <span class="token operator">=</span> <span class="token string">"tn=monline_3_dg&amp;ie=utf-8&amp;wd=python"</span><span class="token keyword">print</span><span class="token punctuation">(</span>parse_qs<span class="token punctuation">(</span>query<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">## query = &#123;</span>                       <span class="token comment">##    'tn':'monline_3_dg',</span>                       <span class="token comment">##    'ie':'utf-8',</span>                       <span class="token comment">##    'wd':'python'</span>                       <span class="token comment">## &#125; </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="parse-qsl"><a href="#parse-qsl" class="headerlink" title="parse_qsl"></a>parse_qsl</h3><p>将参数转化为元组组成的列表</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> urllib<span class="token punctuation">.</span>parse <span class="token keyword">import</span> parse_qslquery <span class="token operator">=</span> <span class="token string">"tn=monline_3_dg&amp;ie=utf-8&amp;wd=python"</span><span class="token keyword">print</span><span class="token punctuation">(</span>parse_qsl<span class="token punctuation">(</span>query<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">## [('tn','monline_3_dg'),('ie','utf-8'),('wd','python')]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="quote"><a href="#quote" class="headerlink" title="quote"></a>quote</h3><p>将内容转化为<code>URL</code>编码格式.如果<code>URL</code>有中文参数,有可能乱码,所以需要<code>quote</code>将其转化为<code> URL</code>编码</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> url<span class="token punctuation">.</span>parse <span class="token keyword">import</span> quotekeyword <span class="token operator">=</span> <span class="token string">"爬虫"</span>url <span class="token operator">=</span> <span class="token string">'https://www.baidu.com/s?wd='</span> <span class="token operator">+</span> quote<span class="token punctuation">(</span>keyword<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="unquote"><a href="#unquote" class="headerlink" title="unquote"></a>unquote</h3><p>将<code>URL</code>编码转成中文</p><h2 id="分析Robot协议"><a href="#分析Robot协议" class="headerlink" title="分析Robot协议"></a>分析Robot协议</h2><p><code>Robot</code>协议也叫机器人协议,全名网络爬虫排除标准(Robot Exclusion Protocal),用来告诉爬虫那些网页可以抓取,那些不行.通常命名为<code>robot.txt</code>,放在网站根目录.</br><br>爬虫在实际爬取时,会先检查是否存在’robot.txt’,如果有则遵从,没有的话就随意爬取.<br>下面是一个<code>robot.txt</code>的实例</p><pre class="line-numbers language-none"><code class="language-none">User-Agent: * &#x2F;对所有爬虫生效Disallow: &#x2F; #不允许爬取任何页面Allow: &#x2F;public&#x2F; #只能爬取public<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="robotparser"><a href="#robotparser" class="headerlink" title="robotparser"></a>robotparser</h3><p>这个模块用于解析<code>robot.txt</code>文件,来判断是由有权利爬取这个网页.</p><pre class="line-numbers language-none"><code class="language-none">urllib.robotparser.RobotFileParser(url &#x3D; &#39;&#39;) ## 可以不设置url,之后用set_url添加<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以下是<code>RobotFileParset</code>常用方法</p><ul><li><strong>set_url</strong>:设置<code>robot.txt</code>文件链接.</li><li><strong>read</strong>:读取文件并进行分析.这个方法包含读取和分析,所以一定要使用.</li><li><strong>parse</strong>:解析文件,传入其中的参数是文件中某些行的内容.</li><li><strong>can_fetch</strong>:需要两个参数,一个是<code>User-Agent</code>,一个是<code>URL</code>.判断是否能爬取.</li><li><strong>mtime</strong>:返回上次抓取分析文件的时间,如果长时间爬取的话就需要获取最新的<code>robot.txt</code>文件来判断自己爬取的合法性.</li><li><strong>modified</strong>:将当前时间设置为上次抓取分析文件的时间,在长时间爬取中很有用.</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一节主要是<code>urllib</code>的使用,使用略显复杂,后面的<code>requesets</code>模块更加方便,但是对于自定义爬虫这很有用.<br>爬取逻辑分析:<br>判断是否需要验证和代理 -&gt; 根据情况建立HTTPBasicAuthHandler(PasswordMgrWithDefaultRealm)或者ProxyHandler(字典) -&gt; 根据Handler建立opener -&gt; 爬取网页,同时记得捕获异常,根据异常修改爬虫. -&gt;如果需要修改cookie,使用HTTPCookieProcessor(CookieJar类).</p>]]></content>
      
      
      
        <tags>
            
            <tag> spider/crawler </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
